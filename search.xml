<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FPython%2Fmatplotlib.html</url>
    <content type="text"><![CDATA[教學 Import matplotlib.pyplot as pltdata.plot()plt.show() # 與data沒有連結???]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FPython%2Fnumpy%26pandas.html</url>
    <content type="text"><![CDATA[週莫煩 numpy主要用來處理矩陣 pandas 架構numpy之上 更適合數據應用上的操作 而不僅是數學 替行列矩陣加上了行索引值與列欄位名 矩陣import numpy as nparr = np.array([[1,2,3],[4,5,6]])arr = np.zeros((3,4)) # 3x4全為0的矩陣, ones/empty/rangearr = np.linespace(0, 10, 6).reshape((2,3)) # 0~10 6個元素 轉為2x3的矩陣arr = np.random.random((2,3))print("dim", arr.ndim, "shape", arr.shapre, "size", arr.size, arr.dtype) np.sin(a)a*b # 直接乘法np.dot(a, b) #矩陣乘法a.dot(b)# 合併np.vstack(a,b) # [[a,b]]np.hstack(a,b) # [a,b]np.concatenate(..., axis=0)# 分割np.split(a, 切塊數, axis=0)np.array_split(a, 切塊數, axis=0) #不等量的分割# deep copyb = a.copy()np.nan # NaNnp.sum(a, axis=0) #axis=0/1 行(橫/row)或列(直/column)np.min(a)np.max(a)np.argmin(a) #最小值的索引np.mean(a)np.average(a)np.median(a) #中位數np.cumsum(a) #累加矩陣np.diff(a) #累差矩陣np.transpose(a) #行列反向 等同a.Tnp.clip(a, 3, 9) #&lt;3則為3 &gt;9則為9 a[行][列]a[行,列]for row in arr:for col in arr.T:for item in arr.flat: #flatten()轉為一維 #Pandas import numpy as npimport pandas as pdpd.Series([1,2,3,'a','b','c']) #一維pd.date_range('20180101', periods=6) #一維 6個日期pd.DataFrame(np.random.randn(3,4), index=[0,1,2], columns=['a','b','c']) # 二維 行索引為012 列欄位為abcpd.DataFrame(&#123;'date': pd.Timestamp('20180101'),'type': pd.Categorical("a", "b", "b", "a")&#125;)data.dtypes # 取得列的所以類型data.index # 取得行索引值data.columns # 取得列欄位名data.values # 取每一行的valuedata.describe() # 取個欄位的統計值data.sort_index(axis=0, ascending=True) # 以行索引排序data.sort_values(by='type') # 以欄位內的值排序 取(選)資料data['type']data.typedata[0:3]# by label namedata.loc['20180101', ['type']]# by index positiondata.iloc[0, 1:2] # 0行的12列# by mixed selectiondata.ix[0, ['type', 'date']]# filterdata[data.type=='a']# 取前五筆data.head() data.dropna(asix=0, how='any') # 丟掉行中若出現nan的行data.fillna(value=0)data.isnull()np.any(data.isnull()) == True 讀取文件資料data = pd.read_csv('file.csv') # html/excel/json...data.to_pickle('file.pickle') 合併concat merge data = pd.concat([data1,data2], axis=0, ignore_index=True) # 合併行# join參數# outer:沒交集的欄位用nan # inner:沒交集的欄位直接刪除join&#123;'outer', 'inner'&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FPython%2FThread%26Process.html</url>
    <content type="text"><![CDATA[Mutli-Thread Python的Thread其實受限於GIL(Global Interpreter Lock全局鎖)的設計 多執行緒同時僅能有一個執行緒被執行 等同於多執行分切cpu時間 使得thread的用法僅在處理大量IO時能得到好處GIL的限制應該是來自於python最初的設計架構 要真正能多執行緒必須靠multi-processing import threadingimport timedef work(): time.sleep(1) print("working...")th = threading.Thread(target=work, name="worker")th.start()th.join() multi-thread搭配queue做為運算結果的回傳 from queue import Queueq = Queue()q.put(a)a = q.get() Multi-Processing 用法同Thread 但進程間無法共用變數 需透過shared memory import multiprocessing as mpimport timedef work(a, b): time.sleep(1) print("working...")q = mp.Queue()th = mp.Process(target=work, args=(1,2))th.start()th.join() import multiprocessing as mpdef work(a): return a*a pool = mp.Pool(processes=2) # 進程池# 方法1: 用map切分任務res = pool.map(work, range(10))print(res)# [0, 1, 4, 9 ....]# 方法2: 只能處理一個res = pool.apply_async(work, (2,))# 4# 方法3: 迴圈式ress = [pool.apply_async(work, (i,)) for i in range(10)]print([res.get for res in ress]) shared memoryimport multiprocessing as mpsv = mp.Value('d', 1.5)sv = mp.Array('i', [1,2,3]) #只能一維# sv在process間是共用的sv.value = 1 #取值與賦值要加.value lockimport multiprocessing as mplock = mp.Lock()lock.acquire() # locklock.release() # unlock]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FPython%2FTkinter.html</url>
    <content type="text"><![CDATA[Tkinter (念T.K.inter或kin.ter)GUI介面 import tkinter as tk# 建立視窗win = tk.Tk()win.title = "title"win.geometry("200x100")# 建立labellab = tk.Label(win, text="label")lab.pack()svar = tk.StringVar()lab = tk.Label(win, textvariable=svar)# 建立buttondef clickme: svar.set("clicked!") btn = tk.Button(win, text="ClickMe", command=clickme)btn.pack()# 啟動windowwin.mainloop()popwin = tk.TopLevel(win)popwin.destory() input / textareainp = tk.Entry(win, show='None')text = tk.Text(win, hight=2) # 寬高為字數text.insert('insert', 123) # 插入在游標處text.insert('end', 456) # 插入在結尾text.insert(1.5, 456) # 插入在第一行第五個字元 Listboxlist = tk.StringVar()list.set((1,2,3,4,5))listbox = tk.Listbox(win, listvariable=list)sel = listbox.get(listbox.curselection()) RadioButtonvar = tk.StringVar()ra1 = tk.RadioButton(win, text="op1", value=1, variable=var) Othres Scale 即seek bar CheckButton Canvascanvas = tk.Canvas(win, bg='blue', height=200, width=200)tkimg = tk.PhotoImage(file="img.png")canvas.create_image(0, 0, anchor="nw", image=tkimg)canvas.pack() Menumenubar = tk.Menu(win)menuA = tk.Menu(menubar)menuB = tk.Menu(menubar)menubar.add_casecade(label="File", menu=menuA)menubar.add_casecade(label="Edit", menu=menuB)menuA.add_command(label="open", command=openfile)menuA.add_separator()menuA.add_command(label="exit", command=win.quit)win.config(menu=menubar) Frame類似一個空間規劃(view或layout的概念) messageboxtk.messagebox.showinfo(title="", message="")# showwarning / showerror / askquestion / askyesno# asktrycancel / askokcancel pack元件放置方式 pack(side="top")grid(row=1, column=1)place(x=0, y=0, anchor='nw')]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FPython%2FPython.html</url>
    <content type="text"><![CDATA[參考週莫煩 Python為直譯語言 沒有bytecode 須透過直譯器執行(又稱解釋器) CPython為C編寫的直譯器 Jython為Java編寫 基本# pip3為python3預安裝的模塊管理cli程式sudo pip3 install numpysudo pip3 install -U numpy # update# 使py為可執行chmod +x hello.py #!/usr/bin/python #用來提示使用的直譯器''' #多行註解 (三個單或雙引號)變數不需要宣告類型 類型可以多載block用tab(四個空格)縮排約束'''x = Nonex = """abc123""" # 多行字串print("hello", x)print(x, end="") # 不換行a = b = c = 1a, b, c = 1, 2, 3x = int(input("input your age"))# list 同array 可用+號 insert/remove/index/count/sortx = [1,2,3,4,5]x = range(3) # 回傳[0,1,2]x = x[1:3] #取索引1~2 (半開/不包含最後一個)x[1:3] = [] #相當於刪除x = x[-1] # 負號為從尾端索引length = len(x)# tuple(元祖) 同list 但不可修改x = (1,2,3)x = (1,) # 如果只有一個 後面一定要加,# setx = &#123;1,2,3&#125;x = set("hello") # &#123;"l", "h" "e" "o"&#125;# dictionary (map)x = &#123;"jim": 18, "john": 15&#125;del x["john"]if True:elif False:else:# else還可用於for/while/try做為final blockfor x in range(2): print(x) pass # 類似break但會執行完該次loop才離開else # 離開loop時執行 print("end of loop") while c&lt;10: breakelse def myfunc(x, y=3): # 函數可巢狀定義 global a # 可以access到caller的a變數 print(x) return 0 myfunc(x=1) # 可指定參數名 ** # 次方// # 除法取整數% # 除法取於數 Exceptiontry: file = open("", 'r')except Exception as e: print(e) Classclass MyCls name = "" __init__(self, name): self.name = name def myfun(self): # self為this用途 呼叫時不需要 print(self.name) # class內的屬性一定要加selfc = MyCls("jim")c.myfun()#判斷類型isinstance(1, int) #回傳truetype(1) #回傳類型 &lt;class 'int'&gt; 系統變數__name__ # Thread nameimport syssys.path # 模組搜尋路徑# 外部模組通常在python/site-packages下sys.argv # 命令列參數 模組sys.path.append("MyModuleFolder") #加入自定義模組路徑import PYTHON_FILENAME #不用副檔名import PYTHON_FILENAME as modfrom PYTHON_FILENAME import * # 之後呼叫不用模組名from PYTHON_FILENAME import func Package在目錄底下新增init.py及可使該目錄成為package 用法與module一樣 只是多一層package name lambdafunc = lambda x,y: x+y copya = [1,2,3]b = aprint(id(a) + " == " + id(b)) # a與b有同樣的索引 表示指向同樣的資料 import copya = [1,2,[3]]shallow = copy.copy(a) # 僅能copy一層deep = copy.deepcopy(a) file#離開with會自動file closewith open("file.txt", "r") as f: str = f.readline() #讀單行 回傳str list = f.readlines() #讀全行 回傳list pickle儲存變數到檔案 import picklea = [1,2,3]f = open("file.pick", "wb")pickle.dump(a, f)f = open("file.pick", "rb")a = pickle.load(f) RegExref import re]]></content>
  </entry>
  <entry>
    <title><![CDATA[區塊鏈Demo架構]]></title>
    <url>%2Fhome%2F%2FCoinPocket%2F%E5%8D%80%E5%A1%8A%E9%8F%88Demo%E6%9E%B6%E6%A7%8B.html</url>
    <content type="text"><![CDATA[簡介區塊鏈節點 礦工節點 主要負責區塊鏈資料的維護 私有節點 用以介接應用程式與區塊鏈 (建立帳號(keystore)/執行交易/取得資訊) 應用程式接入區塊鏈的方法 自建私有節點加入區塊網絡 透過第三方節點開放的rpc介面 智能合約 如同一個可程式化的資料表(記帳人+帳本) 在區塊鏈裡如一個’公證人’帳號 該帳號如同一記帳人(帳本) 與該帳號的交易行為就如同執行合約一般 其執行結果同樣寫入區塊鏈 私有鏈優點 所有節點都自己安插 安全 缺點 大致行為無異於分散式資料庫 區塊鏈形同虛設 公有鏈優點 依附於乙太坊公共網絡 與第三方應用的結合較為多元 缺點 在乙太坊公共網絡執行交易須支付乙太幣 Demo 原始碼私鏈(PoA)Docker用戶服務器Android用戶端 附錄電子錢包應用BitoEx 台廠 幣託 以email申請一個帳號 透過web/phone介面查詢 台灣可透過FamiPort繳費&gt;虛擬帳號&gt;廠商代號&gt;輸入手機號碼&gt;買多少台幣的BTC 現金結帳取得收據與手機簡訊 回BitoEx介面&gt;超商兌換 可綁定信用卡/銀行帳號(可出帳) 等於私鑰託管給BitoEx MaiCoin 台廠Coinbase 美加密貨幣交易所 可綁定信用卡/銀行帳號/paypal/wire transfer 台灣第三方金流服務台景達TaiPay智付通Spgateway綠界ECPay]]></content>
  </entry>
  <entry>
    <title><![CDATA[AWS EC2]]></title>
    <url>%2Fhome%2F%2FCoinPocket%2FAWS.html</url>
    <content type="text"><![CDATA[#連接# (Permissions too open)chmod 0600 ~/Downloads/AwsKeyStore.pem# 用key連接ssh進入主機ssh -i "~/Downloads/AwsKeyStore.pem" ec2-user@ec2-18-221-14-16.us-east-2.compute.amazonaws.com# 透過security group的設定控制port的開放與否 #安裝Docker 安装Ubuntu 系列安裝 Docker chmod +x demo.sh# 安裝yumrpm -qa | grep yum# 切換到super usersudo su# 安裝dockeryum -y install docker-io# 安裝docker-composesudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /bin/docker-compose# 啟動docker daemondservice docker startsudo service docker start# 或sudo dockerd# 安裝gityum install git-core #安裝最新版nodejsapt-get update apt-get install -y python-software-properties software-properties-common add-apt-repository ppa:chris-lea/node.js apt-get update apt-get install nodejs #方法二cd ~curl -sL https://deb.nodesource.com/setup_8.x -o nodesource_setup.shbash nodesource_setup.shapt-get install nodejs#或...curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash - #安裝mongodb yum -y install mongodb-orgservice mongod start #安裝其他 npm i -g trufflenpm install -g ethereumjs-testrpctestrpc #操作dockergit clone https://github.com/jimliuxyz/coinpocket.gitgit clone https://github.com/jimliuxyz/ethereum-poa-docker.git# 或 下載imagedocker pull jlxyz/coinpocket #bash# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/.local/bin:$HOME/binexport DOCKER_HOST=127.0.0.1export PATH yum-config-manager \ –add-repo \ https://download.docker.com/linux/centos/docker-ce.repo # renice -n +10 -p 22609renice -n +10 -p 22751 異常用newAccount函數測試區塊鏈 通常會成功一次 之後節點似乎會自己死掉 const Web3 = require('web3')const httpsoc = `http://127.0.0.1:8545`const provider = new Web3.providers.HttpProvider(httpsoc);const web3 = new Web3(provider);console.log(`web3.eth.coinbase : $&#123;web3.eth.coinbase&#125;`)setTimeout(async () =&gt; &#123; console.log("A") let account = await web3.personal.newAccount(""); console.log("B ", account)&#125;, 1000); (node:3029) UnhandledPromiseRejectionWarning: Error: Invalid JSON RPC response: undefined at Object.InvalidResponse (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/errors.js:38:16) at HttpProvider.send (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/httpprovider.js:91:22) at RequestManager.send (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/requestmanager.js:58:32) at Personal.send [as newAccount] (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/method.js:145:58) at Timeout.setTimeout [as _onTimeout] (/home/ubuntu/coinpocket/test.js:18:37) #安裝web3@1.0.0 yum install gcc-c++sudo npm install --save web3@1.0.0-beta.26 --unsafe-perm --verbosesudo npm install --save web3@0.19.0]]></content>
  </entry>
  <entry>
    <title><![CDATA[MWeb]]></title>
    <url>%2Fhome%2F%2FSingle%2FMWeb%E7%95%AB%E5%9C%96.html</url>
    <content type="text"><![CDATA[教學 @startumlnode node1node node2node node3node node4node node5node1 -- node2node1 .. node3node1 ~~ node4node1 == node5@enduml graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; 範例 option = &#123; title : &#123; text: &apos;某地区蒸发量和降水量&apos;, subtext: &apos;纯属虚构&apos; &#125;, tooltip : &#123; trigger: &apos;axis&apos; &#125;, legend: &#123; data:[&apos;蒸发量&apos;,&apos;降水量&apos;] &#125;, toolbox: &#123; show : true, feature : &#123; dataView : &#123;show: true, readOnly: false&#125;, magicType : &#123;show: true, type: [&apos;line&apos;, &apos;bar&apos;]&#125;, restore : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125; &#125; &#125;, calculable : true, xAxis : [ &#123; type : &apos;category&apos;, data : [&apos;1月&apos;,&apos;2月&apos;,&apos;3月&apos;,&apos;4月&apos;,&apos;5月&apos;,&apos;6月&apos;,&apos;7月&apos;,&apos;8月&apos;,&apos;9月&apos;,&apos;10月&apos;,&apos;11月&apos;,&apos;12月&apos;] &#125; ], yAxis : [ &#123; type : &apos;value&apos; &#125; ], series : [ &#123; name:&apos;蒸发量&apos;, type:&apos;bar&apos;, data:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3], markPoint : &#123; data : [ &#123;type : &apos;max&apos;, name: &apos;最大值&apos;&#125;, &#123;type : &apos;min&apos;, name: &apos;最小值&apos;&#125; ] &#125;, markLine : &#123; data : [ &#123;type : &apos;average&apos;, name: &apos;平均值&apos;&#125; ] &#125; &#125;, &#123; name:&apos;降水量&apos;, type:&apos;bar&apos;, data:[2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3], markPoint : &#123; data : [ &#123;name : &apos;年最高&apos;, value : 182.2, xAxis: 7, yAxis: 183&#125;, &#123;name : &apos;年最低&apos;, value : 2.3, xAxis: 11, yAxis: 3&#125; ] &#125;, markLine : &#123; data : [ &#123;type : &apos;average&apos;, name : &apos;平均值&apos;&#125; ] &#125; &#125; ]&#125;; 张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
  </entry>
  <entry>
    <title><![CDATA[Capgemini-AIE/ethereum-docker]]></title>
    <url>%2Fhome%2F%2FCoinPocket%2Fethereum-docker(Capgemini-AIE).html</url>
    <content type="text"><![CDATA[ethereum-docker中文 docker stop $(docker ps -a -q)docker rm $(docker ps -a -q)#強制移除所有imagesdocker rmi -f $(docker images -q)#啟動docker-compose.ymldocker-compose up -d 基本上會啟動3個服務bootstrap 對外開放8545 ethereumdocker_eth_1 礦工節點 netstats http://localhost:3000 #bootstrap #啟動單一節點docker-compose up bootstrapdocker-compose up ethereumdocker_eth_1#關閉或移除所有containerdocker-compose stopdocker-compose rmdocker-compose killdocker exec -it bootstrap /bin/bashdocker exec -it bootstrap geth attach ipc://root/.ethereum/devchain/geth.ipcdocker exec -it ethereumdocker_eth_1 geth attach ipc://root/.ethereum/devchain/geth.ipc#???docker logs --follow bootstrap admin.nodeInfo.enodeeth.miningminer.start()eth.coinbaseeth.accounts[0]personal.unlockAccount(web3.eth.accounts[0])personal.unlockAccount(web3.eth.accounts[0], &quot;&quot;, 99999999)eth.pendingTransactionsadmin.addPeer(&quot;enode://6814e667f9feef605b9f168d7ea51a5b7d555936974683e51fab1d8d3d4ac9be2f098405b8c17024ba3800a30ce308470b006bb322bcc1b2918b40575c39cab2@127.0.0.1:30303&quot;)admin.peers#授權挖礦帳號clique.propose(&quot;0x0fe2d8747d24156b342c9fa5c5e7138cf4047a8d&quot;, true) 挖礦權限(PoA)挖礦權限跟節點無關 跟節點上eth.coinbase有關(即miner.setEtherbase綁定的帳戶) #取得當下礦工帳號eth.coinbase#設定礦工帳號 (coinbase)miner.setEtherbase(web3.eth.accounts[0])#設定後最好重新stop/startminer.start()#授權其他帳號挖礦clique.propose(web3.eth.accounts[1], true) bootnode#產生一組key並存到bootnode.key中#該key可在啟動geth時以nodekeyhex帶入 之後節點就會有固定的enodebootnode -genkey bootnode.key#091bd6067cb4612df85d9c1ff85cc47f259ced4d4cd99816b14f35650f59c322#以該key產生enode (主要是@前的數字)bootnode -nodekeyhex 091bd6067....INFO [05-03|16:57:03] UDP listener up self=enode://288b972....@[::]:30301 副錄… (PoW模式) 挖礦很慢 建立第一個區塊都長達數分鐘 感覺在discover找其他節點 想要做block sync?換chainId與difficulty都沒改善 執行合約函數時gas不足 gas required exceeds allowance or always failing transaction兩種可能: gas limit真的下少了 合約函數寫錯導致注定失敗 例如require(0==1) 下載舊版本的docker image 以下載ethereum/client-go為例查版本號 docker pull ethereum/client-go:v1.8.6 puppeth做出的json多包了一層docker compose忽略修改後的dockerfile#停止docker-compose down#重做docker-compose build --no-cachedocker-compose up -d --force-recreate]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FDocker.html</url>
    <content type="text"><![CDATA[簡易示範 #Dcokerfile #以'./Dockerfile'建立imagedocker build -t coinpocket .#docker run -p 8081:8081 -d coinpocket#指定啟動container執行bash (跳過預設的命令)docker run -it coinpocket /bin/bash#進入執行中的container的bashdocker exec -it 047 /bin/bash]]></content>
  </entry>
  <entry>
    <title><![CDATA[Coinpocket開發紀錄]]></title>
    <url>%2Fhome%2F%2FCoinPocket%2F%E9%96%8B%E7%99%BC%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[區塊鏈技術變化太快 文件 API 最好參考官方的 不然會吃屎 dockerfile範例 nodejs多執行緒cluster/pm2 nodejs事件迴圈/同步異步/耗時任務 怪事remix執行tx只要設Value都會有gas不足的問題 (所以不好測payable?/聽說跟連接方式有關)ganache的gas limit似乎是指節點執行tx的最大油耗 若太小很容易執行失敗//best兩行assign對調將出現&quot;out of gas&quot; (用法上沒有邏輯 純粹好奇)uint[] best;function func()&#123; uint[3] memory a = [uint(1), 2, 3]; best = new uint[](2); best = a; report(best);&#125; vscode的intellisense沒反應? require來源不是node_module中的一定要加. require("server/test.js") //錯誤!!!require("./server/test.js") //正確 The path /etc/localtime is not shared from OS X and is not known to Docker Add -e TZ=ls -la /etc/localtime | cut -d/ -f8-9 to the docker run command line vscode的intellisense與JsDoc搭配ref /** * @param userInfo - Information about the user. * @param userInfo.name - The name of the user. * @param userInfo.email - The email of the user. */function test(userInfo) &#123;&#125;/** * @typedef &#123;object&#125; TestConfig * @property &#123;string&#125; name * @property &#123;number&#125; gold * @typedef &#123;object&#125; TestConfig2 * @property &#123;string&#125; name2 * @property &#123;number&#125; gold2 * @param &#123;TestConfig&#125; config - 註解1 * @param &#123;TestConfig2&#125; config2 - 註解2 */function test(config, config2) &#123;&#125;@param &#123;number|undefined&#125; ...@param &#123;Object.&lt;string, number&gt;&#125; dict ...@type &#123;string&#125; ... //for one var 自創加密貨幣 (TutorialToken)truffle範例 tutorialtoken-box openzeppelin完整步驟 架構 : 本地端網頁透過websocket連本地MetaMask再連到Ganache的測試環境(節點)上本地端網頁 : 由truffle產生 主要機制在於連接MetaMask 加載合約.jsontruffle : 網頁上線前 還可幫忙編譯合約與佈建openzeppelin : 合約lib 提供標準加密貨幣的規格讓使用者繼承 //下載套用tutorialtokentruffle unbox tutorialtoken//編譯合約與發佈truffle migrate --reset//執行本地端網頁伺服器npm run dev CoinPocket範例pragma solidity ^0.4.7;contract CoinPocket &#123; event txlog(string dtypes, string action, uint amount); uint constant DTYPELEN = 2; string[] dtypes = [&quot;TWD&quot;, &quot;USD&quot;]; enum DollarType&#123; TWD, USD, _END &#125; struct Account &#123; uint[DTYPELEN] dollar; &#125; constructor() public&#123; users[this].dollar[uint(DollarType.TWD)] = 5000; users[this].dollar[uint(DollarType.USD)] = 3000; &#125; mapping (address =&gt; Account) users; modifier checkType(uint dtype)&#123; require(dtype&gt;=0 &amp;&amp; dtype&lt;dtypes.length &amp;&amp; DTYPELEN == dtypes.length &amp;&amp; DTYPELEN == uint(DollarType._END)-1 , &quot;dtype error!&quot;); _; &#125; modifier enought(uint dtype, uint amount)&#123; require(users[msg.sender].dollar[dtype]&gt;=amount , &quot;insufficient balance!&quot;); require(users[this].dollar[dtype]&gt;=amount , &quot;insufficient balance of contract!!!&quot;); _; &#125; function deposit(uint dtype, uint amount) checkType(dtype) public&#123; users[msg.sender].dollar[dtype] += amount; users[this].dollar[dtype] += amount; emit txlog(dtypes[dtype], &quot;deposit&quot;, amount); &#125; function withdraw(uint dtype, uint amount) checkType(dtype) enought(dtype, amount) public&#123; users[msg.sender].dollar[dtype] -= amount; users[this].dollar[dtype] -= amount; emit txlog(dtypes[dtype], &quot;withdraw&quot;, amount); &#125; function detail() constant public returns(uint[DTYPELEN])&#123; return users[msg.sender].dollar; &#125; function detail_pool() constant public returns(uint[DTYPELEN])&#123; return users[this].dollar; &#125; function test1() pure public returns(string)&#123; return &quot;~~It&apos;s CoinPocket!!&quot;; &#125;&#125; truffle migrate失敗 has not been deployed to detected network (network/artifact mismatch) # 1.Remove the build folderrm -r build/truffle compiletruffle migrate# 2.Usetruffle migrate --reset --all 直接用web3建立合約const fs = require('fs');const solc = require('solc');const Web3 = require('web3');/** * prepare build folder */fs.existsSync('./build') || fs.mkdirSync('./build')fs.existsSync('./build/contracts') || fs.mkdirSync('./build/contracts')/* * connect to ethereum node */const ethereumUri = 'http://localhost:8545';let web3 = new Web3();web3.setProvider(new web3.providers.HttpProvider(ethereumUri));if (!web3.isConnected()) throw new Error('unable to connect to ethereum node at ' + ethereumUri);var address = web3.eth.coinbase/* * Compile Contract and Fetch ABI, bytecode */let source = fs.readFileSync("./contracts/CoinPocket.sol", 'utf8');console.log('compiling contract...');let compiledContract = solc.compile(source);console.log('done');for (let contractName in compiledContract.contracts) &#123; var bytecode = compiledContract.contracts[contractName].bytecode; var abi = JSON.parse(compiledContract.contracts[contractName].interface); //write to local fs let data = &#123;contractName, abi, bytecode&#125; fs.writeFileSync('./build/contracts/' + contractName + '.json' , JSON.stringify(data, undefined, 2) , &#123;encoding: 'utf-8'&#125;);&#125;/* * Doploy to blockchain network */let gasEstimate = web3.eth.estimateGas(&#123;data: '0x' + bytecode&#125;);console.log('gasEstimate = ' + gasEstimate);let MyContract = web3.eth.contract(abi);console.log('deploying contract...');let myContractReturned = MyContract.new([], &#123; from: address, data: '0x'+ bytecode, gas: gasEstimate + 50000&#125;, function (err, myContract) &#123; if (!err) &#123; // NOTE: The callback will fire twice! // Once the contract has the transactionHash property set and once its deployed on an address. // e.g. check tx hash on the first call (transaction send) if (!myContract.address) &#123; console.log(`myContract.transactionHash = $&#123;myContract.transactionHash&#125;`); // The hash of the transaction, which deploys the contract // check address on the second call (contract deployed) &#125; else &#123; console.log(`myContract.address = $&#123;myContract.address&#125;`); // the contract address global.contractAddress = myContract.address; &#125; // Note that the returned "myContractReturned" === "myContract", // so the returned "myContractReturned" object will also get the address set. &#125; else &#123; console.log(err); &#125;&#125;);(function wait () &#123; setTimeout(wait, 1000);&#125;)(); brew安裝舊版軟體以安裝舊版docker為例 Formula : 指可安裝軟體的名稱 #找到Formula的rb檔案的git連結brew cask info docker#連入該git連結 按history找到自己要的版本 按view瀏覽並複製下整份code#https://github.com/caskroom/homebrew-cask/blob/master/Casks/docker.rb#在本機裡自建一個.rb檔 把複製的code貼上(cask 'docker' do改為'docker_old')cat &gt; /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/docker_old.rb#指定rb路徑做安裝brew cask install /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/docker_old.rb #安裝mongodb#官網下載安裝#主程式移動到/usr/local/下sudo mv mongodb-osx-x86_64-3.6.4/ /usr/local/mongodb#建立db目錄sudo mkdir -p /data/db#編輯.bash_profilecode .bash_profile#添加內容export MONGO_PATH=/usr/local/mongodbexport PATH=$PATH:$MONGO_PATH/bin#啟動daemon程式source .bash_profilemongod#預設port:27017]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ethereum]]></title>
    <url>%2Fhome%2F%2FFinTech%2Fethereum.html</url>
    <content type="text"><![CDATA[節點軟體 節點的核心是geth MacOs安裝 安裝(以Ubuntu為例)#ppa源 : 非Ubuntu官方上架的軟體安裝來源(Personal Package Archive)#software-properties-common為add-apt-repository的依賴sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install ethereum 簡易安裝缺bootnode, evm, disasm, rlpdump, ethtest… apt-get install geth 編譯#安裝golang編譯器sudo apt-get install -y build-essential golangcd go-ethereummake geth 官方還有提供Docker Image在Hub上 合約結構 合約也有自己的一個account 把他當人看 (這個觀念很重要!!!!!!) transaction為一個動作(交易)的執行 例如轉帳/建合約/呼叫合約 就是一個transaction 任何帳號都能發起transaction呼叫合約函數 且不能確定會有幾個節點同時執行合約 但最終只會有一個勝出 solidity仍在演化中 語法或結構隨時都會進化 只要有寫入操作都會消耗gas 若是在不允許消耗gas的函數(宣告為constant或fallback函數)中做寫入操作將導致失敗難以察覺 solidity中文簡介 pragma solidity ^0.4.2;//引用其他合約import "Another.sol"contract Test &#123; //狀態變數(state) //int/uint/byte/bool/string/struct/address/mapping //基本上允許不初始化 即'零態' 但array會報錯 //var:賦值後才確定型別(棄用) address public owner; //相當於uint160 (20byte) //事件 (會將參數寫到transaction receipt作為收據紀錄) //客戶端可以訂閱(watch)這個event (當transaction被放到blockchain後) event Becalled(address indexed caller, bytes message); //枚舉 (值為uint) enum State &#123;Ready, Doing, Done&#125; //key value pair (初值為0)(不需初始化) mapping (address =&gt; userInfo) public users; //array (初值為0,可動態,有維度,刪除元素時會shift) uint[] best; //動態陣列類似於arraylist 用push新增 uint[5] top5; function func()&#123; uint[3] memory a = [uint(1), 2, 3]; //左右必須對稱; uint(1)為顯式轉型 best = a; best = new uint[](2); //用new初始化陣列; 宣告2個元素的陣列 &#125; string str = '123' // ascii 非 unicode bytes(str)[2] //string操作通常要轉為bytes for(int i=0; i&lt;2000; i++)&#123; &#125; //hex字串轉bytes bytes memory signedString =hex"f4128988cbe7df8...."; //結構 (如同原生型態 賦值於變數時會被拷貝) (只有internal函數能回傳struct) struct Member &#123; string name; uint age; bytes12 phone; address addr; &#125; //建構子 constructor() &#123; //不能用this 不能做自己的external call &#125; //呼叫函數時用於檢查狀態 類似處理assertion //一個函數可以有多個modifier 也可以覆寫父合約的modifier modifier beforeCall &#123; if(msg.sender != owner) throw; //原函數尚未執行 _; //&lt;-表示暫時返回原函數執行 //原函數執行完畢 &#125; //函數 (函數內任何變數其作用域為整個函數 沒有block概念) function testFunc() beforeCall &#123; Member memory s = Member(&#123; age : 10, name : "Jack", &#125;); Member memory s = Member("Test", 10,...); Becalled(msg.sender, msg.data); &#125; //storage修飾傳入的是一個field(status) (僅能internal或private) function modifyX(uint[] storage _x) internal &#123;...&#125; //fallback function 當找不到叫用的函數(例如有人轉帳到合約中)或寫錯函數名則會呼叫這個函數 function()&#123; throw; //避免合約被當成一般帳戶被入帳 而之後無法出帳 &#125;&#125; memory / storage 僅針對struct與array設計 memory : 記憶體變數 如同一般程式語言 不能宣告做為field storage : 永久儲存體變數 將寫入區塊 兩者轉換都是以copy的方式 (賦值 或 經由函數傳遞時) memory變數丟到另一個函數參數也是memory 兩個會是同一塊memory (其他程式語言處理struct與array也大致如此) contract SimpleAssign&#123; //field(status)一律為storage變數 struct S&#123; string a; uint b; &#125; uint x; function assign(S s) internal&#123; //參數變數(s)預設是memory(即一份copy) //struct區域變數(tmp)預設是storage [為何要預設為storage???] S tmp = s; //報錯 //1.必須強制將傳入參數設為storage (該函數必須為internal) //2.或將tmp設為memory S memory tmp2 = S(&quot;memory&quot;, 0); //在記憶體中使用struct &#125; //struct宣告該為memory或storage跟宣告的地方與使用的方式有關 //1.丟進函數前是什麼 2.進入函數時是什麼 3.進入函數後是什麼&#125; 合約產生合約import &quot;./MyCont.sol&quot;;...address caddr = new MyCont() //部署合約 先取得addressMyCont cont = MyCont(caddr) //才能建立實體叫用 fallback函數 當呼叫一個合約中沒有的函數 會執行fallback當執行address.send()時固定會執行fallbackfallback有2300gas的限制 故大致用於事件紀錄 事件 每次交易可以紀錄receipt(收據) 取回時為json格式每次交易可以觸發多次event 產生多個log參數預設存到data欄位 例如event(A,B) 造成 {data:’AB’} 無分隔符號如果參數前綴indexed可將參數存到topic欄位(有分隔符號) 預設第一個是event的識別字 剩下3個可以用事件在客戶端可被監聽(event callback) this 合約的執行環境 等同合約的addressthis不同 表示storage不同 讀寫出的東西就不同 Contract A&#123; function func2() internal &#123;&#125; function func1()&#123; #func2被以internal的方式呼叫 func2(); #func2被以external的方式呼叫 (若func2強制宣告為internal則會報錯) this.func2(); &#125;&#125; send()與transfer() 都用於傳送eth 有2300gas限制 send() 失敗回傳falsetransfer() 失敗直接throw(建議使用)#msg.sender傳送1wei給addraddr.send(1) assert與require與throw 都是assertion的處理throw偏向意外會被取走等同gasLimit的手續費 (正常是gasUsed)assert與throw一樣 (應注意而未注意)require為gasUsed (需求不符)(可傳錯誤訊息)revert() 同require 只是沒有輸入參數(可傳錯誤訊息) call()與delagatecall()示例除了用send()與transfer()做tx外 call也可以達成 A為caller B為someone caller執行someone.call(&quot;somefunc&quot;)&gt; 在somefunc中 : this為someone ; msg.sender為caller&gt; 兩合約各自安全&gt; 可以串addr.gas().value().call(...) 指定gas與value caller執行someone.callcode(&quot;somefunc&quot;)&gt; 在somefunc中 : this為caller 等同於caller將somefunc嵌入自己的函數中&gt; caller的變數有被覆寫的風險 `somefunc中沒有msg訪問權` (已納入棄用) caller執行someone.delagatecall(&quot;somefunc&quot;)&gt; 同callcode 差別在有msg訪問權 (msg持續是caller中的msg) #increaseAge為合約內的一個函數bytes4 methodId = bytes4(keccak256(&quot;increaseAge(string,uint256)&quot;));#addr為合約帳戶 固定返回bool表示成敗bool res = addr.call(methodId,&quot;jack&quot;, 1);addr.call(&quot;myfunc&quot;, &quot;str&quot;);#設定gas limit與傳輸的eth值addr.call.gas(1000000).value(1 ether)(&quot;myfunc&quot;, &quot;str&quot;);addr.delagatecall.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;) 函數可見性(visibility)參考 public 可被外界使用(預設)(是internal也是external)private 合約內部使用internal - 自己與其繼承合約external 僅供外部合約使用 (內部硬要呼叫要用this.)public用於field可讓編譯器建立訪問器(getter) (array一次僅能get一個元素)(mapping要看key/value的型別)(struct也是看型別)合約內回傳的資料型態較不受限 合約外(external call)通常是基本型沒問題 其他最好使用時測試 因為solidity變化太快 函數屬性標示 payable 只要函數涉及msg.value 就要加payable constant 宣告該函數不需寫資料到區塊鏈 不需身份識別與gas 原本storage變數也不會寫入!!!! 在remix控制台可以看到return值 非constant 即可能需要寫入資料的函數 必須透過event寫receipt 再讀receipt才能debug payable : constant : 宣告該函數不需寫資料到區塊鏈 不需身份識別與gas (或呼叫時加.call()也行) 物件 單位 : ether finney wei時間 : seconds weeks years now (base on block)msg : 與transaction相關的訊息 (sender:發起人 value:交易的ether)address : 一個帳號地址 (用=0x0來歸零) msg : 呼叫函數時以msg帶入呼叫者與一個ehter valuemsg.sender : 代表執行函數的人(在建構函數時就是部署合約的人)msg.vlaue : msg被傳入的etherthis.balance : 合約餘額address.balance : 帳號餘額address.send(amount) : msg.sender送錢到address (方向邏輯有點相反 特別注意)selfdestruct(addr) : 終結合約(結帳) 將合約balance轉到addr web3.js內部如何包裝交易訊息到節點上執行參考參考 //以呼叫此合約函數為例contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)//建立交易訊息var rawTxn = &#123; nonce: web3.toHex(txnCount), //txnCount可以是當下的交易總筆數 gasPrice: web3.toHex(100000000000), gasLimit: web3.toHex(140000), to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b', //合約帳號 value: web3.toHex(0), //交易金額 data: '0xc7ed0149'+'52616d61....' //合約函數的hash值的前4byte與參數&#125;;//合約函數的hash值web3.sha3('voteForCandidate(bytes32 candidate)')='0xc7ed014922ff9493a686391b70ca0e8bb7e80f91c98a5cd3d285778ab2e245b3'//合約參數被串接為每個32byte的字串0x52616d610000000000....//將privateKey從字串轉為bytesconst privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')//產生交易物件const txn = new EthereumTx(rawTxn)//簽名該交易txn.sign(privateKey)//序列化const serializedTxn = txn.serialize()//取得交易id (往後以此id查找交易訊息/狀態)transactionId = sha3(serializedTxn)//將serializedTxn傳到任何一個節點即可 (傳到json-rpc??) 模組安全性防禦建議 eth：交易與區塊 net：p2p網絡狀態 admin：管理節點 &lt;危險權限&gt; miner：挖礦 personal：帳戶管理 &lt;危險權限&gt; txpool：交易內存池 web3：包含以上 幣值單位轉換 私有鏈ref 步驟簡述 安裝節點軟體 geth 建立account (keystore) 建立創世區塊 custom_genesis.json 以創世區塊初始化節點 啟動節點 建立nodecd /mychainmkdir node1cd node1#以data目錄做為資料與keystore目錄#產生新帳號(HASH)表示這個node的account(address)(通常會前綴0X)#帳號需要搭配一組密碼geth --datadir ./data account new 建立genesis block的設定 初始化時Clique模式需將授權節點的相關資訊放在Block Header中透過puppeth(CLI)按步驟設定 #回到/mychain目錄puppeth#設定network name為mynet 最後會產生mynet.json#至少先需要設定一個節點(account)做為授權seal的節點 初始化節點 用同一個設定檔init各個節點 geth --datadir node1/data init mynet.json 啟動節點cd node1geth --datadir ./data --networkid 55661 --port 2000 console#networkid : 節點間要有共同的id才能互通(1:主網 2:測試)(預設會進到ether主網絡)#port : 即該節點export出的port 做為入口讓其他節點連結 (非rpc-api的port)(預設30303)#console : 表示啟動進入javascript console提示符號 可進行geth內部的控制#rpcapi 'module' : 開啟某module的rpcapi 允許外部連入(預設僅開eth,net,web3)#rpcaddr : localhost或0.0.0.0表示完全對外開放#rpccorsdomain : 指定rpc僅接受某domain#nodiscover : 取消p2p自動搜尋節點#netrestrict : 限制與之連線的節點在某個子網域#bootnodes : 指定啟動時直接連接某些節點#unlock : 解鎖 所有節點都可以miner.start() 但要先unlock 與其他節點連接 執行geth時帶bootnodes參數 進節點console執行admin.addPeer() 設定./data/static-nodes.json #節點格式 enode://&lt;id&gt;@&lt;ip&gt;:&lt;port&gt;#[::]為IPv6的寫法 可能表示localhost或全零enode://e92fd77c6b2df9daff7ac54473c40d1eef18f63eddbd6fadc2d5fd79a5d957e522348314d6bd63c6919e09bd6b2b5e5616d9b8169ab898946a21d0e06abe08ad@61.66.218.xxx:30303 Kademlia(Kad) : P2P技術 NodeID裡包含路由訊息 節點的分類僅是應用上的定義 實際上每個節點都是一個平等的Account Address eth : 一般的用戶端 例如使用電子錢包的人 miner : 礦工 bootstrap 用來形容一個固定節點 當有新節點加入時就找bootstrap console#取得node資訊admin.nodeInfo#加入節點 (表示可以去連別的節點)admin.addPeer#查看連接的節點admin.peers#開始挖礦 初次啟動會產生dag檔miner.start()#設定挖礦入帳的地址miner.setEtherbase(eth.accounts[0])eth.coinbase #對應到setEtherbase#第三方client通常會以miner(節點)的coinbase的地址做為from進行操作 所以需要時必須對該節點unlock#查詢餘額eth.getBalance("&lt;Address&gt;")eth.sendTransaction #回傳transaction的hash 合約回傳值要用event寫到收據中eth.getTransactioneth.pendingTransactionseth.getTransactionReceipteth.estimateGas #估算交易花費eth.getCode("&lt;Address&gt;") #智能合約編譯後會有一個CODE欄位 如果Account能得到code表示他能執行合約內容#建立合約 (之後還需要用new來deploy)eth.contract(abi);#編譯合約?eth.compile.solidity(source_text)#透過node可以做任何事 (某些要解鎖)personal.newAccount()personal.listAccounts#PoA機制中 授權某節點做為minerclique.propose personal.unlockAccount#將某帳號解鎖 privateKey+passphrese#即輸入密碼從keystore中提取private key 解鎖狀態默認是300秒#駭客只要亂槍打鳥 碰巧遇上解鎖的帳號 就不用密碼也可以下達sendTransactionpersonal.unlockAccount("&lt;Address&gt;")#經測試truffle做部署時 可經由remix的網頁(rpc)做解鎖 也可經由節點本地端(ipc) 也就是說只要節點把account解鎖了 就算不同的client進去也能視同該account已解鎖 eth.getBalanceBalance在區塊鏈中預設就是存在的 除字面上作為財產餘額外 Balance也做為買gas驅動節點運作的籌碼 DAG檔 跟挖礦PoW演算法相關的資料集 據說會越漲越大 到GB等級 IPC 用pipefile實現 讀寫這個檔猶如console打字與畫面輸出結果 sendTransaction與callmethod type指的是一個合約函數是不是constant,如果不是,最終一定要用sendTransaction,因為該函數需要寫資料進區塊鏈,寫入動作是規範在交易裡,必須消耗gas(手續費),也需要解鎖發起人帳號的權限(因為要付錢) 另外,寫資料需要區塊鏈的多數共識,操作的結果在web3中是異步事件. // Automatically determines the use of call or sendTransaction based on the method typemyContractInstance.myMethod(param1 [, param2, ...] [, transactionObject] [, defaultBlock] [, callback]); // Explicitly calling this methodmyContractInstance.myMethod.call(param1 [, param2, ...] [, transactionObject] [, defaultBlock] [, callback]); // Explicitly sending a transaction to this methodmyContractInstance.myMethod.sendTransaction(param1 [, param2, ...] [, transactionObject] [, callback]); // Get the call data, so you can call the contract through some other meansvar myCallData = myContractInstance.myMethod.getData(param1 [, param2, ...]);// myCallData = '0x45ff3ff6000000000004545345345345..']]></content>
  </entry>
  <entry>
    <title><![CDATA[區塊鏈]]></title>
    <url>%2Fhome%2F%2FFinTech%2F%E5%8D%80%E5%A1%8A%E9%8F%88.html</url>
    <content type="text"><![CDATA[十分鐘數位加密貨幣課程 Ethereum Wallet 以太幣錢包 區塊鏈代幣平台WAVES區塊鏈原理 ICO(Initial Coin Offering) 以某計畫為基礎 向大眾發起虛擬貨幣的融資 (模仿IPO發股票改發幣)因為區塊鏈的興起 建立虛擬貨幣太容易 加密貨幣 指貨幣機制是經由密碼學等演算法維護 Nonce 一個數挖礦尋找出的一個隨機數可稱為nonce交易時也有一個參數稱nonce 做為總交易的流水號 挖礦難度 尋找一個Nonce能產生HASH值前面產生N個0 (0越多越難找) Hash值通常用SHA-256計算 包含 index+previous block hash+timestamp+data+nonce礦工要找到一個nonce滿足產生的Hash值前N個位數為0 礦池 集結礦工算力 礦場 電費低廉的地方架設礦機 創世區塊(Genesis block) 即第一個區塊 資料 N筆交易-&gt;1筆區塊全部的區塊形成一個帳本(Ledger) Peer節點 一個礦工就是一個節點 主鏈 最長鏈正確性比對大於50% network name 節點網絡名稱 不要跟ip網路搞混 chain/network ID 不明 預設為random 共識機制(勞動證明機制)無論何種共識機制都可能有一個以上的node同時產生block 同時被接到前一block下 出現分歧 挖礦 用來形容以某演算法產生新區塊 (算得慢的node等於做白工) PoW (Proof of work) 即挖礦認證機制/以工作搶快為主耗電ethereum稱為Ethash PoS (Proof of steak) 另一種挖礦認證機制為解決pow耗電不環保的問題 PoA (Proof of Authority) 指定授權某個節點能夠挖礦用seal關鍵字代替挖礦ethereum稱為Clique 分歧導致的問題 使node挖礦效率下降 若分歧持續等量延長 可能表示算法難度或亂數不夠複雜同時挖礦得到的兩個block雖長相不一樣 但內容結果是等效的等待某一分支長過另一分之變成主鏈 模式參考 公有鏈 bitcoin ethereum完全去中心化 透過獎勵機制記帳(PoW) 私有鏈 完全內部節點 但無法竄改資料既然是私有就應該能完全信任 不一定非用上區塊鏈做紀錄 也許分散式資料庫即可 聯盟鏈 適合於機構與機構間 (Proof of Authority)允許更快產生Block 許可鏈 私有鏈 聯盟鏈 都屬於許可鏈 加入的節點 要得到許可 混合鏈 … 電子錢包Mist 是Ethereum的Dapp瀏覽器 也能作為官方的Wallet Ethereum Wallet 同樣是官方Wallet 但就僅是Wallet (Dapp) MEW (MyEtherWallet) 網頁版 https://www.myetherwallet.com/ MetaMask 除了是一個簡單的錢包外，它可以使得Chrome瀏覽器變身成以太坊瀏覽器，讓使用者通過瀏覽器和智慧合約互動情境是:你有一個Dapp網頁供用戶登入錢包 該Dapp無法成為節點操作區塊鏈 所以有兩種方式幫助它 網頁後端有動態伺服器(託管密鑰)像是Truffle(node.js) 對映出api即可 透過MetaMask(託管密鑰)外掛在Chrome上進行登入 網頁js只需應對MetaMask給出的api ParityEthereum (以太坊)(念itSeeRin)用Docker搭建Ethereum網路 一個建立智能合約的平台 同時也是以太幣ETH對應的Project (想像Ethereum是一家公司 以太幣是他發行的股票)智能合約能幫助web或app加入區塊鏈應用 達到Dapp 做出類似區塊鏈的投票機 智能合約 取名有點混淆視聽 其實就是一段程式碼 部署到區塊鏈上 在peer產生實體物件 以該物件作為合約(例如金融帳戶) 可進行合約提供的method(例如轉帳)通常由第三方提供區塊鏈平台(例如Ethereum) 並提供上傳智能合約的機制 便於客製化合約的應用每個peer都能驗證其他peer產生的資料是否依照合約進行執行合約是需要付費給peer的一般合約程式碼需要公開 使參與者知道公平性與共識用Solidity編寫 (類似js)智能合約也視同為一筆Transaction 智能合約開發語言Solidity (類JavaScript)Serpent (類Python)Mutan (類Go)LLL (類Lisp) Account分兩類 Externally Owned Accounts(EOA) : 即人類交易帳號 (Ethereum Account) 主要紀錄的就是balance(餘額)Contract Account : 部署一個合約如同產生一個帳號 該帳號除了balance外 依合約還有了自定義的狀態 由於Account是Hash出來的 重複機率微乎其微 只要有公私鑰就如同有帳戶地址 故能跨不同ethereum網絡使用 但Contract Account不行(why?) EVM (Ethereum虛擬機) 在node上運行 用以執行智能合約的bytecode Transaction (Tx)(交易) 交易一詞由來於設計時以金融交易做為假想 用以表示執行的動作猶如交易機制交易一詞也表示金融交易時需要做同步鎖的機制 與區塊鏈多數認證結果 與失敗的回滾區塊鏈中所有會導致寫入區塊鏈的動作 都稱為交易交易通常帶有一個value值 表示要轉出的金額 Gas 汽油 是一個單位 指node上執行Transaction或智能合約所需的成本gasPrice則是每單位成本 wei/gas願付出多少gas執行可由用戶決定 但可能有out of gas的狀況 (狀態會被回滾) Gas Limit 限制執行合約交易消耗的gas 若達限制交易將失敗用於客戶端節點 : 表示願意付出的gas上限(預扣) 太低會導致沒有節點願意幫忙執行用於執行端節點 : 節點自己控制自己能夠處理事務 避免接到耗時操作用於fallback函數 : 固定有2300gas限制 避免難以結束交易區塊也有一個經由節點共識產生的gas limit用來限制區塊中交易的數量 (即何時開始打包區塊) DApp（decentralized applications） 去中心化應用泛指區塊鏈應用的app 如透過Ethereum平台建立智能合約應用在自己的app上 架構 底層的geth、用solidity寫智能合約、合約在線瀏覽器browser-solidity(remix)、合約錢包Mist/wallet、以太坊的前端開發框架TruffleRPC 遠程呼叫 基於socket 與node連接通常是透過rpc 所以都要有ip:port Geth (節點核心)(念Gets)Geth 由Go語言開發的CLI 用以安裝客戶端RPC API (客戶端應該就是指節點)需要node.js可安裝於多種OS上 Go-Ethereum Geth的project name簡稱Geth因為Geth最核心 事實上還包含其他工具 執行節點(Geth)提供的函數 透過Geth console (本地端適用 不能coding) 透過web3.js (均適用) (走WebSocket) (port:8545) 透過jsonrpc (遠端 無法執行web3.js時) (走TCP基於http?) (port:8545) 透過WebService-RPC (文件規範比較複雜) (port:8546) Truffle（松露） 是以太坊（Ethereum）最受歡迎的一個開發框架一個npm上的cli程式 用來開發自己的錢包(Dapp)包含web3與solc客戶端(web browser)預設有一個react-box的樣板客戶端沒有登入認證系統 需藉由MetaMask Web3.js 以太坊提供的js api, 執行於node.js上js =&gt; Geth RPC (本地端為一個節點 用RPC連本地端節點) Ganache (念甘納許) 前身叫TestRPC用於模擬區塊鏈 生成假的node 有UI畫面預設的port:8545 (示例多用7545)有助記符號(Mnemonic)輔助 (12個單字)(又叫seed phrase) 能替代private key與address remix 官方提供的IDE remix便於編寫智能和約 與呼叫合約方法 abi(Application Binary Interface) 一個.json文件 做為smart contract的介面描述 (裡面有個欄位紀錄bytecode)編譯.sol檔後產生 (npm install solc) Ether 乙太幣有幣值單位 類似K/M/G/T 但以類似人名來表示單位 節點運作概述 每個比特幣錢包都是一個節點,除此之外還有一些是全節點(full node). 全節點負責交易紀錄與驗證及擴散資料. 交易發生時,節點會將交易擴散到節點網路中進行紀錄,待區塊滿載(或??)則開始挖礦產生新區塊. 通常還是要有一些永久性的節點(seed node list) 尤其是初期 待複製出更多節點後 才慢慢式微 節點通常包含四大部分: Network : 找到其他節點 與傳輸接收 Blockchain : 即帳本 Mining : 產生新區塊 Wallet : 保管key與address(帳號) 分兩類 一類必須有完整帳本(full node) 在交易時能確認比對 另一類沒有稱為 SPV nodes 需依靠附近node提供資訊 用戶(Wallet)也是一個node 疑慮節點 一般超過兩個區塊 則成為主鏈 節點上原本就記錄有 持續長大的帳本參考 PSV node : 一個非全節點建立一個乙太幣主鏈(MainChain)的全節點 下載與驗證可能要超過半天 為什麼10分鐘才能產生一個區塊 區塊若同時產生 就會產生另一個分支的鏈 分支中僅有一個能成為最後的主鏈 也就是被刪去的分支上的區塊都是做白工為避免太輕易發生這樣的問題 所以規劃10分鐘產生一個新區塊節點網路需要時間來擴散資料進行比對10分鐘是基於一個數學運算的難度 例如算出前N位為0的hash值 平均算出時間約10分鐘 區塊的產生 規定每10分鐘僅能產生一個區塊規定每個區塊約1MBbitcoin每筆交易約300byte 每秒平均能交易7筆 (tps/transaction per second) 區塊確認 即資料確認寫入半數節點網絡 需要時間確認交易已寫入主鏈 通常以6個區塊做為界定 分支超過6個區塊的機率微乎其微通常提幣系統都會要求6個區塊做保護 也就是60分鐘以Bito來說每筆交易會有一個狀態區分(有入帳但未打勾) 自創貨幣中誰來挖礦? 透過ethereum的主網付Ether幣 或其測試網路真實環境裡自己透過geth 總要有一台伺服器傳達工作給礦工吧? 欲執行任何動作都需要加入節點網路中成為一個節點執行geth即可成為節點產生rpc介面 工作就可以從這裡散播 鏈跟鏈不會衝突嗎? 會 node間分辨彼此所處的鏈(網絡)是依照network id和genesis_hash 誰都可以建只要這兩個一模一樣即表示節點處於同一個鏈 而區塊鏈短的會被更新掉那如果做一個比Ether更長的鏈 放到公眾網路上是否就能覆蓋其他節點的區塊鏈??? 其他p2p的UDP打洞 AB兩節點若在NAT下沒有export對外的port號 則無法互相連接 AB先都連上S 連接的過程NAT會分配port讓AB對外做請求 此時AB都有特定的port了 但對象都是S S得知雙方ip:port 由S仿冒A:port向B:port騙過NAT 之後A就能連B了 FileCoin 一家公司 以區塊鏈技術為基礎儲存檔案(切割小份) IPFS : 欲取代http中對於檔案通訊協定 歷代p2p NodeServer : 所有節點必須透過NodeServer登記與取得其他節點位置 單點故障就斷鏈 Boradcast : 造成廣播風暴 DHT : 分散式HashTable 去中心化 NodeID裡包含路由訊息 歷代區塊鏈 比特幣 乙特幣 超級帳本 Fabric 冷錢包 即硬體錢包 將私鑰匯出到硬體(usb)裝置上 完全移除網路上的私鑰 BitoEx 幣託-比特幣錢包BitoEx 台灣廠商 用email申請一個帳號 透過web/phone介面查詢台灣可透過FamiPort繳費&gt;虛擬帳號&gt;廠商代號&gt;輸入手機號碼&gt;買多少台幣的BTC 現金結帳取得收據與手機簡訊 回BitoEx介面&gt;超商兌換可綁定信用卡/銀行帳號(可出帳)等於私鑰託管給BitoEx https://www.bitoex.com/ MaiCoinMaiCoin 同BitoEx 台灣廠商 Coinbase 同BitoEx 但更大更全球化可綁定信用卡/銀行帳號/paypal 或用wire transfer 圖靈完備 圖靈機(Turing machine)是早期的一種紀錄資料的機器 可以無限紀錄與擦除在程式語言上通常指擁有if/for/recursive功能 能達成任何演算法 公私鑰 RSA 公鑰加密私鑰(收) 或 私鑰加密公鑰(送)被公鑰加密的東西 通常是給自己看的 只有自己能用私鑰解被私鑰加密的東西 通常是用來給別人驗證自己身份的 任何人拿我公鑰解出特定的內容 表示內容肯定是我的 數字簽名 Docker AWS | Amazon Elastic Container Service]]></content>
  </entry>
  <entry>
    <title><![CDATA[電子支付]]></title>
    <url>%2Fhome%2F%2FFinTech%2F%E9%9B%BB%E5%AD%90%E6%94%AF%E4%BB%98.html</url>
    <content type="text"><![CDATA[FinTeck支付行為詳解 EMVco 國際晶片卡組織 初期由EuroPay + MasterCard + Visa共組發佈信用卡代碼化(Tokenization)標準 也是HCE的核心架構 發卡組織(International Association) 由銀行共同成立 如VISA/MasterCard/JCB/中國銀聯本身不發行信用卡 算是提供支付網路/收單/清算 由其會員銀行(發卡機構或發卡銀行)發卡賺取跨國交易手續費 發卡機構(發卡銀行)(Issuer) 指實際發行信用卡的單位 通常是銀行手續費約佔75% 特約商店 即加入諸如VISA/MasterCard支付網路的商家通常需支付2~3%的手續費給收單機構再分配給整個供應鏈 清算中心(跨行) Interbank Card Center(BKM) 負責在收單機構與發卡銀行(跨行)間整合、交換交易紀錄的組織如VISA/MasterCard/台灣的NCCC都能擔任此角色手續費約佔2.5% NCCC(National Credit Card Center of R.O.C.) 聯合信用卡處理中心是中華民國一家處理信用卡交易的非營利組織收單/清算 負責信用卡交易請款扣帳訊息的交換與傳送 收單機構(Acquirer) 刷卡機的提供者 通常是發卡銀行第三方支付通常要尋求收單機構配合 (第三方支付的角色在此)手續費約佔22% 聯名卡(co-branded credit card) 即信用卡 僅因與特定商家合作 刷卡能取得些許回饋 行動支付 線上 網路購物(線上) 行動支付 近端支付 超商NFC(線下) / 商店BarCode(線上) NFC（Near Field Communication） 近場傳輸 感應式讀卡機 (NFC Payment) Visa Wave 與 Master PayPass刷卡上限約超過3000需簽名 刷卡流程 消費者(Cardholder)欲付1,000 商家(Merchant)進行交易 傳給收單機構(Acquirer)並被抽25元 若跨行需再透過清算機構(BKM) 並支付25的2% 若跨國再透過國際發卡組織(VISA/MasterCard...) 並支付? 最後支付25的75%給發卡銀行(Issuer) 支付模式TSM(Trusted Service Manager) 信託服務管理平台 須向電信公司申請將SIM卡換成USIM卡 再向銀行臨櫃申請綁定信用卡 優點:無需網路 USIM如同信用卡 硬體晶片加密(Secure Element) 難以普及 淘汰 HCE(Host-based Card Emulation) 主機卡模擬 Apple/Sumsung/Google/t wallet+ 需預先取得真實卡號對應的token來進行交易 與POS機之間通常以NFC交互token 基本上由app主導支付機制 安全性由app控制(解鎖/密碼/指紋等) 可短暫離線 但通常有安全機制 例如1小時內有效 BarCode Line/街口/支付寶AliPay/歐付寶AllPay改O’Pay(台灣) 不需NFC 可離線支付 但通常有安全機制 例如10分鐘內有效 HCE流程 以Tokenization技術認證持卡人 而不用將真實卡號透露給商家或其他組織發卡銀行必須付手續費給Apple或Google 因其替代了信用卡進而促成交易 取得Token流程 (Visa Token) 安裝app 輸入信用卡號 送向Token Requestor(即Apple或Google等app提供者) 再轉向TokenServiceProvider(發卡組織 如MasterCard或Visa)產生Token 最後將卡號與Token送到發卡銀行 發卡銀行主動傳送Token給app, app必須解出該token已達到認證 並將之前輸入的卡號刪除 支付流程 傳送Token給商家 通常經由NFC/Bluetooth/BarCode/MST(磁條) 商家將Token傳給收單機構再傳給清算機構 清算機構將Token傳給TokenServiceProvider做真實卡號的解碼 再回傳Acquirer收單機構(發卡銀行)與NCCC(聯合信用卡處理中心/清算機構) 第三方支付 與行動支付的差別在於 第三方支付類似代理收單平台提供一手交錢一手交貨的保障 向會員或購物平台收取手續費通常需綁定信用卡 或儲值(或匯款) 建立一個money buffer 即電子錢包相對於Tokenization技術 信用卡的安全是比較有疑慮的 故在台灣發展受限 微信 付款情境1 : 在路邊購物 商家提供QRCode做為收費帳號的連結 買家掃描該QRCode進入付費頁面 決定付費金額 付費 (金額自己決定) 付款情境2 : 在便利商店 買家主動提供自己帳號的QRCode/BarCode做為付費帳號的連結 商家用掃條碼及完成付費 (金額商家POS機決定) 電子票證 儲值支付 雖同為第三方支付 但以電子票證發行管理條例來規範悠遊卡(EasyCard)一卡通(iPass)iCash(統一集團)happycash(遠東集團) ???掃碼式接觸式手機信用卡SIM卡需改為USIM卡 經由官方]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FAndroid%2FLocation.html</url>
    <content type="text"><![CDATA[經緯度 Google地圖v2 Google Maps API 申請 畫路徑圖xml格式json格式 權限&lt;uses-permission android:name="android.permission.INTERNET" /&gt;//以GPS定位 GPS_PROVIDER&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;//以網路定位 NETWORK_PROVIDER&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; 座標 SDK Manager必須安裝Google Play Services implementation 'com.google.android.gms:play-services-maps:15.0.0'//for LocationServicesimplementation 'com.google.android.gms:play-services-location:15.0.0' mGoogleApiClient = new GoogleApiClient.Builder(this) .addConnectionCallbacks(this) .addOnConnectionFailedListener(this) .addApi(LocationServices.API) .build();//onResume 與 onStop間重新建立mGoogleApiClient.isConnected()mGoogleApiClient.connect();mGoogleApiClient.disconnect();//after connected 單次取得Location loc = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);//after connected 多次取得locationRequest = new LocationRequest(); locationRequest.setInterval(1000); locationRequest.setFastestInterval(1000); locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);LocationServices.FusedLocationApi.requestLocationUpdates( googleApiClient, locationRequest, this);@Overridepublic void onLocationChanged(Location location) &#123;&#125; 地圖map = ((SupportMapFragment) getSupportFragmentManager(). findFragmentById(R.id.map)).getMap(); latLng = new LatLng(loc.getLatitude(), loc.getLongitude());//建立標記map.addMarker(new MarkerOptions().position(latLng));marker.setPosition(latLng); Geocoder 地名轉location設定標記BitmapDescriptor icon = BitmapDescriptorFactory.fromResource(R.drawable.ic_launcher); MarkerOptions markerOptions = new MarkerOptions() .position(place) .title(title) .snippet(snippet) .icon(icon);map.addMarker(markerOptions);map.clear(); animateCamera畫圖導航]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FAndroid%2FBlueTooth.html</url>
    <content type="text"><![CDATA[BlueTooth啟動藍牙&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt; adapter = BluetoothAdapter.getDefaultAdapter();if (adapter != null)&#123; if (!adapter.isEnabled())&#123; Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, REQUEST_ENABLE_BT); &#125; Set&lt;BluetoothDevice&gt; devs = adapter.getBondedDevices();&#125;//adapter.disable(); 啟動藍牙可見性&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt; intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); //300秒startActivity(intent); 掃描周圍藍牙設備設備//adapter如同本地的bluetooth裝置adapter = BluetoothAdapter.getDefaultAdapter();//以intent要求掃描adapter.startDiscovery(); //must check permission adapter.cancelDiscovery();//以broadcast receiver進行設備的接收intent_filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);intent_filter = new IntentFilter(BluetoothDevice.ACTION_STATE_CHANGED);receiver = new CustomReceiver();registerReceiver(receiver, intent_filter);class CustomReceiver extends BroadcastReveiver&#123; public void onReceive(Context context, Intent intent)&#123; if (intent.getAction().equals(ACTION_STATE_CHANGED))&#123; state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, ERROR); //OFF //TURNING_OFF //STATE_ON //TURNING_ON &#125; if (intent.getAction().equals(ACTION_SCAN_MODE_CHANGED))&#123; mode = intent.getIntExtra(EXTRA_SCAN_MODE, ERROR); //CONNECTABLE_DISCONVERABLE //CONNECTABLE //NONE //CONNECTING //CONNECTED &#125; &#125;&#125;//藍芽需要的危險權限void checkPermissions()&#123;//ACCESS_FINE_LOCATION : GPS定位//ACCESS_COARSE_LOCATION : 粗估位置 if (Build.VERSION.SKD_INT &gt; Nuild.VERSION_CODES.LOLLIPOP)&#123; int check = this.checkSelfPermission("Manifest.permission.ACCESS_FINE_LOCATION"); check += this.checkSelfPermission("Manifest.permission.ACCESS_COARSE_LOCATION"); if (check != 0)&#123; requestPermissions(new String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION&#125;) &#125; &#125;&#125; 配對 Pair可取得對方的藍芽的name/class/address配對後的裝置(paired)之後就會記錄在系統不用再配對 if (intent.getAction().equals(ACTION_BOND_STATE_CHANGED))&#123; device = intent.getParicelableExtra(BluetoothDevice.EXTRA_DEVICE); state = device.getBondState(); //BONED //BONDING //NONE&#125;if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN_MR2)device.createBond();adapter.getBondedDevices()//用address即可取得特定的deviceadapter.getRemoteDevice(address) 資料交互ref透過類似socket的作法 主動建立連線 (client side)似乎會自動進行bond配對 socket = device.createRfcommSocketToServiceRecord( UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));socket.connect(); //阻塞 等待server回應 被動等待連線連入 (service side)serverSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord( Bluetoothprotocol.PROTOCOL_SCHEME_RFCOMM, UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));socket = mserverSocket.accept(); //阻塞 等待client連接 讀寫socket.getOutputStream(); //寫資料socket.getInputStream(); //讀資料socket.close(); //切斷連線 多樣性資料續用一個socket傳遞ref 自定義格式 (hearder+size+checksum+payload)用DataOutputStream(OutputStream os)以便處理 Beacon 類似一個廣播器 低功耗藍牙技術 多台beacon可作精準的室內定位一個類似RFID的應用 利用bluetooth連接 例如商店內置放一台beacon 用戶手機有安裝對應app 當用戶接近beacon就得以連線 app就會連接雲端 做GCM/FCM推播內容給app Bluetooth4.0 BLE技術 (Bluetooth Low Energy) BLE設備大致分為中心(Central)和週邊(Peripheral) 周邊設備不斷地發出廣播封包告知存在 中心設備則掃描接收廣播 NFC（Near Field Communication）ref 基於RFID而發展 高頻距離短(也就更安全)建立P2P通訊 也能與藍芽建立P2P能用於交互(門禁、公車、手機支付)NFC強調的是P2P間信息的交互 而RFID僅是主從間狀態的讀取 RFID與NFC之間的區別悠遊卡與RFID 高頻 : 電磁感應 距離短 數10公分 RFID（Radio Frequency Identification）videoref 主要用於訊息的讀取與判定IC卡運作的電流經由環境(讀卡機)提供其應用在於ID二字(悠遊卡/ETC(超高頻)/eTag/寵物晶片/防盜標籤/VISA WAVE) 可近可遠 低頻/高頻/超高頻(微波 距離長 十數公尺)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FAngular.html</url>
    <content type="text"><![CDATA[interface NgModule &#123; providers : Provider[] declarations : Array&lt;Type&lt;any&gt;|any[]&gt; imports : Array&lt;Type&lt;any&gt;|ModuleWithProviders|any[]&gt; exports : Array&lt;Type&lt;any&gt;|any[]&gt; entryComponents : Array&lt;Type&lt;any&gt;|any[]&gt; bootstrap : Array&lt;Type&lt;any&gt;|any[]&gt; schemas : Array&lt;SchemaMetadata|any[]&gt; id : string &#125; providers : 服務類型 其類型會被建立成一個singlton供各元件進行注入 entryComponents : 與route有關 也與編譯有關 當一元件做為入口元件但沒加到route中時就要在這裡宣告 編譯器才會編入 否則可能tree shake時就被移掉了 declarations : 主要用來宣告會用到的Component 以及連帶用到的Pipe與Directives imports : 元件或服務或其他用於該NgModule中的類型 所需要用到額外的類型或Module (ngmodule屬於angular的應用層面 其import是為了編譯出完整的app 而ts的import是屬程式語言的層面 兩個編譯屬不同層次) bootstrap : 首先被啟動的Component]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2F%E6%97%A5%E8%AA%8C.html</url>
    <content type="text"><![CDATA[180412好用畫圖工具 FireAlpaca]]></content>
  </entry>
  <entry>
    <title><![CDATA[作品]]></title>
    <url>%2Fhome%2F%2FSingle%2FArts.html</url>
    <content type="text"><![CDATA[區塊鏈電子錢包原始碼 私鏈(PoA)Docker / 用戶服務器 / Android用戶端 / iPhone用戶端 以乙太坊智能合約搭建電子錢包 MapRunnerGitHub 以兩隻手機模擬 跑步機與行動裝置 間的互動情境 模擬跑步機 等待藍芽裝置連入 連入後 開始定位 並透過google api下載行進路線 (終點預設為’台中火車站’) 開始位置移動的模擬 並傳送給手持裝置 模擬手持裝置 搜尋與連接藍芽裝置 連接後 開始接收移動位置 顯示於地圖 並寫入資料庫 Kotlin / Room / Retrofit 畫面翻轉狀態保留 以Sketch繪製與切版 自定義View(儀表板) 加減速指針動畫 TSNoteGitHub / Google Play 多國語言 有聲 翻譯 筆記 Kotlin / Dagger LangStarGitHub / Google Play / 線上web版本 語言單字學習 類似單字卡的分享平台 以Ionic開發的Hybrid App 後台用Firebase 包含social login 以標籤機制區分各國語言與內容 過往操作可離線使用 WOVOGitHub / Marketplace 一個VSCode的Extension 股票程式化分析軟體 接收DDE或券商提供之API做即時報價與委託交易能夠動態編譯腳本程式 用以繪圖或分析選股或執行程式交易 Java 僅能於window平台執行 免安裝下載 官網連結]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hybrid App Architecture]]></title>
    <url>%2Fhome%2F%2FSingle%2FHybridAppArchitecture.html</url>
    <content type="text"><![CDATA[Cordova其前身稱為PhoneGap 做為JavaScript Bridge 實現JS介接Native Libraryref WebView 使用WebView意味著看到的ui元件不是native元件構建而成 而是透過webview畫出 (應該也沒有寫NativeView的必要了) WebView有分原生的或Cordova的跨平台WebView Plugin大致寫法類似用xml(metadata)分別設定android與ios 並分別實作api對應的native程式(繼承CordovaPlugin) 最後實作一個js object對應該api 透過WebView叫用api (之後再自行封裝成類別形式)cordova.exec(success_callback, error_callback, feature_classname, action_str, args); React NativeReact Native 航向真全端，建構雙平台 App /Native UI Components / 菜鳥窩React Native 從零到高級 只有JS Engine 沒有WebView 意味著web的ui元件實現須對應到native的ui元件上 實作比較辛苦 但執行比較快]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2FSort.html</url>
    <content type="text"><![CDATA[ref 泡沫排序 倆倆比較 將大的往後推(交換) 每一輪結束最大的一定推到最後一個(排好一個) 所以下一輪就少推一個 優化: 若其中一輪完全沒有交換 表示已經完成排序 public static void bubbleSort(final int[] nums) &#123; for (int i = nums.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; final int next = j + 1; if (nums[j] &gt; nums[next]) &#123; final int buffer = nums[j]; nums[j] = nums[next]; nums[next] = buffer; &#125; &#125; &#125;&#125;static void test1() &#123; int[] arr = new int[]&#123;3, 17, 63, 27, 9, 15, 2, 6&#125;; System.out.println(Arrays.toString(arr)); bubbleSort(arr); System.out.println(Arrays.toString(arr));&#125; 交換排序 從第一個位置開始 與之後的每個位置比較 交換出最小的 一輪比完再進行下個位置 public static void exchangeSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; final int buffer = nums[j]; nums[j] = nums[i]; nums[i] = buffer; &#125; &#125; &#125;&#125; 選擇排序 (交換排序法的優化) 如同交換排序 只是記住最小值的索引位置 於當輪結束時交換 public static void selectionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; int k = i; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[k] &gt; nums[j]) &#123; k = j; &#125; &#125; if (k != i) &#123; final int buffer = nums[k]; nums[k] = nums[i]; nums[i] = buffer; &#125; &#125;&#125; 插入排序 記住第i個位置的值(tmp) (準備把tmp往左插入到正確位置)開始往左比 一路把大於tmp的值往右推 直到找小於tmp的位置 再執行下個循環 public static void insertionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length; ++i) &#123; final int tmp = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; tmp) &#123; nums[j + 1] = nums[j--]; &#125; nums[j + 1] = tmp; &#125;&#125; 快速排序 採分治法(Divide and Conquer) 找一個中間數(pivot)將 並使其歸於正確位置(左小又大) 左右邊再各自做一次同樣的循環 public static void quickSortRecursive(final int[] nums, final int start, final int end) &#123; final int x = nums[start]; // 將start位置的值設為pivot int l = start + 1; //所以start+1是最左的元素 int r = end - 1; //end因為是length 所以要減1 while (true) &#123; //從右邊往左 找到小於pivot的位置 while (r &gt; start &amp;&amp; nums[r] &gt;= x) &#123; --r; &#125; //從左邊往右 找到大於pivot的位置 while (l &lt;= r &amp;&amp; nums[l] &lt;= x) &#123; ++l; &#125; //若l&lt;r表示尚未巡完整個array 就已需要交換 if (l &lt; r) &#123; final int buffer = nums[l]; nums[l] = nums[r]; nums[r] = buffer; &#125; else &#123; //lr巡完表示pivot的位置就在其交會點 if (r &gt; start) &#123; final int buffer = nums[r]; nums[r] = nums[start]; nums[start] = buffer; &#125; break; &#125; &#125; final int ls = start, le = r; final int rs = r + 1, re = end; final int ll = le - ls, rl = re - rs; if (ll &gt; 1) &#123; quickSortRecursive(nums, ls, le); &#125; if (rl &gt; 1) &#123; quickSortRecursive(nums, rs, re); &#125;&#125;quickSortRecursive(array, 0, array.length); 合併排序```排序======```java 排序```排序======```java 排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2Fhome%2F%2FJava%2FLock.html</url>
    <content type="text"><![CDATA[ref 同步與異步同步二字在生活上通常都解釋成同時進行/亦步亦趨 但程式上不是這樣觀念 異步 : 各自行動 互不等待 (記住異步的定義) 同步 : 行動須受牽制 等待 使一致 比喻 異步 : 像是短跑比賽 參賽者各跑各的 同步 : 像是跑接力賽 沒拿到接力棒就只能等待 (執行上依賴共享的資源) 用途 異步 : 增進執行效率 多執行緒 : 使用共享資源時還是要進入同步 單執行緒 : 任務寫在Event Callback/Hook 由Event Loop驅動 仿效異步 (如JavaScript) 同步 : 保護共享資源的必要手段 異步執行 指耗時任務交付後就可以先去做別的事情 等任務執行完再通知此任務稱為異步任務 不會馬上被執行架構為事件處理型(onEvent)的設計異步任務(Runnable)可以用thread或handler達成 同步執行 指事情必須依序處理 未完成前不能離開例如從網路取得一張圖片 顯示在螢幕上 若下載圖片要10秒鐘 程式就必須等待完成後才能繼續執行程式的基礎都是建立在同步執行上的 而多執行緒中的同步更強調的是只有一個執行緒在執行該段程式執行緒競爭要達到同步的代價就是等 等的實踐就是鎖 鎖的用途就是保護 對於鎖或與執行緒同步相關的實踐: synchronized lock blocking queue semaphore 需要等待的情境 等待共享資源 (用同步鎖解決) 等待異步任務(一個或多個)結果 (Thread.join或更高階的手段) 鎖 臨界區(critical section) : 即被鎖住的區塊 可重入性(reentrant) : 指thread可以重入相同的鎖中 即在funcA中又進入funcB 線程飢餓與公平(Starvation and Fairness) : 指線程搶不到開鎖機會的狀況 Busy Wait : 指while loop的等待方式 造成cpu持續忙碌而無法有效利用 synchronized 以某個物件(實例或類)做為鎖 多個thread中僅能一個thread取得鎖 也就是執行權 確保僅有一個thread進入critical section 確保從main memory讀入 離開時寫回 thread間取得鎖的結果是不公平的 有優先權的 而不是先到先贏 class Test&#123; //實例鎖 public synchronized void funcA()&#123; &#125; public synchronized void funcB()&#123; &#125; //類鎖 public static synchronized void func()&#123; &#125; static obj... public void func()&#123; //實例鎖 synchronized(this)&#123; &#125; //類鎖 synchronized(obj)&#123; &#125; &#125;&#125; 線程間能被安全共用的實例public class MyData&#123; protected Object data = false; public synchronized Object get()&#123; return data; &#125; public synchronized void set(Object data)&#123; this.data = data; &#125;&#125; 信號機制 每個Object都能做為MonitorObject wait : 使當下thread進入等待 並監視MonitorObject的信號 notify : 喚醒監視MonitorObject的thread (由系統決定喚起的thread) notifyAll : 喚醒全部監視的thread 重新競爭鎖 Missed Signals : 指notify前沒有相應的wait先被執行 而可能造成之後的wait無人喚醒 算是設計錯誤 以信號機制實現鎖public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; //isLocked為false時 進入wait循環 thread被鎖住 等待另一個thread開鎖 //若同一個thread未unlock又來lock第二次 同樣會被鎖死 造成沒有thread能解鎖 while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false; notify(); //相當於觸發信號 &#125;&#125;public class Counter&#123; private Lock lock = new Lock(); private int count = 0; public int inc()&#123; lock.lock(); int newCount = ++count; lock.unlock(); //若臨界區會拋出異常 需使用catch finally return newCount; &#125;&#125; wait如同sleep 但從wait中醒來並不是一定要有notify 它僅是告知已經可以從wait中喚醒 這種不是經由notify喚醒的情形稱作虛假喚醒(spurious wakeup) 故wait與notify之外仍需要isLocked做為是否unlock的判斷 這種while建構的鎖稱為自旋鎖 實現可重入性要考慮: 記住是由哪個thread上鎖 且上鎖幾次 解鎖必須counter歸零 Slipped Conditions 即指while(isLocked)與isLocked=true非一氣呵成(原子操作) 執行的間隙造成鎖的狀態改變 FairLock 透過List將記住請求鎖的順序 Semaphore 計數信號 實作上首先要確保操作的原子性當資源量為1時 可當鎖用 SEM_VALUE_MAX 資源量 P take/wait 減1操作 取得資源 V release/signal 加1操作 歸還資源 BlockingQueue 阻塞隊列 當take時沒有元素 或put時沒有空間時阻塞線程]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 增訂]]></title>
    <url>%2Fhome%2F%2FJava%2FJava8Explained.html</url>
    <content type="text"><![CDATA[Lambda 箭頭函數lambda是一個java8開始的新語法 類似於javascript的箭頭函數 因應functional programming而生 可以將箭頭函數想像成一個”只有一個method的object” 就會比較容易理解 看/用起來像function但其實是一個object 因為只有一個method所以method的name就不重要了 object即等同method 為什麼要這樣?因為java的method不能像變數一樣當作參數 要傳函數勢必只能整個object傳入 而箭頭函數就是為了解決這樣的困擾 Runnable runnbale = new Runnable() &#123; public void run() &#123; System.out.println("run me!"); &#125; public Runnable get()&#123; //將現有的method當作箭頭函數般回傳 return this::run; &#125;&#125;;//箭頭函數的形式Runnable runnbale = () -&gt; System.out.println("run me!"); Collection走訪functional programming的另一個重點就是function chain與Collection(list/map/array)的走訪. 搭配Collection的stream() //透過stream()衍生function chainlist.stream().filter(s -&gt; Integer.valueOf(s) &lt; 3).forEach(s -&gt; System.out.print(s));//parallelStream() : 平行處理的stream Lambda 以函數為參數//格式Function&lt;input, output&gt;Consumer&lt;input, void&gt;Predication&lt;input, boolean&gt;Supplier&lt;output&gt; static test(int x, Function&lt;int, string&gt; fun)&#123; f.apply(x);&#125;test(99, (int x) -&gt; &#123;return "99"&#125;); Interface擴展interface的method可前綴default與static的關鍵字 用以擴展interface的method Optionallink Optional是一個新的類別 用於封裝一個傳入或回傳值 並提供一些良好的方法 讓programer養成良好的習慣 Data/Time方面的新類別]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection]]></title>
    <url>%2Fhome%2F%2FJava%2FCollection.html</url>
    <content type="text"><![CDATA[ref ref 類型 Collection 一無序物件群體的介面 Set 一無序物件群體 元素無法重複(會覆蓋) 沒有索引沒有get方法 因爲沒有key的概念 僅存放value(或稱element) 用iterator遍歷HashSet為常用的實現 或可排序的TreeSet List 一有序物件群體 元素可重複 有數字索引 能get(idx) Map 鍵值對 (Key-Value pair) (entrySet) 結論 要數字索引 : List (ArrayList) (CopyOnWriteArrayList) 有Key-Value關聯 : Map (HashMap/LinkedHashMap) (ConcurrentHashMap) 單存放置一群物件 : Set (HashSet) 要隨時排序 : TreeMap 基本上如此 但技術演變很快 類別也會出現變形 concurrent(指多thread能夠同時存取) 意味 thread-safe 遍歷HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();//keysetfor (Object k : map.keySet())&#123; System.out.print(k + " ");&#125;//entrysetfor (Map.Entry entry : map.entrySet()) &#123; System.out.print(entry.getKey() + " ");&#125;//iteratorIterator entries = map.entrySet().iterator();while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry)entries.next(); System.out.print(entry.getKey() + " ");&#125; 測試發現 : HashMap與Hashtable 遍歷時都是沒有規律的 實現類實現解說 HashMap (ConcurrentHashMap) 以hashcode為key (null也有其hashcode)速度快,遍歷時無序的(非照put時機或key值排列)非thread-safe, multi-thread資料可能異常,但有ConcurrentHashMap可以替代,或Collections.synchronizeMap(map)使其thread-safe需要預留較大的array空間(對應每個hashCode) 資料量不多時划不來以一個hash值為索引的array其每個元素對應到一個list 當list長度超過8則改為紅黑樹(自平衡二元樹) Hashtable thread-safe, 慢繼承Dictionary較早的技術 建議用HashMap取代 LinkedHashMap (小資料量的通常的選項) 繼承HashMap (應該是以雙向鏈取代固定size的array)遍歷時是依照put順序的較慢 但啟動較省空間 在資料不多時 不見得比較慢 EnumMap 以enum為鍵 意即使用時就已知最大容量 通常會較快 TreeMap 實做SortMap介面遍歷預設依照key值的升序排序 可以自訂Comparator WeakHashMap 弱參考 可做自動回收的快取 HashSet 以HashMap實現即以Object的hashCode為key 本身為值 故同樣的hashCode無法對應兩個值 即不會重複 map.put(key, new WeakReference(value)) Arraysint[] ints = new int[10];Integer[] ints2 = new Integer[10];List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); 固定長度 可放原生類型透過java.util.Arrays工具類延伸操作 ArrayList 元素為連續排列 但能動態調整大小(會預留空間) 從刪除或插入會造成比較大的開銷get/set能透過索引算出 快add/remove需要移動整個右邊元素 慢 LinkedList 以雙向鏈(node)實現Listget/set需透過node遍歷 慢add/remove直接調整左右節點即可 快 (節點不在最前最後時要先遍歷找到節點) Iterator (迭代器)用於遍歷Set與List元素 類似一個for loop (Map的遍歷透過其EntrySet) ListIterator : 可雙向 fail-fast : 操作集合會累加modCount以示集合出現更動 若迭代時出現更動會拋出異常java.util.ConcurrentModificationException 算是一種偵錯機制 fail-safe : 迭代時複製一分參考清單 該清單無人能更動 自然就能確保迭代期間是完整的 但期間若真有異動也無法即時反應 Stream (流)類似以loop方式每次推送一個元素到function中操作 透過各式操作符一層一層完成以往for loop的工作 parallelStream : 以並行(切割任務)方式處理流 同步Map map = Collections.synchronizedMap(new HashMap()); JDK集合實現List//Single-threadedArrayList – 基於數組的泛型LinkedList – 請勿使用Vector – 已棄用//ConcurrentCopyOnWriteArrayList – 極少更新，常用於遍歷 Maps//Single-threadedHashMap – 泛型映射EnumMap – 枚舉鍵Hashtable – 已棄用IdentityHashMap – 用== 對比的鍵LinkedHashMap – 保持插入次序TreeMap – 有序鍵WeakHashMap – 有益於緩存//ConcurrentConcurrentHashMap – 泛型並發映射ConcurrentSkipListMap – 有序並發映射 Sets//Single-threadedHashSet – 泛型集合EnumSet – 枚舉集合BitSet – bits/dense 整型集合LinkedHashSet – 保持插入次序TreeSet – 有序集合//ConcurrentConcurrentSkipListSet – 有序並發集合CopyOnWriteArraySet – 極少更新，常用於遍歷 Queues / deques (隊列/雙隊列)//Single-threadedArrayDeque – 基於數組的泛型Stack – 已棄用PriorityQueue – 有序檢索操作//ConcurrentArrayBlockingQueue – 有界阻塞隊列ConcurrentLinkedDeque / ConcurrentLinkedQueue – 無界鍊式隊列(CAS)DelayQueue – 由延遲元素構成的隊列LinkedBlockingDeque / LinkedBlockingQueue – 可選有界鍊式隊列(locks)LinkedTransferQueue – 可傳輸元素且不進行存儲PriorityBlockingQueue – 並發PriorityQueueSynchronousQueue – Queue 接口的交換器]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMM (Java Memory Model)]]></title>
    <url>%2Fhome%2F%2FJava%2FJMM.html</url>
    <content type="text"><![CDATA[*ref ref ref JMM (Java Memory Model) JVM執行區分 主內存(共享內存) 與 本地內存 Main : 主記憶體 (heap) Local : 各個thread獨立使用 (cache/副本) thread執行時會將需要的內容從main複製到local 之後操作各自的local memory, thread彼此間是無法得知其他thread操作的結果 除非重新同步main的資料 local從main讀寫資料應該是視為synchronized或有cpu確保同步 String str = new String("hello");//str為一參考 會放在stack//new String會放到heap//hello是字面值會放到靜態儲存區(應該也是heap) 可見性(visibility) 指A修改變數x時 確保B能夠隨時得到最新的值 (即cache失效)Java透過volatile將變數宣告為易變的/易揮發的 以提示其需要可見性的維護 (但並沒有原子性保護) x = 0;AB兩thread同時執行+3與+5,預期得到8volatile x = 0;A(x=x+3) : 0+3=3 將3指定給xB(x=x+5) : 0+5=5 此時x變為3,但運算已結束 將5指定給x 最後卻得到5,這是因為x=x+5的動作並不屬於原子操作,x+5與x=?是分別執行的,中間可以穿插,所以volatile不一定能確保變數一定是thread-safe的故volatile一般都用在狀態或旗標變數上 原子操作 (atomic)原子是最小無法分割之物 用來形容操作是不能分割的 以完成i++為例 分別需要取值/運算/賦值 假若期間無法插入任何與i相關的操作 就可以確保i的正確性 範例volatile int x = 0;volatile int y = 0;AtomicInteger a = new AtomicInteger(0);for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; x = x + 1; a.addAndGet(1); synchronized (Thread.class)&#123; y = y + 1; &#125; &#125; System.out.println("ans x : " + x); //405949 &lt;- 錯的 System.out.println("ans y : " + y); //500000 System.out.println("ans a : " + a); //500000 &#125; &#125;).start();&#125; CAS compareAndSet(expected, new) atomic檢查主入內存與expected是否相同,若相同表示可以賦值為new 否則回傳false 猜測應該是用在鎖的應用上 類似CountDownLatch 但不會阻塞 atomicI = new AtomicInteger(0);private void safeCount() &#123; for (;;) &#123; runCount++; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) break; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2F%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[*post 定義//Lev 1class Food&#123;&#125;//Lev 2class Fruit extends Food&#123; int weight;&#125;//Lev 3class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125; T //(或其他字母)T為一泛型可用以表示某一特定類別class List&lt;T&gt;&#123; T e&#125;List類別中有一特定類別為E區間:子類 &lt;- extends T super -&gt; 父類 -&gt; Object 泛型Class設計- T指是某一確切的類別 例如T為Fruit 並且可以多型轉換接受Apple或Banana- List&lt;T&gt;同上 但無法多型轉換 因為List&lt;Fruit&gt;並不能轉為List&lt;Apple&gt;- List&lt;? extends T&gt;是一個不確切的型別 兼容其子類 List&lt;Fruit&gt;與List&lt;Apple&gt;- super與extends雷同 兼容其父類 只是需求比較少見 - 例如要傳入一個比較器 希望設計這個比較器時能被通用 - 會寫成class Comparator&lt;Furit&gt;&#123;&#125;而不是替每種fruit分開寫 - 接收比較器的介面就需讓父類能傳入 如不管T是Fruit或Apple或Banana都能用 class MyList&lt;T&gt;&#123; //在MyList中根本不會知道E將會是什麼 ArrayList&lt;T&gt; list = new ArrayList(); //Fruit的子類都能傳入 void add(E e)&#123; &#125; //只能傳入ArrayList&lt;Fruit&gt; void addFromList1(ArrayList&lt;T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之子類 void addFromList2(ArrayList&lt;? extends T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之父類 void sort(Comparator&lt;? super T&gt; c) &#123; &#125;&#125; E被指定為?的副作用因為編譯時還不知道E是什麼,所以不能確定其子類或父類 Food food = null;Fruit fruit = null;Apple apple = null;Object obj = null; //? extendsArrayList&lt;? extends Fruit&gt; fruitlist_ex = null;fruitlist_ex.add(food); // X : 任何型別都不能傳入fruitlist_ex.add(fruit); // Xfruitlist_ex.add(apple); // X/*原因 :假若fruitlist_ex = new ArrayList&lt;Apple&gt;();此時fruitlist_ex.add(new Banana())若被允許表示T同時代表了具體的Apple(建構時)與Banana(函數呼叫時),這將使後續的操作難以預料故無論輸入什麼類都一律拒絕,以保封裝後的安全*/food = fruitlist_ex.get(0); // 回傳上限型別(Fruit),很合理,後續自己轉成子類 //? superArrayList&lt;? super Fruit&gt; fruitlist_su = null;fruitlist_su.add(fruit); // 可以傳入合理型別fruitlist_su.add(apple);/*原因 : 因為下限就是Fruit,不能fruitlist_su = new ArrayList&lt;Apple&gt;();所以T無論如何至少都是Fruit容器,放fruit/apple/banana都能符合T*/food = fruitlist_su.get(0); // X : 無法傳出合理型別obj = fruitlist_su.get(0); // 只能回傳Object型別/*原因 : 上線型別是Object故唯有傳Object能涵蓋所有可能型別*/ 即使你很確定轉型不會造成操作失敗,但編譯器仍會阻止你,因為至少在編譯器這一關需確保泛型所有可能性的安全,以提供語法上邏輯的正確. 簡記 extends 與其子類 僅能用於 輸出參數 out getter super 與其父類 僅能用於 輸入參數 in setter]]></content>
  </entry>
  <entry>
    <title><![CDATA[Singleton]]></title>
    <url>%2Fhome%2F%2FJava%2FSingleton.html</url>
    <content type="text"><![CDATA[video 建立的兩個需求: thread safe lazy Plainclass MySingale&#123; private MySingale()&#123;&#125; public static MySingale instance = new MySingale();&#125; //kotlinobject MySingale&#123;&#125; Lazy (not thread safe)class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; val instance by lazy(LazyThreadSafetyMode.NONE)&#123; MySingale() &#125; &#125;&#125; Lazy (thread safe)(synchronized) 加synchronized class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static synchronized MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; private var instance: MySingale? = null @Synchronized fun getInstance(): MySingale&#123; if (instance == null) instance = MySingale() return instance &#125; &#125;&#125; Lazy (thread safe) (volatile) 加volatile : 確保不同thread中能立即察覺變數的更動 class MySingale&#123; private MySingale()&#123;&#125; private static volatile MySingale instance; public static MySingale getInstance()&#123; if (instance == null)&#123; //避免持續進入synchronized synchronized (MySingale.class)&#123; if (instance == null)&#123; instance = new MySingale(); &#125; &#125; &#125; return instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; val instance by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; MySingale() &#125; &#125;&#125; 透過Holder (靜態內部類) 透過static Holder達到lazy new操作在java中原本也就是thread safe class MySingale&#123; private MySingale()&#123;&#125; private static class Holder&#123; static MySingale instance = new MySingale(); &#125; public static MySingale getInstance()&#123; return Holder.instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; fun getInstance() = Holder.instance &#125; companion Holder&#123; val instance = MySingale() &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2Fhome%2F%2FJava%2FJava.html</url>
    <content type="text"><![CDATA[面試題 資料型態 short / char : 2byte (unicode) int / float : 4byte long / double : 8byte (64bit) field修飾字 同package 子類 其他package public ✅ ✅ ✅ protected ✅ ✅ × default ✅ × × private × × × 引用 強引用(Strong) 強行使物件無法被回收 軟引用(Soft) 不置於立即回收 做cache時很適合 弱應用(Weak) 同軟引用 但更容易會被回收 虛引用(Phantom) 該回收就回收 可用於檢查物件的回收與否 person = new Person("john", 10);ref = new SoftReference&lt;Person&gt;(person);Person p = ref.get(); String透過純字面建立的string會在靜態緩衝裡建立快取 所以同樣的字串會對應到同樣的位置 但透過new String則一定是一個全新的指向s1 = "123";s2 = "12" + "3";s3 = "12" + new String("3");s4 = new String("123");// 其中只有s1==s2 StringBuffer / StringBuilder StringBuffer : thread-safe 較慢 StringBuilder : not thread-safe 較快 builder類通常宣告於method內做local變數 沒有共用的問題 也就不需要thread-safe interface / abstract interface 一個interface可繼承(extends)另一個interface 一個class可實作(implements)多個interface 可有member field 但強制成為static final method上加註default或static建立具體method (java8開始) abstract 無異於一個具體類(concrete class) 但無法實例化 且有抽象方法 一個class僅能繼承一個abstract class IOC / DI 控制反轉(Inversion of Control) 等同依賴注入(Dependency Injection)即指建立一物件時 其依賴並非由建立者或被建立者來建立提供 而由一專屬框架負責 InputStream / OutputStream 流操作分兩類 byte/character byte : 以InputStream / OutputStream結尾 Input/Output : 讀/寫 Stream : byte stream character : 以Reader / Writter結尾 以InputStreamReader為例 前綴InputStream表示輸入為byte 後綴Reader表示輸出character Proxy 代理 即中間人 透過中間人與物件互動 中間人即可提供一些額外的功能 RealSubject 被代理的物件(委託對象) ProxySubject 代理對象 Subject RealSubject與ProxySubject共同的介面 假設有一個request方法 靜態代理 : 就僅是將RealSubject包到ProxySubject裡new ProxySubject(real); 動態代理 : 透過反射 class ProxyHandler implements InvocationHandler&#123; private Subject subject; public ProxyHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //插入代理的行為 Object result = method.invoke(subject, args); return result; &#125;&#125;//建立一個該subject的handler 處理對應的invokehandler = new ProxyHandler(real);//建立ProxySubject 給予其該有的介面與handler 會動態產生一個classproxy = (Subject)Proxy.newProxyInstance( RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler);proxy.request(); Annotationref類似metadata 提供訊息用以描述內容 例如某個method是override的 用途 編譯檢查 如 @Override,@SuppressWarnings,@Deprecated 執行期間以反射取得某物件的Annotation 以提供相應的處理 編譯時搭配額外編譯工具提供自動產生代碼 如Dagger/JavaDoc @Retention(RetentionPolicy.RUNTIME) //使其能在runtime時保留 供反射使用@Target(METHOD.TYPE) //能被用在method上public @interface MyAnnotation &#123; String value() default "test"; //宣告需要一個字串變數&#125;public class TheClass &#123; @MyAnnotation("unit test") public void doSomething() &#123; &#125;&#125;//透過反射取得其AnnotationMethod method = TheClass.class.getMethod("doSomething"); Annotation[] annotations = method.getDeclaredAnnotations();Annotation annotation = method.getAnnotation(MyAnnotation.class); 捕捉 UncaughtException從Thread捕捉所有未能被try catch中捕捉的意外 替即將掛掉的程式安插一些處理方式 class ExceptionHandler implements Thread.UncaughtExceptionHandler&#123; @Override public void uncaughtException(Thread t, Throwable e) &#123;...&#125;&#125;Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler()); 內部類class AllInnerClass&#123; //內部類 (嵌套類) class InnerClass&#123; &#125; //靜態內部類 static class StaticInnerClass&#123; static Object obj = new Object(); //靜態成員的初始化 1.懶初始化 2.保證thread-safe &#125; public Object getTaske()&#123; //局部類 class LocalClass extends Object&#123; &#125; return new LocalClass(); &#125; //匿名內部類 Runnable anonymousInnerClassObject = new Runnable()&#123; @Override public void run() &#123;&#125; &#125;; //Lambda Runnable runnbale = () -&gt; System.out.println("running~");&#125; HTTPHttpURLConnection 較低階 HttpClient 較高階 以HttpGet或HttpPost做為請求對像 HttpClient client = new DefaultHttpClient(); HttpGet request = new HttpGet("http://tw.yahoo.com"); HttpResponse response = client.execute(request); HttpEntity entity = response.getEntity(); InputStream input = entity.getContent();]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2Fhome%2F%2FSingle%2FKotlin.html</url>
    <content type="text"><![CDATA[官方文件 簡介 介於Java與Scala之間 困擾 因為setter與getter緣故 難以區別’賦值’與’叫用’ 看不出in func的移轉 ()裡是什麼? 前綴是class : 建構成員參數宣告 前綴是fun : 函數參數宣告 {} 裡是什麼? 前綴是class : class宣告 前綴是fun : fun宣告 匿名函數 lambda 描述 不用分號結尾 一個檔案可多個類別 預設類別名稱 FilenameKt 沒有Primitive類型 全是Object (所以Java要存取都須透過getter/setter) 沒有static關鍵字 @JvmStatic @JvmField 方便對映回java對應 關鍵字 internal : 不允許外部訪問 (修飾class對java無效;但修飾fun會造成java無法access) Annotation @JvmOverloads //使fun多載(默認參數) @Synchronized @Volatile @JvmSuppressWildcards 避免Any轉成Java的? package 不宣告即為預設的package 檔案路徑不須對應package import 可以引入function 變數 前面一定要val或var val : 不可變(final) var : 可變 lateinit : 告訴編譯器稍晚會init不要報錯 但若沒有init執行時仍會丟異常 var 變數名稱: 型態 ＝ 初始值var x : Int = 1var x = 1 //自動推定var age_:Int? = nullx as String //轉型 (不需要再傳給變數)x.trim() Int String Unit : 相當於void Any : 類似Object 但不能是null IntArray / intArrayOf(1,2,3) vararg : 相當於Java接收參數String args…, 用*vararg能將其轉回陣列與java互用 Null 變數預設不能為null 型別後加?才能為null 安全調用 obj?.getNum()?:-1 空斷言!! 當null時報出exception (表示上:在變數後加!提示該變數是nullable) var x: Any //允許,但後續仍會被要求initvar x: Any? = nullfun getLength(s:String?):Int = s.length //編譯器不會過fun getLength(s:String?):Int = s?.length?:0fun getLength(s:String?):String = s!! function open : 可複寫 寫在最外層會變成 FilenameKt的靜態method open fun myfunc(x: Int, s: String) : Int&#123;&#125;//單行回傳fun getAge() = age 匿名函數 不允許冠return 最後一行的變數或結果自動當作回傳 fun myfunc(type: Int, func: () -&gt; Int)&#123; println(func())&#125;myfunc(1,&#123;7&#125;) //熟悉的寫法myfunc(1)&#123;8&#125; //較難理解的寫法myfunc(func = &#123;9&#125;, type = 1) //指定參數位置fun myfunc(func: () -&gt; Int)&#123; println(func())&#125;myfunc&#123;10&#125; //很難理解的寫法 SAM conversion//前面沒有fun關鍵字 後面接&#123;&#125;就是傳入匿名參數 懶加載 by lazy被用到時才初始化 val xy:Int by lazy &#123; val x=1 val y=5 x+y //最後一行即為匿名函數的回傳&#125; 具名函數 有回傳須指定型態 且要冠return fun func1():Int &#123;return 1&#125; //指名為func1fun func2() &#123;2&#125; //指名為func2fun func3() = &#123;3&#125; // &#123;3&#125;為匿名函數(lambda) 指定給func3作為回傳fun func5() = 5println("func1 ? " + func1()) //1println("func2 ? " + func2()) //kotlin.Unitprintln("func3 ? " + func3()) //Function0&lt;java.lang.Integer&gt;println("func3' ? " + func3()()) //3println("func4 ? " + &#123;4&#125;()) //4println("func5 ? " + func5) //5 //程式進入點func main(args:Array&lt;String&gt;)&#123;&#125; string templateval x = 1println("x = $x");println("x+1 = $&#123;x+1&#125;"); if-elseval max = if (x &gt; y) x else y when if 也可以回傳值 後面接的是lambda val x = 1var y:Intwhen (x) &#123; 1, 2 -&gt; y = 1 in 20..30 -&gt; y = 1 else -&gt; y = -1&#125;//SmartCast 可回傳var v = when (obj) &#123; is String -&gt; Integer.parseInt(obj) is Number -&gt; obj.toInt() + 5 else -&gt; -1&#125; forfor (i: Int in 1..5 step 2) &#123; print(y)&#125;//135for (i: Int in 5 downTo 1) print(i)//54321 lambda it : 預設第一個引數 val ia: IntArray = intArrayOf(120, 30, 15, 27, 66)ia.filter &#123; it &gt; 50 &#125; // 留下大於50的元素 .sortedBy &#123; it &#125; // 依照大小排序 .map &#123; it / 10 &#125; // 元素值除以10 .forEach &#123; print("$it-") &#125; // 顯示元素值 // 顯示： 6-12- class open : 可被繼承 close : inner : 預設的inner class是static的(與java相反), 要成為member class需加inner open class Person(var name: String) &#123; // 首要建構子的參數列 (有寫就一定要call)//參數列宣告有加var或val才能被外面存取//首要(primary)建構子 (有寫就一定要call) init&#123; &#125;//geter / setter var age:Int get() = age // java用.getAge() kotlin仍用.age set(value) &#123;age=value&#125; //這樣寫會recursive,要用field取代age set(value) &#123;field=value&#125;// 其它建構式，使用this(name)呼叫主要建構式 constructor(name: String, , age: Int) : this(name) &#123; this.age = age &#125; fun sayHi() &#123; println("Hi, $name!") &#125;&#125;//繼承open class NewPerson(name: String) : Person(name)&#123; override fun sayHi() &#123; println("Hey, $name!") &#125;&#125;val person = Person("Jim")println(person.age)person.sayHi() object 單例(Singleton) 立即實體化 沒有建構子 靜態實例 類似java的static 但access寫法不一樣 僅能透過ClassName存取 不能透過實例存取 中間多有一個單例的名稱 無法訪問其outter class的成員 (因為是單例/靜態/不屬於物件) 可以實作介面 但不能繼承 因為沒有建構子 可以宣告在任何地方 companion只能定義在class中 且僅能有一個 類似於static interface MyInterface &#123; fun doit() &#125;object single : MyInterface&#123; override fun doit() &#123; &#125;&#125;class MyClass&#123;//static companion object&#123; //變數預設名稱為Companion var x=1 fun myStaticFunc() &#123; &#125; //java叫用MyClass.Companion.sfunc() &#125;//單例 (class外部無法access) object mySingle&#123; var x=1 fun myFunc() &#123; &#125; &#125;&#125;//外界access方式 (不能透過類別實例存取)MyClass.myStaticFuncMyClass.mySingle.x MyClass.Companion.myStaticFuncMyClass.mySingle.x 類別擴展 用途類似包裝utils工具 MyUtils.ext(person) 但更便利 Java無法使用 有block範圍限制 不同block可有各自的擴展 (預編譯要先過) 可以靜態擴展 (可擴展第三方類別) 可以動態擴展 (但離開block後就不能用了) 可以透過import 在不同的檔案類別中共用 fun Person.ext()&#123; println("are you $name ?")&#125;import com.example.myextends.extimport com.example.myextends.*//泛型fun &lt;T&gt; T.basicToString(i: Int) &#123;&#125;basicToString&lt;String&gt;(1) infix : 語法糖 便於閱讀 infix fun String?.append(s:String?) = this+svar x = "xxx" append "dddd" 泛型video*postpost ? 相當於 * (這樣說不正確) extends 相當於 out get安全 set禁止 生產者 super 相當於 in set安全 get禁止 消費者 inline : 相當於將函數程式碼坎入到caller處 比較適用於lambda型式的函數 refied : 與重新定義泛型有關 //聲明處型變interface Source&lt;out T, in E&gt; &#123; // &lt;&lt;---在這裡 fun funOut(): T //out表示僅能定義在輸出 fun funIn(t:E) //in表示僅能定義在輸入&#125;//使用處型變interface Source&lt;T&gt; &#123; fun funIn(t: Source&lt;out T&gt;) // &lt;&lt;---在這裡&#125;//泛型約束&lt;T extends String&gt; ==&gt; &lt;T : String&gt;//kotlin允許多個約束 (用where關鍵字)open class Food&#123;&#125;open class Fruit : Food()&#123;&#125;class Apple : Fruit()&#123;&#125; 不型變 指List與List是無關聯的 協變 指List是List的子類”型” (不是子類) 逆變 指List是List的子類”型” 突破java限制: //javainterface Source&lt;T&gt; &#123; public T nextT();&#125;public void demo(Source&lt;String&gt; strs)&#123; Source&lt;Object&gt; objs = strs; // 在Java中是不允许的 // 正确方式为 // Source&lt;? extends Object&gt; objs = strs;&#125; //kotlinabstract class Source&lt;out T&gt; &#123; // 使用out的话，T只能作为返回值 abstract fun nextT(): T // 不能作为传入参数，下面会报错 // abstract fun add(value: T)&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs&#125; functioninterface Function &lt;in T, out U&gt;Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt; enum 與 sealed sealed用法類似enum 但能以class或object識別 enum class Lang(val text: String)&#123; ENGLISH("Hello"), CHINESE("你好");&#125; sealed class Cmd(val text: String)&#123; class Play(val url): Cmd object Stop: Cmd&#125; 委派 Delegate field存取委派 內部用get/set實現 Delegates實作要繼承ReadWriteProperty 像是做lazy或監聽 var state:Int by Delegates.observable(0, &#123;prop, old, new -&gt; &#123; println("$old =&gt; $new")&#125;) 尾遞歸優化 避免StackOverflowError (其實就是轉為loop處理) 遞歸函數在最後呼叫稱為尾遞歸 函數前綴 tailrec Operator overloadinga == b // a.equals(b)a..b // a.rangeTo(b)a in b // a.contains(b)a[i] // a.get(i)a[i] = 9 // a.set(i, 9) 其他class MyClass&#123;&#125;Class::class.java //取得class實例 等同於Java的MyClass.class]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth]]></title>
    <url>%2Fhome%2F%2FSingle%2FOAuth.html</url>
    <content type="text"><![CDATA[youtube 意義user =&gt; client app(consumer) &lt;=&gt; server(service provider) app取得provider的service user不必向app透露帳號密碼 過程 client請求request token client將主導權導向server server向用戶詢問是否授權(導向server提供的畫面) server將主導權導向client client請求access token Signature 簽名 server透過signature驗證用戶身份 Signature = Signature Base String (AES with) secret key Signature Base String大概是由url的特徵產生 secret key僅有加密者與server知曉,故透過Signature就能讓server辨試身份 Request Token 與provider對話權的令牌 初步驗證app的權限後取得 client提供app key與signature向server請求request token Access Token 存取用戶資料授權的令牌 驗證用戶身份與同意授權項目後取得]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDagger.html</url>
    <content type="text"><![CDATA[gradle設定dependencies &#123; kapt &apos;com.google.dagger:dagger-compiler:2.5&apos; compile &apos;com.google.dagger:dagger:2.5&apos;&#125; android/kotlin注意事項@Inject/@Named 註解欄位時要加field:fragment要繼承DaggerFragment (否則從FragmemtManger取回時不會注入)activity要繼承DaggerAppCompatActivity 示例欲在MainActivity中自動注入Car實例 class Car&#123;&#125;class MainActivity()&#123; lateinit var car: Car init&#123; car = Car() //希望透過別的方式將Car注入到MainActivity的car &#125;&#125; 對象名詞定義 dependency : 依賴物 如Car client : 接收依賴者 如MainActivity 先設想一個注入器要有哪些提示才能完善 依據什麼對應D和C? 用類型,但要切確,例如不能把Object注入到String field 怎麼知道哪個field需要被注入? 用@Inject標記field 哪些類是可以拿來注入的? 用@Inject標記constructor 建構依賴時可能需要建構參數或靈活性? 用@Provides做method回傳建構好的實體 所以依賴可用@Inject標記constructor”或”直接做@Provides method回傳依賴物 同一個類但對應多個不同的子類或不同建構參數? 用@Qualifier給各自一個別名 field想宣告成界面類型要怎麼做? 用@Binds做綁定該類與其介面 注入的東西生命週期為何? 用@Scope定義 可以需要一個或多個生產依賴的工廠 稱作Module 至少要有個注射器建構這些工程吧 Component就是注射器 而Module依附在注射器裡 注射器下還有子注射器區別不同的環境 叫做SubComponent 那不就要寫很多code? 幾乎只要用interface或abstract進行描述 dagger會自動產生實做好的類別(Component/Module) 尚未驗證 依賴的可視性應該取決於注射器與子注射器的繼承關係 子能見父 但子與子間互不可見 “父可能也不能見子” (父子指的是注射器產生出的實體) 子的注射物無法override父的注射物 仍要用key 是否單例取決於scope 同名scope在不同注射器上應如同不scope 同注射器同scope間僅能有一個實體 沒指名scope表示沒此注射都用不同實體 一個依賴只能有一個scope @Singleton是一個Application層的scope 相當於global/root/最頂層 開始於一個該scope的頂層物件 該物件在產生其他依賴 這一群的依賴中 同一個Lazy只會回傳一個實體 與singleton無關 只是快取 step1 @Inject 宣告注入物 : 在注入物的Constructor標註@Inject (一種可以不在Module中宣告的方式) 使用注入物 : 在其使用處(注入處)標註@Inject (可用Lazy取得緩衝物件) @Singletonclass Car @Inject constructor() &#123;&#125;class MainActivity()&#123; lateinit var car: Car @Inject set&#125; 發現在android的dagger2, Constructor不一定需要@Inject step2 @Module Module如同依賴物的生產工廠 當有需要依賴時dagger會自己叫用這裡的fun Module可為’class一般類’或’abstract class抽象類’或’object實例’ 其中只有抽象類能用@Binds(因為code是自動產生的,僅需提供介面) 用抽象函數提供依賴 其輸入參數最終要能得到實例 (靠@Inject或@Provides) @Binds 用抽象函數提供轉型 @Binds abstract OutCls trans(InCls obj) @Provides 直接提供注入函數 回傳實例 @Moduleclass CarModule&#123; @Singleton //標示provide一個singleton實例 @Provides //標示該fun為一provide函數 fun provideCar() = Car()&#125; 一個物件要被提供給注射器 @I : 直接在該物件的constructor宣告@Inject (會自動產生依賴函數於注射器) @P : 用@Provides寫函數回傳提供 (寫在Module裡,就可以省略1) @B : 轉型需求 僅是一個輔助 1或2再加上@Binds abstract fun… step3 @Component Component稱為注入器更貼切 只需定義其介面 dagger2的builder會實作該介面 並建出前綴為Dagger的class 並用該class建立注射器實體 @Singleton //如果Module中有Singleton這裡也要有(原因可能跟@Scope綁定作用域相似)@Component(modules = arrayOf(CarModule::class)) //定義注入器能注入的Moduleinterface MainActivityComponent &#123; fun injectCar(main: MainActivity)&#125;//dagger2會自動建出DaggerMainActivityComponent並且實作injectCar() step4 實際注入 dagger2負責建立依賴 但依賴注入的時間點仍須自己處理 //方式1 自有注射器 (或繼承DaggerAppCompatActivity 他能替我們注入activity的依賴)class MainActivity&#123; lateinit var car: Car @Inject set init&#123; DaggerMainActivityComponent //dagger自己產生的class .builder() .carModule(CarModule()) //將Module提供給注入器 .build() //建立注入器實體 .injectCar(this) //替this注入依賴 (沒有lazy) &#125;&#125; //方式2 建立Android Framwork App共用的注射器 App要註冊到manifestclass App : Application() &#123; //android.app.Application val injector: AppComponent by lazy &#123; DaggerMainActivityComponent .builder() .carModule(CarModule()) .build() &#125;&#125; more1 @Qualifier 或@Named(“type”) 用來替@Inject注入處綁定@Provide fun, 解決Car能由多個provide fun產出的情形 首先要自訂Annotation @Qualifier@Documented@Retention(RUNTIME)public @interface ProvideID &#123; String value() default "";&#125;@QualifierA@Provides fun provideCarA():Car&#123;...&#125;@QualifierB@Provides fun provideCarB():Car&#123;...&#125; //kotlin中明確指出annotation作用的位置為field:@Inject@field:Named("local")lateinit var ....或@field:[Inject Named("local")]lateinit var .... 將該Annotation註釋到@Provide與@Inject的注入處即可 more2 @Scoperef 用來綁定@Provide與@Component注入器間的生命週期 讓provide產生的實例沿用直至注入器結束 一個component中僅能有一個scope 同一個component中不允許兩個同類型的’注射物類型’ (以類型的字面定義區分 無論繼承關係) 同一個scope中不會建立兩個同類型的’注射物實體’ (即局部單例) 用@I或@P方式建立依賴物(當兩個都有建立時,依賴是優先從@P方式取得) 若是依賴在注射器中是從@P方式取得 則@I的scope宣告會被忽略 故scope應該建立於provider函數上 (很容易理解 因為provider函數的回傳是我們自己實例化的 scope限制的是該函數 而不是函數的回傳) @B因為是自動產生provider函數 所以會參考@I的scope宣告 more2 @Singelton 即@Scope做出來的一個Annotaion 字面上的意思是Singelton 實際上每個scope中的每個類型都僅能有一個實體對映 若要對映多個 1.用@Qualifier區分 2.用@Binds轉成不同型別(非@Binds真正的目的) more3 @Reusable 類似@Singelton但不再需要與注入器綁定 multi-thread時可能會出現多個實例 more4 @BindsInstance 與@Component注射器的builder相關 貌似能從builder()後接上需要提供的依賴物 more5 注射器間的依賴 一個注射器的依賴來源可以是Module 也可以是另一個注射器 @Component(dependencies = MainActivityComponent.class) //依賴另一個注射器interface Activity2Component &#123; fun injectCar(aty: Activity2)&#125;Activity2Component aty2Component = Dagger Activity2Component.builder() .mainActivityComponent(mainAtyComponent) //build時需提供注射器的依賴 .build(); more6 注入器間的繼承 @SubComponent Annotation使用上如同@Component 同一個Component下的SubComponent可以有各自的scope 概念就跟類別繼承一樣]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRxJava.html</url>
    <content type="text"><![CDATA[stream的類型 cold : 如同隨選視訊 流是固定的 訂閱才送 每次送都是完整的 不論是否送過給別人 hot : 如同直播 流是不斷送出的 無法減速的 每次訂閱都只能從當下開始 沒有終點的 物件解釋//基於Obserable建立一個可訂閱對象Obserable.create( new OnSubscribe&lt;String&gt;()&#123; @Override public void subscribe(Emitter&lt;String&gt; e)&#123; //發送事件 e.onNext("new event!"); e.onComplete(); &#125; &#125;) .subscribe( //訂閱並設定接收的對象 參數列:onNext, onComplete, onError new Consumer&lt;String&gt;() &#123; @Override public void accept( String s) &#123; System.out.println(s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;); ref Obserable : 可觀察對象 除此還有多種不同類型的可觀察對象可以create OnSubscribe : 可訂閱對象 負責發送產生事件 Emitter : 相當程度代表一個訂戶(多少有連結關係) Observer : 觀察者 即訂戶 接收事件 Consumer : 一個通用的介面 帶有一個accept方法 該方法被叫用的意義與時機由外界定義 BiConsumer : 同Consumer 但accept能傳如兩個參數 upstream / downstream : 即兩個observable的相對應關係 donw=up.map(…) 大致流程(一種意象上的形容 幫助記憶) 最末端的observer開始o.subscribe(observer) 一路向上訂閱 操作符也如同一個observer+observable (向上進行訂閱 向下提供可觀察對象) 一直訂閱到最頂端的observable (到頂端前,中間的操作符也可能發射值) observer相當於會被丟到OnSubscribe.subscribe()直接被呼叫onNext/onError/onCompleted 一個observable被重複訂閱也是相同的流程 但不見得會發射一樣的值 要視observable設計與規劃而定 例如cold與hot的差別 ObservablesRxJava搭配Room observable flowable : 有backpresure策略 可控制流速 single : 只發1次(onSuccess)或0次(onError)事件 沒有其他選項 completable : 沒有事件 只有成功與否 只有onComplete與onError 常用.andThen(…)操作符再轉出其他obserable maybe : single+completable 一次性使用 : single / maybe 僅關注成敗 : completaion emmiter interface onNext(T t) 多事件型會用這個關鍵字 onSuccess(T t) 單事件型 相對應的是onError(Throwable t) observer interfaceobserver與emmiter的介面有點像是mapping 呼叫emmiter的onNext近似於observer的onNext被呼叫 onError後 onComplete應該就不會被呼叫了 Subjectref subject同時擁有observable與observer的能力. 做為observer可以直接透過subject實體餵入事件onNext(“event”) 做為observable能讓外部訂閱 算是一種整合應用 做為observer很單純 但做為observable則有很多變化 PublishSubject 沒有任何特殊機制 BehaviorSubject 訂閱時會發射預設值或最後一值 像是一個狀態變數一樣 任何時候都有值 AsyncSubject 只在onCompleted才發射值(最後一個) ReplaySubject 任何時間訂閱都從頭再發射一次 操作符 操作符回傳的都是Observable 但向操作符提供的function僅是完善操作符的一小部分 func的in/out與操作符的out是不相干的 操作符的應用 應考慮流的屬性(hot/cold) 操作符 - 結合concat一個流結束 才切到下一個流 marge多個流同時穿插 當一個流onError就全部結束 操作符 - 建立create 自訂OnSubscribe 自己提供值來發射 from 用Iterable的內容值發射 just 從參數列給值來發射 defer 產生新的observable (每次訂閱就會重新產生) Interval 值從0開始 每固定時間發射一次 timer 在一段時間之後發射0 之後就completed range 分別發射一個區間的值 repeat 將收到的值重複發射N次 操作符 - Transforming 將值變形buffer(count) 累積count個值 轉成array發射 buffer(count, skip) 累積skip個值 只取count個 轉成array發射 window(count/time) 同buffer 但包裝成Observable 可用時間做buffer map 將值個別map成新的值 ex:1 =&gt; “1” flatMap 將值個別map成以Observable產生的值 ex:1 =&gt; Observable.just(“1”) flatMapIterable 將值個別map成以Iterable產生的值 ex:1 =&gt; listOf(“1”) map說明 以上三個map操作符輸出的都是Observable\ 僅只是用不同的方式建立內容 scan 類似map的用法 但多一個acc的累加參數 (如若有設初始值,在subscribe時會先送初始值,無論上游是否有值) groupBy 依值建立GroupedObservable 返回Observable\&lt;GroupedObservable\&lt;K,T&gt;&gt; cast 轉型 操作符 - Filteringdebounce 抗反彈 收到值後需N時間後無新值才會發射 否則用新值且N重算 throttleWithTimeout (同throttleLast?) 同debounce 但N不會重算 throttleFirst 同debounce 但N不會重算 且取的是最先發生的值 sample 固定時間內取最新的一筆 時間的起點與訂閱時間有關 與資料發生時間無關 distinct 僅發射不同的 從未出現過的值 distinctUntilChanged 僅發射與前一個值不同的值 elementAt 僅發射第N個值(接收到的第N個) filter 僅發射函數返回為true的值 last / first 僅發射函數返回為true的第一或最後一個值 發射完即completed take 僅發射固定筆數 發射完即completed skip 忽略前面N筆 blocking… 將上游阻塞 待下游… 用途尚未確認 操作符 - CombiningObservable.combineLatest(O1,O2,combiner) 當O1或O2有值時透過combiner函數決定發射的值 (傳入O1,O2的最新值) (多形用法還多) join(O2,T1,T2,combiner) 將現有Observable(O1)與O2結合 T1/T2分別表示O1/O2有效的時間 兩者都在有效時間內時會呼叫combiner進行發射 joinGroup … Observable.merge 混合兩個Observable mergeWith 同merge 但沒試出結果 startWith 開頭時插入值 switch 當一個O發射多個O時 切換到最新發射的O Observable.zip(O1,O2,O3,zipper) … 將O1,O2,O3的值依序合併成新值 操作符 - 異常處理onErrorReturn 捕捉onError異常 並補一個值 之後onCompleted onErrorResume 同onErrorReturn 並補一個Observable繼續運作 OnExceptionResumeNext 針對Exception處理 retry / retryWhen onError時重試 retryWhen要注意forever loop問題 操作符 - Utilitydelay 延遲值的發射 delaySubscription 延遲訂閱的時間 doOnEach/doOnNext/doOnSubscribe/doOnUnsubscribe/doOnError/doOnCompleted/doOnTerminate/finallyDo 監聽事件 直接回傳上游Observable materialize 將事件與值封裝為Notification類型 dematerialize 將Notification解回事件與值 [ subscribeOn / observeOn ] 將個訂閱過程拆分”訂閱時期”與”觀察(遞值)時期” 訂閱時是由下往上(code的順序) 觀察時期是由上往下 subscribeOn 在訂閱時期指定thread (訂閱時期比較短 相應的函數通常只執行一次) observeOn 在觀察(遞值)時期指定thread (觀察(遞值)時期比較長 相應的函數通常反覆執行) timeInterval 發射值與前一個值之間的時間差 timeStamp 發射值發生時的時間戳 timeout 逾時未出現值則發出onError 或發出endWith+onCompleted using 有點像是建立一個與該Observable伴隨生命的物件 操作符 - Conditional and Booleanall(func) 根據func的回傳 如果至onCompleted都沒有false 就發射一個true 然後onCompleted amb(O1,O2…) 讓O1,O2…競賽 以最先有值或事件的O做為發射的來源 contains(func) onCompleted前func回true則發射true 否則發射false 然後onCompleted isEmpty (true or flase) + onCompleted defaultIfEmpty empty時發射default+onCompleted sequenceEqual(O1,O2) 用來判斷O1,O2的發射值與順序是否一模一樣 skipUntil(O2) 直到O1出現O2的pattern前都skip skipWhile(func) 直到func回傳false前的值都skip takeUntil / takeWhile … 如上類似 操作符 - 合計Aggregatecontact 合併兩個O 但第一個onCompleted才能切第二個 count 在O結束時 發射值的數量然後onCompleted reduce 壘算 直到O結束才發射 然後onCompleted (類似scan 只是scan是每次壘算都發射) collect(init,collector) 將值收集到ArrayList之類的物件 在O結束時才發射 然後onCompleted 操作符 - Connectablepublish 將O轉成需要connect才發射的型態(Connectable) 主要用意在控制多個observer時的發射時機 connect 當connect時該Connectable即已經開始訂閱上游 refCount 將Connectable轉回普通的O replay 轉為一個Connectable 並保留數個值或一段時間的值做新訂閱者的startWith (字面很像重播 但實際比較像buffer的效果) 操作符 - 自訂操作符ref compose (自定義/加工observable) Transformer 加工上游observable 再返回另一個observable 可以當成一個聚合的操作符 執行一個compose裡面藏了很多操作符 lift (自定義observer) 能插入一個Operator/Subscriber]]></content>
      <tags>
        <tag>Android</tag>
        <tag>ReactiveX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast]]></title>
    <url>%2Fhome%2F%2FAndroid%2FBroadcast.html</url>
    <content type="text"><![CDATA[Broadcast 發送或接收系統事件廣播 如低電量/簡訊生命週期在onReceive()結束後終止以靜態方式(manifest)註冊接收器 可以不用開app 也能接收事件 registerReceiver(new BroadcastReceiver()&#123;&#125;, new IntentFilter("action..."));unregisterReceiver(mybc);Intent intent = new Intent(this, MyBC.class)Intent intent = new Intent("action...")intent.putExtra("data", "mydata");sendBroiadcast(intent);class MyReceiver extends BroadcastReceiver&#123; onReceive(content, intent);&#125; 或以常駐的方式(不論app是否啟動或kill都能被執行) &lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.EDIT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Dev Log]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDevLog.html</url>
    <content type="text"><![CDATA[TextView行高在編輯文字時會改變addTextChangedListener(object:TextWatcher&#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; //每次文字更動時都在設定一次行高 setLineSpacing(0f, 1f) setLineSpacing(20f, 1f) &#125;&#125;)]]></content>
      <tags>
        <tag>Android</tag>
        <tag>開發紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRecyclerView.html</url>
    <content type="text"><![CDATA[加入RecyclerView//0. 取得viewvar view = findViewById&lt;RecyclerView&gt;(R.id.recyclerView)//1. 設定layoutval layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)view.layoutManager = layoutManager//2. 設定adapterview.adapter = MyAdapter(data)//3. 設定分隔線view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); class MyAdapter : RecyclerView.Adapter() &#123; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; //建立ItemView並存於ViewHolder回傳 &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; //將欲顯示的內容抽換到holder中的view &#125; override fun getItemCount(): Int &#123; &#125; //自訂ItemView的Holder class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2Fhome%2F%2FAndroid%2FFragment.html</url>
    <content type="text"><![CDATA[加入Fragment fragment要被砍入的位置 R.id.contentFrame fragment自身的佈局 R.layout.main_frag var fragment = supportFragmentManager.findFragmentById(R.id.contentFrame)?:MainFragment().also &#123; supportFragmentManager.beginTransaction().apply &#123; add(R.id.contentFrame, it) commit() &#125;&#125; class MainFragment : Fragment()&#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; var view = inflater?.inflate(R.layout.main_frag, container, false) return view &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2Fhome%2F%2FAndroid%2FGradle.html</url>
    <content type="text"><![CDATA[Groovy 語言特性介紹 加快編譯//gradle.propertiesorg.gradle.jvmargs=-Xmx512morg.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.configureondemand=true 異常”Gradle project sync failed”在android sample中加入kotlin一直不成功 但new project中卻沒問題 把code移入new project中確認也沒問題 可見是環境造成 rm -rf .gradle/ .idea/ build gradle 最後是把src root folder從Application改名(Refacotr)為app才正常 buildTypes 控制編譯流程 debug / release productFlavors 分歧編譯目錄 mock / prod 不同選擇即用不同目錄下的檔案編譯 flavorDimensions : 對flavor再進行一次分類 例如platform,vertype 組合出多個目錄 BuildConfig設定會透過BuildConfig類帶入java中 applicationId作用在google play store上 用以辨識app, 不同的release要有不同的applicationId, 否則會被視為同一個app 可寫在defaultConfig或個別的buildType/productFlavors中 也可用applicationIdSuffix]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE_ENV]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIDE-ENV.html</url>
    <content type="text"><![CDATA[API版本 SDK TOOL路徑cd ~/Library/Android/sdk/tools/bin/ export JAVA_HOME=`/usr/libexec/java_home -v 1.8`export SDK_HOME=/Users/jimliu/Library/Android/sdkexport ANDROID_HOME=/Users/jimliu/Library/Android/sdkexport GRADLE_HOME=/Applications/Android\ Studio.app/Contents/gradle/gradle-3.2/export PATH=$JAVA_HOME/bin:$&#123;SDK_HOME&#125;/tools/bin:$&#123;SDK_HOME&#125;/platform-tools:$GRADLE_HOME/bin:$PATH cat &gt; ~/.bash_profile貼上之後ctrl+c 添加Library Adding a Library Project Adding a Jar library 快速鍵//自動完成不分大小寫editor&gt;general&gt;code completion的case sensitive completion要調為none//自加cmd IKJL : 上下左右cmd+sft J/L : to line start/endcmd+sft I/K : extend/shrink selectioncmd p : parameter infocmd ;或z : Basic/ in Code Completion 函數自動完成 (api doc)cmd , : insert live template 插入樣板//mousecmd click : Declaration/ in Main menu Naviagte 查原始碼 (或xml)//視窗檔案切換ctrl tab//游標opt 左右 : 左右移 擴大/縮小選取sft opt : 上/下移動行sft enter : end + entercmd enter : enter + 上 (游標位置不動產生一空行)//快速產生程式碼 souf fori logi cmd j : 插入樣板cmd opt t : if / try / while//開啟燈泡內的選項opt enter//查詢物件的method/field 或任何可能的字串ctrl space : 查詢method/field (選定後按tab!!!!) 或 提示字串自動完成//建立methodcmd n : 各式選單ctrl o : select override/implement//單純查詢ctrl j : 查詢文件定義cmd p : 顯示參數定義 ****cmd b : 查原始碼 (或xml)cmd u : 跳到父類cmd opt L : 自動格式化cmd F9 : 編譯執行//搜尋內容或檔案sft sftsft F6 : 變數改名cmd + d : 複製貼上一整行 或貼上已選取的內容cmd sft a : 開啟系統功能搜索]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resource]]></title>
    <url>%2Fhome%2F%2FAndroid%2FResource.html</url>
    <content type="text"><![CDATA[資源引用出現的樣式[@|?][namespace:]type/name//type : string，dimen，drawable，layout，color，anim，animator，mipmap，raw，id，style，attr，array//@ : 引用切確資源@android:string/title //Android本身的資源@string/title //省略namespace即引用自建資源//? : 引用自主題屬性 (如果主題沒定義該屬性會報InflateException)android:background="?attr/colorPrimary"//+ : 通常是替自己建立資源設定ID時使用android:id="@+id/myViewId"//@null : 應該是一個特別的id 讓某些屬性能夠不執行android:button="@null"android:background="@null" assets與raw assets不會產生id於R資源 可有目錄結構 透過AssetManager讀取 raw屬於R資源 透過R.id讀取 AssetManager am = getAssets(); InputStream is = am.open("filename"); InputStream is = getResources().openRawResource(R.id.fileNameID);VideoView.setVideoUri(Uri.parse("android.resource://" + getpackageName() + "/" + R.raw.movie)); 多國語言只需透過IDE編輯即可 (勾選不需要翻譯的字串) Drawable 可被畫出在View上的 例如圖檔來源 from BitmapDrawable 也可從xml定義 color shape : 形狀 方圓線等 stroke 描邊 solid 填充 corners 邊角 padding selector : 狀態 每個item搭配一個狀態對應一個drawable state_pressed / state_focused / state_selected / state_checkable state_checked/ state_enabled / state_activated / state_hovered state_window_focused layer-list : 圖層 越先執行的在越底層 用很多層疊出一個drawable]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storage]]></title>
    <url>%2Fhome%2F%2FAndroid%2FStorage.html</url>
    <content type="text"><![CDATA[Storage internal與external是以app間分享的角度,external表示可被分享 無論internal或external 在app移除都會跟著移除 除非用是PublicDirectory internal /data/data/ 被連結到(/data/user/...) 一定存在 別的app不能訪問 用Context.filesDir取得 primary external /Android/data/PACKAGE_NAME 被連結到(/storage/emulated/...) 可能是內部記憶體卡的分割或外部記憶裝置(Adoptable Storage) 用Context.getExternalFilesDir取得 secondary external 外部記憶裝置 不一定存在 //Context.filesDir (/data/data的連結) /data/user/0/PACKAGENAME/files//Context.getExternalFilesDir /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures//Context.getExternalFilesDirs (Primary/Secondary) /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures /storage/12E9-1105/Android/data/PACKAGENAME/files/Pictures //Environment.getExternalStorageDirectory /storage/emulated/0 //Environment.getExternalStoragePublicDirectory /storage/emulated/0/Pictures //Environment.getDataDirectory /data//Environment.getDownloadCacheDirectory /cache//Environment.getRootDirectory /system//Environment.getExternalStorageState mounted]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layout]]></title>
    <url>%2Fhome%2F%2FAndroid%2FLayout.html</url>
    <content type="text"><![CDATA[Layout view跟layout定義上的差別: view是通常形容元件 layout則是容器(容器內的排版)layout是view的子類 RelativeLayout定位於 某元件 或 所處容器 的相對位置 FrameLayout定位於左上角 (view會重疊) LinearLayout水平或垂直 接續排列 權重分佈 TableLayout格狀排列 ConstraintLayout約束排列 約束元間之間的相對關係 (取代RelativeLayout) StaggeredGridLayout格狀(磚塊)排列 LayoutParams.FILL_PARENT //依父容器大小 填滿父容器LayoutParams.WRAP_CONTENT //依內容大小 適當顯示 SwipeRefreshLayout有下拉Refresh功能 findViewById&lt;SwipeRefreshLayout&gt;(R.id.refresh_layout)?.apply &#123; isRefreshing = true //設定為正在refresh setColorSchemeColors( ContextCompat.getColor(activity, R.color.colorPrimary), ContextCompat.getColor(activity, R.color.colorAccent), ContextCompat.getColor(activity, R.color.colorPrimaryDark) ) setOnRefreshListener&#123; println("do refresh...") postDelayed(&#123; println("done refresh...") isRefreshing = false //設定為沒在refresh &#125;, 3000) &#125;&#125; 屬性一個view中前綴layout的屬性是給其容器看的 例如layout_gravity與gravity 以個是告訴容器把自己放在哪 另一個是自己中把內容物放在哪 指定layout managermanager = new LinearLayoutManager(this);RecyclerView mList = (RecyclerView) findViewById(R.id.list_view);mList.setLayoutManager(manager);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArchitectureComponent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FArchitectureComponent.html</url>
    <content type="text"><![CDATA[video video LifecycleOwner : lifecycle的擁有者 像activity或fragment都是LifecycleOwner 可透過getLifecycle()取得Life LifecycleObserver : 一個介面 實作這個介面 就能透過Life.addObserver加入監聽lifecycle事件的行列 ViewModel :]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMisc.html</url>
    <content type="text"><![CDATA[Launcher 即手機home鍵看到的畫面 以及其延伸的機制 本身同樣為activity HomeScreen WorkSpace 上半部的大範圍 HotSeat 底下的熱連結 AppList (GridView) 應用 Shortcut 將app中某些功能結合user需求產生快捷 LiveFolder 類似將一個content provider封裝 AppWidget WallPaper]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Widget]]></title>
    <url>%2Fhome%2F%2FAndroid%2FWidget.html</url>
    <content type="text"><![CDATA[Widget 一個自訂的service(app)顯示且整合於WorkSpace中 整合困難的部分在於launcher與widget執行於兩個不同的process中 AppWidget 即自訂的app AppWidgetHost 一個AppWidget的宿主 負責與AppWidget交互 AppWidgetHostView AppWidgetManager AppWidgetProvider 提供view的更新 是一個BroadReceiver (即使是空的也無所謂) AppWidgetProviderInfo 提供資料的更新(mata-data) 寫code只需要AppWidgetProvider與Manifest+provider_info+layout的設定即可 RemoteViews 一個能夠對映view的投射物件(兩者都從相同的layout建立) 透過RomoteViews操作view 再將此RomoteViews丟到遠端 遠端即可知道如何更新實際的view 達到跨process的view操作]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAnimation.html</url>
    <content type="text"><![CDATA[*post animation property (透過修改view實例自動產生動畫) view animation (tween) (Alpha Rotate Scale Translate Set) drawable animation (frame by frame) 單位: 數字 : px 50% : 自己寬度的50% 50p : 容器寬度的50% //Tweenanim.setDurationanim.repeatMode // 重頭再開始 / 倒退再開始anim.fillAfter // 停在結束anim_set.add(anim)view.startAnimation(...)anim = animationUtils.loadAnimation(R.id....) // from xmlaty.overridePendingTransition() //過場動畫 //viewFlipperfilper.setInAnimation(...)filper.setOutAnimation(...) android:activityOpenEnterAnimation&lt;ViewAnimator android:inAnimation="@android:anim/slide_in_left"&gt; &lt;TextView/&gt; &lt;TextView/&gt;&lt;/ViewAnimator&gt; youtube Animation Tweened (補間動畫) alpha 淡入淡出 rotate scale translate 移動 Frame-by-Frame Property Animation (屬性動畫) Tweened與ValueAnimator的差別 Tweened僅是繪製上的調整 也就是說移動一個button 事實上只是畫到別的地方而其屬性仍保留在原處 而ValueAnimator則不斷的調整view的屬性 TweenedAlphaAnimation animate = new AlphaAnimation(1, 0);animate.setStartOffset(1000);animate.setDuration(1000);animate.setFillAfter(true); //動畫後停留在最後animate.setFillBefore(false); //動畫後回到起點animate.setRepeatCount(1);AnimationSet aset = new AnimationSet(true); //共用interpolatoraset.addAnimation(animate);imageview.startAnimation(aset); //rotate需定義旋轉的中心點,中心點可相對於自己或containarRotateAnimation animate = new RotateAnimation(0, 360 Animation.RELATIVE_TO_PARENT, 1f, Animation.RELATIVE_TO_PARENT, 0f); //scale需定義縮放的軸心,軸心可相對於自己或containarScaleAnimation animate = new ScaleAnimation(1, 0.1f, 1, 0.1f Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); //向中心點縮小 ####用xml建動畫流程建res/anim目錄,寫alpha.xml,android studio會自動產生對應的code在gen/R.java &lt;set ...&gt; &lt;alpha ... /&gt;&lt;/set&gt; Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha); Interpolator用途示範插值器 補插動畫效果 Frame-by-Frame&lt;animation-list ...&gt; &lt;item android:drawable="..." android:duration="500" /&gt;&lt;/animation-list&gt; imageview.setBackgroundResource(R.drawable.animff);AnimationDrawable ad = (AnimationDrawable)imageview.getBackground();ad = AnimationUtils.loadAnimation(this, R.anim.alpha); LayoutAnimationController控制layout group中動畫的順序 ####從java建立Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha);LayoutAnimationController lac = new LayoutAnimationController(animate);lac.setDelay(0.5f);lac.setOrder(LayoutAnimationController.ORDER_NORMAL);listview.setLayoutAnimation(lac); ####從xml導入&lt;LayoutAnimation delay="0.5" animationOrder="normal" animation="@anim/alpha"/&gt; &lt;ListView layoutAnimation ="@..."/&gt; AnimationListeneranimation.setAnimationListener(new AnimationListener()&#123; onAnimationStart() onAnimationEnd() onAnimationRepeat()&#125; ValueAnimator ValueAnimator : 類似以值的變化形容動畫 類似補差值 ObjectAnimator : 將ValueAnimator套用到Object上 ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); animator.setDuration(5000); animator.start(); //組合多個動畫ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); //在xml定義anim_file.xmlAnimator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file); animator.setTarget(view); animator.start(); Activity overridePendingTransition方法需要在startAtivity方法或者是finish方法調用之後立即執行 overridePendingTransition(R.anim.zoomin, R.anim.zoomout)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2Fhome%2F%2FJava%2FThread.html</url>
    <content type="text"><![CDATA[相關知識 program : binary code,一段機械碼或可被執行的檔案 process : 執行一個program後形成一個process,其中包含一塊記憶體空間(code/heap). process間是不共用的,互相通信需特殊的機制 thread : 實際執行程式碼的單元 包含stack與cache儲存變數與參考 task : 任務,軟體概念,如同Runnable介面 yield : 類似sleep 但不能指定時間 目的在於讓出cpu時間給同優先級的執行緒 (針對非timeslicing作業系統) Concurrency(並發) vs Parallelism(並行) 與thread數量無絕對關連 與資源共用有關資源可以指時間或執行緒或資料物件例如javascript中共享執行緒的異步執行(協程)(Promise)就屬於併發的應用 並發 : 一個資源 輪流供應多個人使用 (共用需要使用鎖)(有能力處理一起發生的事件,但未必一起執行) 並行 : 每個人有各自的資源 雖同時進行 但互不相干 Thread 其應用通常與Lock息息相關 Daemon Thread 守護線程 又稱background thread 其生命週期中斷於程式的其他thread全部結束 例如GC線程setDaemon(true) corutine 協程 由編譯技術實現 被視為輕量級thread 應該是依附在thread 用於異步執行 透過async/await讓工作不立即執行 且能夠被等待 相當於排程的概念 更有效率的使用thread 例如 : 在main thread中連續執行ABC三函數 一般情況下執行的順序是ABC 若B能進入異步 順序會變為AC…B (B不確定何時執行) 若B能進入異步 且C能等待B執行完 順序又變回ABC 假若B在異步執行時是透過其他thread 那C等待B時main thread還能繼續其他工作 async&#123; value = await getData();&#125; Thread Poolref ExecutorService 即thread pool的實現 Executor介面類 即execute() 供ExecutorService實現 Executors工具類 便於產生ExecutorService 內部有一個BlockingQueue存放任務 每個thread如同一個looper等待取得task Thread的切換一個流程中某些動作必須跳到異步執行 待執行完再切回原本的thread 這些切換thread的動作將使一個流程無法順暢的寫完 舉例: user按下執行按鈕 (ui) 下載url的內容 (network) 存成本地檔案 (i/o) 取得執行狀況 將內容顯示於ui (ui) message handler 適合簡單的切換 多個連續流程仍難以處理 範例 切換越多次巢狀越明顯 public class AppExecutors &#123; //seeu 建立Thread切換機制 private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors() &#123; diskIO = Executors.newSingleThreadExecutor(); networkIO = Executors.newFixedThreadPool(THREAD_COUNT); mainThread = new MainThreadExecutor()); &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; private static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; ForkJoinPool專處理可併行的任務 將任務(ForkJoinTask)切割執行於pool中 運用於Collection.ParallelStreams中 //ForkJoinTask大致寫法@Overrideprotected Integer compute() &#123; if(!needSplit)&#123; return sum(); &#125;else&#123; int middle = (start + end) / 2; CountTask task1 = new SumTask(start, middle); CountTask task2 = new SumTask(middle+1, end); //執行分割任務 task1.fork(); task2.fork(); return task1.join() + task2.join(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Room]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRoom.html</url>
    <content type="text"><![CDATA[TypeConverter 建立物件與database primitive type的轉換 data class Word( @SerializedName("naText") var naText: String, @SerializedName("taText") var taText: String)//透過TypeConverter建立object與json字串的轉換class WordConverter &#123; @TypeConverter fun word2Json(words: ArrayList&lt;Word&gt;): String &#123; val json = Gson().toJson(words) return json &#125; @TypeConverter fun json2Word(json: String): ArrayList&lt;Word&gt; &#123; val turnsType = object : TypeToken&lt;ArrayList&lt;Word&gt;&gt;() &#123;&#125;.type val list = Gson().fromJson&lt;ArrayList&lt;Word&gt;&gt;(json, turnsType) return list &#125;&#125;@Entity(foreignKeys = [ForeignKey(entity = BookInfo::class, parentColumns = ["id"], childColumns = ["bookId"], onDelete = CASCADE)])@TypeConverters(WordConverter::class) //加入需要的TypeConverterdata class BookContent(@PrimaryKey(autoGenerate = true) var id: Long, var bookId: Long, var words: ArrayList&lt;Word&gt; = ArrayList&lt;Word&gt;()) ForeignKey (外鍵) 使該table(child)與外界的table(parent)連動 例如一起被刪除 Embedded 在table中坎入其他table或pojo class 避免宣告裡必須攤平所有欄位失去結構 可作為查詢時暫用的表 實際的解析上有點像是將Embedded表的欄位名(變數名)平面化 所以各個表中的欄位名還不能重複 若重複還要加prefix將整個表的欄位名加前綴 select語句針對prefix的部分必須一一列出(太麻煩了) SELECT *, tbl_b.id as prefix_id FROM tbl_a INNER JOIN tbl_b ON tbl_a.id=tbl_b.id WHERE ... Relation 可以建立一個連動的查詢 整合到一個table中 (用起來方便但要多建一個class) @Entitydata class BookSet( @Embedded var info: BookInfo?=null,//BookContent.bookId對映BookInfo.id//查詢的結果必須是List或Set @Relation(parentColumn = "id", entityColumn = "bookId") var content: List&lt;BookContent&gt;?=null) Migration 升級]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB-MySQL]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDB-MySQL.html</url>
    <content type="text"><![CDATA[SQLiteOpenHelperref public class DBHelper extends SQLiteOpenHelper &#123; public DBHelper(Context context) &#123; super(context, "mydb.db", null, 0); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("CREATE TABLE IF NOT EXISTS user(\ _id INTEGER PRIMARY KEY AUTOINCREMENT, \ name TEXT)" ); &#125;&#125;dbHelper = new DatabaseHelper(context);SQLiteDatabase db = dbHelper.getWritableDatabase();SQLiteDatabase db = dbHelper.getReadableDatabase();db.close();//insertContentValues values = new ContentValues();values.put("id", 1);values.put("name", "jim");db.insert("user", null, values);db.execSQL("insert into user (id,name) values (1,'carson')") //updatevalues.put("name", "jim2");db.update("user", values, "_id=?", new String[] &#123; "1" &#125;);db.execSQL("update [user] set name = 'jim2' where _id=1");//deletedb.delete("user", "_id=?", new String[]&#123;"1"&#125;);db.execSQL("delete from user where _id=1");//seleteCursor c = db.rawQuery("select * from user where id=?",new Stirng[]&#123;"1"&#125;);c = db.rawQuery("SELECT _id, name FROM user");c = db.query("user", new String[] &#123; "_id", "name" &#125;, "_id=?", new String[] &#123; "1" &#125;, null, null, null); Cursor//遍歷1while (c.moveToNext()) &#123; int idx = c.getColumnIndex("_id"); //取得欄位idx int id = c.getInt(idx); //取得資料&#125; //遍歷2c.moveToFirst(); while(!c.isAfterLast())&#123; //dosomething c.moveToNext(); &#125;//記得關閉c.close(); 將db檔預先置入apk 將寫好的db放到res/raw下 在開啟db前將資源寫入android檔案系統 InputStream myInput = context.getResources().openRawResource(R.raw.database);File file = context.getDatabasePath("mydb.db");if (!file.exists()) &#123; try &#123; OutputStream myOutput = new FileOutputStream(file); byte[] buffer = new byte[1024]; int length; while ((length = myInput.read(buffer))&gt;0)&#123; myOutput.write(buffer, 0, length); &#125; myOutput.close(); myInput.close(); mIsDBOK = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Task]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTask.html</url>
    <content type="text"><![CDATA[Activity.runOnUiThread activity內建的一方法 便於異步切回main thread AsyncTaskref aad : Execute a background task inside of a Service thread pool+handler應用的再封裝 易於與main(UI) thread切換 需在main thread建立與執行 (最終記得cancel) 如同Thread一次性使用 結束後無法重新啟動 class MyTask extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123;//&lt;傳入型態, 進度值型態, 結果型態&gt; @Override public Bitmap doInBackground(String ...args)&#123; //進入異步 不要做view操作 publishProgress(...); activity.runOnUiThread &#125; onPreExecute() //回main thread onProgressUpdate(Integer... values) //回main thread onPostExecute(Bitmap bitmap) //回main thread&#125;new MyTask().execute("str"); CountDownLatch// 1.設定好要count down的數量final CountDownLatch countDownLatch = new CountDownLatch(1);// 2.在異步thread結束後countDown使其歸零countDownLatch.countDown();// 3.一直等到countDownLatch為0才返回countDownLatch.await(); Timer &amp; TimerTaskTimer timer = new Timer()timer.schedule(new TimerTask() &#123; @Override public void run() &#123; //... &#125;&#125;, 1000, 1000);timer.cancel() Looper + Handler Looper消息接收器 建立時連帶建立一個MessageQueue Handler消息處理/發送器 用途在於將msg或task隊列執行 Looper與Handler內部都是利用current thread做為key 所以建立與呼叫時所處的thread很重要 //自訂的class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; //以當下thread建立looper (內部會存於map中) Looper.prepare(); //以當下thread建立Handler 並取得當下thread的looper中的MessageQueue //於是looper與handler都有共通的msgQueue //之後外部可用handler建立傳遞msg進入msgQueue //loop即能收到msg並透過msg的callback回叫handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; &#125; &#125;; //以當下thread執行loop (當下thread會進入等待msg的loop而block住) Looper.loop(); &#125;&#125; MessageQueue 內部是透過native code實現主要機制 HandlerThread 同上方範例 但沒有handler public void download2(String url) &#123; HandlerThread ht = new HandlerThread("MyHandlerThread"); ht.start();//必須先啟動thread (執行prepare後looper才會建立) //直接指定Handler的looper Handler handler = new Handler(ht.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //H:MyHandlerThread System.out.println("H:"+Thread.currentThread().getName()); if (msg.obj=="quit") getLooper().quit(); &#125; &#125;; handler.post(new Runnable()&#123; public void run()&#123; //R:MyHandlerThread System.out.println("R:"+Thread.currentThread().getName()); &#125; &#125;); handler.obtainMessage(0, "url").sendToTarget(); handler.obtainMessage(0, "quit").sendToTarget();&#125; main thread預設已執行prepare 所以在main thread下Handler能直接使用]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[壓力循環測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMonkeyTest.html</url>
    <content type="text"><![CDATA[Android測試 adb (android debug bridge)Android SDK本地端執行程式 crash / anr(activity not responding) //列出deviceadb devices//進入手機shell (如果Permission denied可執行su)adb shell//到安裝路徑cd /data/data/com.jimliuxyz.vocabook.mock///安裝apkadb install package.apk//取得 device logadb logcat monkeyAndroid OS上的測試程式 monkey 自動壓力測試(隨機操作)//執行測試 (隨機點擊操作)adb shell monkey 100//執行100個操作 每1000ms執行一次 以50為操作seedadb shell monkey -p tw.com.langstar.t1 -v -s 50 --throttle 1000 100-v : detial info-s : seed操作種子 固定的種子能複製出同樣的操作行為--pct-touch : touch操作的百分比--ignore-crashes : crash後自動重啟再測試---//手機內存放anr的log目錄data/anr monkey 自訂測試腳本//Android SDK內建的UI元件檢視器 能查詢執行中的app/Users/jimliu/Library/Android/sdk/tools/bin/uiautomatorviewer//上傳檔案adb push myscript /data/local/tmp//執行測試 (隨機點擊操作)adb shell monkey -f /data/local/tmp/myscript 100 // 點擊DispatchPointer(downtime,eventide,press:0/release:1,x,y,pressure,size,metastate,xpresision,ypresision,device,edgeflags)DispatchPointer(10,10,0,100,100,1,1,-1,1,1,0,0)DispatchString(mystr)//manifest的activity須加exported="true"屬性LaunchActivity(package, package + ActivityName)UserWait(1000) //msDispatchPress(66) //keycode monkeyrunnerAndroid SDK本地端程式/Users/jimliu/Library/Android/sdk/tools/bin/monkeyrunner從本地端執行python控制測試流程 可抓圖 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#MonkeyRunner.alert("msg", "title", "okText")device = MonkeyRunner.waitForConnection(3, "emulator-5554")device.startActivity("package/package.activityname")MonkeyRunner.sleep(2)device.touch(100, 100, "DOWN_AND_UP")device.type("string")device.press("KEYCODE_ENTER", "DOWN_AND_UP")image = device.takeSnapshot()image.writeToFile("./test.png", "png") monkeyrunner demo.py]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShellCmd]]></title>
    <url>%2Fhome%2FLinux%2FSingle%2FShellCmd.html</url>
    <content type="text"><![CDATA[refref # 搜尋執行檔路徑 (依環境path)which gitwhereis git# 依檔名尋找檔案find / -name gitfind grep awk# 資料夾中搜尋文件內容grep -r '導航' ~/GoogleDrive/grep -r --include="*.java" "service" .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[頁面導航]]></title>
    <url>%2Fhome%2F%2FAndroid%2FNav.html</url>
    <content type="text"><![CDATA[task back stack行為設定參考官方中文說明Android 深入ActivityAndroid基礎知識 launchMode intent flag minifest activity Deep Link(App Links) 超連結啟動apprefref aad:Implement non-standard task stack navigation (deep links) &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;!--從adb啟動--&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!--從browser啟動--&gt; &lt;data android:scheme="app" android:host="jimliuxyz.com"&gt;&lt;/data&gt;&lt;/intent-filter&gt; adb shell am start -W -a android.intent.action.VIEW -d "app://jimliuxyz.com" com.jimliuxyz.tsnoteam : activity maneger-W : wait for launch to complete[-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;]package不一定要 如果要用override fun onNewIntent()處理 activity要為singleTop之類 TaskStackBuilderrefref 用於憑空建立parent activity於TaskStack中當MsgActivity是從其他app(intent或deep link)啟動時 並沒有自己的back stack 所以按下back按鈕時 無法回到MainActivity 此時就需要NavUtils工具 Minifest 指定android:parentActivityName為欲返回的MainActivity &lt;activity android:name="com.example.myfirstapp.MsgActivity" android:label="display_message" android:parentActivityName="com.example.myfirstapp.MainActivity" &gt; &lt;!-- Parent activity meta-data to support 4.0 and lower --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.myfirstapp.MainActivity" /&gt;&lt;/activity&gt; //通常都經由ActionBar左上角的箭頭驅動返回事件(android.R.id.home)getActionBar().setDisplayHomeAsUpEnabled(true); //測試不okIntent upIntent = NavUtils.getParentActivityIntent(this);if (NavUtils.shouldUpRecreateTask(this, upIntent)) &#123; //非處於自己app的back stack中時 TaskStackBuilder.create(this) .addNextIntentWithParentStack(upIntent) .startActivities();&#125; else NavUtils.navigateUpTo(this, upIntent); 透過PendingIntent預先設定好(測試ok)notify-user Intent intent = new Intent(this, MsgActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addNextIntentWithParentStack(intent); //依manifest設定的android:parentActivityNamepi = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); launchMode manifest可設定activity的android:launchMode standard : 不斷新建堆疊a - a&apos; - a&apos;&apos; singleTop : 同standard,但當該activity已處於stack top時不會再新建a - a - a - b - a&apos; - a&apos; singleTask : 不會重開,該activity出現時勢必將task中其他task全部拋掉a - a - b - c - d - a [back]離開app singleInstance : 不會新建,該activity的task僅允許自己使用a - a - a [back]離開a回到b b - [back]離開b回到home 簡述 standard - 不斷重開堆疊 : 預設 (可能有多個aty重複) singleTop - 頂端不新建 : 合理避免重複 (可能有多個aty重複) singleTask - 頂端排他 task pop all : Home singleInstance - 獨佔 : 供別的app使用 single指的是activity不新建 但會執行onNewIntent() taskAffinity allowTaskReparentingaffinity類似一個groupId的概念 activity預設的affinity為package name當一個activity以FLAG_ACTIVITY_NEW_TASK啟動時會以affinity去找該被加到哪個task中 FLAG_ACTIVITY透過intent開啟的activity該依循何策略進入task或操作stack FLAG_ACTIVITY_NEW_TASK(同singleTask) : aty會在自己的task中 new aty : 為aty新增tasknew aty : push進aty原屬的taskold aty : 顯示task但aty不會到top (怪怪的) FLAG_ACTIVITY_CLEAR_TOP : pop出原本在其上者 b是FLAG_ACTIVITY_CLEAR_TOPa - b - c - d - b (此時cd會被pop出,剩下ab) FLAG_ACTIVITY_BROUGHT_TO_FRONT : activity會to front FLAG_ACTIVITY_MULTIPLE_TASK : 能以另一個task啟動(act實體個別存在不同的task) FLAG_ACTIVITY_SINGLE_TOP(同singleTop) FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET與FLAG_ACTIVITY_RESET_TASK_IF_NEEDED : 1.設定清除點 2.pop掉清除點與之後的 還有很多…]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIntent.html</url>
    <content type="text"><![CDATA[概述 一個意圖/命令的容器putExtra僅能傳遞native type,或序列化物件(Serializable或Parcelable) 顯示 : 指定元件的類別 隱式 : 僅提供ACTION/CATEGORY/URI 不指定元件的類別 intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(file), "image/*");startActivity(intent);intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://..."));startActivity(intent); Intent導航與返航####導航 //啟動startActivity(intent)startActivityForResult(intent, req_id) //透過activity或fragment呼叫//被啟動override fun onCreate(savedInstanceState: Bundle?) //首次啟動override fun onNewIntent(intent: Intent?) //已啟動 但有新intent ####返航 setResult() //均透過activityoverride fun onActivityResult(int requestCode, int resultCode, Intent data) fragment有startActivityForResult與onActivityResult,但沒有setResult PendingIntent 封裝執行intent的機制 類似於將startActive/startService與intent封裝起來 丟給系統 透過系統機制讓user觸發intent此外尚有些flag策略 通常就是和Notification合用 Notification 位於手機上方的通知欄 可作為service的ui使其能顯示狀態與被使用者操作 //NotificationManagernm = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);//Intentintent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);//PendingIntentpi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);//NotificationCompat.Builderbuilder = new NotificationCompat.Builder(this, "practice_channel") .setSmallIcon(android.R.drawable.ic_dialog_info) .setContentTitle(getString(R.string.time_to_practice)) .setContentText(getString(R.string.it_is_time_to_practice)) .setAutoCancel(true) .setContentIntent(pi);//產生與取消nm.notify(NOTIFICATION_ID, builder.build());nm.cancel(NOTIFICATION_ID);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android CheatSheet]]></title>
    <url>%2Fhome%2F%2FAndroid%2FCheatSheet.html</url>
    <content type="text"><![CDATA[//下載圖片img = Drawable.createFromStream(new URL(url).openStream(), "");//顯示短暫訊息Toast.makeText(this, "...", Toast.LENGTH_SHORT).show();getResources().getStringArray(R....);getResources().getXml(R....); //XmlResourcesParsergetAssets().open("...")getSystemService(Service...)//URIMediaStore.Images.Media.INTERNAL_CONTENT_URI 查看activity back stackadb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' | sed -En -e '/com.jimliuxyz/p']]></content>
      <tags>
        <tag>Android</tag>
        <tag>Cheat Sheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[協助工具]]></title>
    <url>%2Fhome%2F%2FAndroid%2FHelpingTools.html</url>
    <content type="text"><![CDATA[uiautomatorviewer 檢視View階層 (方面找ID) cd ~/Library/Android/sdk/tools/bin/ uiautomatorviewer draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStackadb shell dumpsysadb shell dumpsys Android-Debug-Databaseref, 本地端連結 dependencies &#123; debugImplementation 'com.amitshekhar.android:debug-db:1.0.0'&#125; # Working with emulatorcd /Users/jimliu/Library/Android/sdk/platform-tools./adb forward tcp:8080 tcp:8080 LeakCanaryLeakCanary 檢測記憶體洩漏 (針對activity生命週期) dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'&#125; public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) return; LeakCanary.install(this); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功能測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTesting.html</url>
    <content type="text"><![CDATA[JUnit 僅於本地JVM上測試 又稱單元測試(函數功能測試) 不依靠android環境 以滑鼠右鍵選單”Go To&gt;Test”快速建立test class Annotation @Test 註解一函數為 測試使用 @Test(expected = Exception.class) 使符合預期時拋出異常 @Test(timeout=100) 指定測試需在100ms內完成 @Before 註解一函數為 每個測試函數執行要先執行的函數 @After 邏輯同上 @BeforeClass @AfterClass 邏輯同上 但僅為整個class執行一次 @Mock 宣告一個假物件 @Captor 宣告一個叫用參數捕捉器(以取得叫用參數) @Spy 監視一個真物件 @Rule 修飾TestRule Matchers 比對器 類似過濾行為 能以廣義的形容區別物件 eqis 是某個objectisA 是某個classnotanyInthasItem Assert 斷言結果 判斷值是否符合預期 若不符合斷言即為測試失敗 //斷言結果需為trueassertTrue("test failure", mockins.func() == 1);//斷言instance.func()執行回傳為1assertThat("test failure", mockins.func(), is(1)); //用Matcher判斷assertThat(mockins.getList(), not(hasItem(not_expected));//assertEquals mockito 製作假物件ref 通過製作假物件與指定其反應回傳 來驗證該假物件是否被呼叫?以何參數呼叫? 通常被測物需為真物件(因為要測試他的邏輯) 其依賴物為假物件(不著重邏輯是否正確或回傳什麼 僅著重是否被真物件正確叫用) //1. 產生mock物件@Mock MyClass mockIns; //不需要newMockitoAnnotations.initMocks(this); //但之後要做init使class內的@Mock生效//1. 產生mock物件LinkedList mockList = mock(LinkedList.class);LinkedList mockList = mock(LinkedList.class, Mockito.RETURNS_SMART_NULLS); //指定預設的回傳//2. 指定mock物件的反應 (此動作稱為Stubbing)when(mockList.get(0)).thenReturn("it's a mock string");when(mockList.get(1)).thenThrow(new RuntimeException());when(mockList.get(anyInt())).thenReturn("element");when(mockList.size()).thenReturn(1, 2, 3); //每次回傳都不同//doReturn, doThrow, doAnswer, doNothing, doCallRealMethoddoThrow(new RuntimeException()).when(mockList).clear();reset(mockList); //清除所有Stubbing//3. 經過某些動作操作後...即可進入驗證mockedList.add("once");//驗證1. 驗證mock物件的方法是否被呼叫(times, atLeast, atMost, atLeastOnce, never, timeout)verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); verify(mockedList).set(anyInt(), eq("element")); //用Matchers便於廣義的驗證//驗證2. 連帶驗證呼叫順序InOrder inOrder = inOrder(mockedList);inOrder.verify(mockedList).add("first");inOrder.verify(mockedList).add("second");//驗證3. 捕捉呼叫參數ArgumentCaptor&lt;String&gt; args = ArgumentCaptor.forClass(String.class);mockedList.add("John");verify(mockedList).add(args.capture()); //驗證add的叫用 同時捕捉叫用的參數assertEquals("John", args.getValue()); spy監視真物件List list = new LinkedList();List spy = spy(list);//之後spy即類似mockito的操作 TestRule 能在測試函數前後插入動作 例如偵測測試函數的執行時間 加入TestRule時需用@Rule註解才能與JUnit掛鉤 public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; //base : 一個能夠驅使測試函數被執行的物件 //description : 一個相關於測試函數環境的描述 return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; //即測試前 base.evaluate(); //即測試後 &#125; &#125;; &#125;&#125;@RuleMyRule rule = new MyRule() EspressoAndroid testing samples 依賴於JUnit的一個測試框架 UI測試 依靠android環境執行 針對view元件進行驗證 基本三步驟 取得view或data的互動 onView / onData 執行動作 perform 檢查驗證 check 大致動作//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); onView ViewInteraction onView(Matcher viewMatcher) 透過matcher取得view的控制 //Matcher&lt;View&gt;allOf 合併多個matcherwithIdwithTextisDisplayed//其父view的id為R.id.recyclerViewisDescendantOfA(withId(R.id.recyclerView))//其父view為ListView.classisDescendantOfA(isAssignableFrom(ListView.class))hasDescendanthasSibling perform ViewInteraction perform(final ViewAction… viewActions) 執行動作 //ViewActionclick()LongClick()clearText()replaceText("")typeText("")closeSoftKeyboard()//專為RecyclerView設計(actionOnItem)onView(allOf(withId(R.id.recyclerView))) .perform(actionOnItem(hasDescendant(withText("title")), click())); check ViewInteraction check(final ViewAssertion viewAssert) 斷言 //ViewAssertionmatches(isDisplayed()) //使用view matcher來斷言doesNotExist()isChecked() 其他pressBack() //按下返回鍵TestUtils.rotateXXX() //控制手機旋轉TestUtils.getCurrentActivity() TestUtils 一個工具類 提供靜態方法控制手機裝置 rotate / getCurrentActivity 自訂Matcher//一個回傳Matcher的functionprivate Matcher&lt;View&gt; withItemText(final String itemText) &#123; return new TypeSafeMatcher&lt;View&gt;() &#123; @Override public boolean matchesSafely(View item) &#123; return allOf( //其父view為ListView.class isDescendantOfA(isAssignableFrom(ListView.class)), //且text為itemText withText(itemText) ).matches(item); &#125; @Override public void describeTo(Description description) &#123; description.appendText("is isDescendantOfA LV with text " + itemText); &#125; &#125;; &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2Fhome%2F%2FAndroid%2FContentProvider.html</url>
    <content type="text"><![CDATA[Loader Fetch local data from disk using a Loader on a background thread Propagate data changes through a Loader to the UI refvideo 簡單理解為一個監聽器介面機制 很主要目的在實現LiveData(即時資料顯現)(ContentObserver) Activity重建時LoaderManager中已建立的Loader不需重建 能透過id續用 AsyncTaskLoader (abstract extends Loader) 分離IO與UI使用的執行緒 因為ContentProvider執行的thread是caller提供的 透過AsyncTaskLoader能讓caller處於非main thread 避免影響ui CursorLoader (extends AsyncTaskLoader) 建立cursor並透過cursor監聽uri是否被通知為變更 若是則Loader會叫用callback 使用loader//實作介面this implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;override fun onCreateLoader(id: Int, args: Bundle?): Loader&lt;Cursor&gt; &#123; //要求建立cursor (語句與用contentResolver.query建立時相同) return CursorLoader(this, URIContract.MyEntry.URI, arrayOf("_id", "value", "time"), null, null, null)&#125;override fun onLoadFinished(loader: Loader&lt;Cursor&gt;?, data: Cursor?) &#123; //loader建立完成 (cursor設定監聽的uri) data?.setNotificationUri(contentResolver, URIContract.MyEntry.URI) adapter!!.swapCursor(data)&#125;override fun onLoaderReset(loader: Loader&lt;Cursor&gt;?) &#123; //loader需被結束(釋放資源) adapter!!.swapCursor(null)&#125;//建立CursorAdapteradapter = SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, null, arrayOf("value"), intArrayOf(android.R.id.text1), 0)var lv = findViewById&lt;ListView&gt;(R.id.lv)lv.adapter = adapter//啟動loader (啟動後的實體manager自己會管理)loaderManager.initLoader(0, null, this) 自訂Loaderpublic class StringLoader extends AsyncTaskLoader&lt;String&gt; &#123; private String mCache; public StringLoader(Context context) &#123; super(context); &#125; @Override protected void onStartLoading() &#123; if (mCache != null) &#123; //跳過loadInBackground super.deliverResult(mCache); &#125; else &#123; //驅動loadInBackground與deliverResult達到資料更新 forceLoad(); &#125; &#125; @Override public void deliverResult(String data)&#123; mCache = data super.deliverResult() &#125; @Override public String loadInBackground() &#123; return "data"; &#125; @Override public void onReset()&#123; //結束該loader 釋放資源 super.onReset() &#125;&#125; ContentProviderrefref 行為 提供資料存取的獨立個體 應該是被動的存在 有權限的約束 Activity靠ContentResovler與ContentProvider聯繫 以uri指定資源的路徑 回傳Cursor給外部使用 MINE type 即 類型/子類型 (應用類型/文件類型) 例如 text/html ContentProvider的應用類型固定為cursor 文件類型可以自訂 "vnd.android.cursor.dir/multi" //multiple record"vnd.android.cursor.item/single" //single record uri ContentUris URI解析工具 //建立uriUri uri = Uri.parse("content://com.jxyz.provider/user") //添加iduri = ContentUris.withAppendedId(uri, 5); //取出idlong personid = ContentUris.parseId(uri); UriMatcher URI比對工具 matcher = new UriMatcher(NO_MATCH); //不匹配時回傳NO_MATCHmatcher.addURI("com.jxyz.provider", "user", USER); //匹配回傳URI_USERmatcher.addURI("...", "user/#", USER_ID); //# : intmatcher.addURI("...", "user/info/*", USER_NAME); //* : stringswitch(matcher.match(uri))&#123; case URI_USER: ...&#125; ContentObserver 監視uri對應內容的變化 //監聽uri變動contentResolver.registerContentObserver(uri, true, mContentObserver)//通知uri變動contentResolver.notifyChange(uri, null);//要求cursor監聽uri (使CursorLoader能自動更新)cursor.setNotificationUri(context.contentResolver, uri) 權限//宣告本app自訂的權限&lt;permission android:name="com.jxyz.provider.READ" android:protectionLevel="normal"/&gt;//provider就可用該權限指定需要受約束的元件&lt;providerandroid:name=".MyProvider"android:authorities="com.jxyz.provider"android:readPermission="com.jxyz.provider.READ"android:exported="true"&gt;&lt;/provider&gt;//其他app若要有該權限 則需如下宣告讓user同意該使用權限&lt;uses-permission android:name="com.jxyz.provider.READ"/&gt; public class MyProvider extends ContentProvider &#123; private Context mContext; DBHelper mDbHelper = null; SQLiteDatabase db = null; //Application.instance.packageName() + ".provider" public static final String AUTOHORITY = "com.jxyz.provider"; public static final int USER_CODE = 1; public static final int USERID_CODE = 1; private static final UriMatcher mMatcher; static&#123; mMatcher = new UriMatcher(UriMatcher.NO_MATCH); mMatcher.addURI(AUTOHORITY,"user", USER_CODE); mMatcher.addURI(AUTOHORITY,"user/#", USERID_CODE); &#125; @Override public boolean onCreate() &#123; mContext = getContext(); mDbHelper = new DBHelper(mContext); db = mDbHelper.getWritableDatabase(); //init mock db.execSQL("delete from user"); db.execSQL("insert into user values(1,'Carson');"); db.execSQL("insert into user values(2,'Kobe');"); return true; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; db.insert("user", null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; int code = mMatcher.match(uri); if (code == USERID_CODE)&#123; long userid = ContentUris.parseId(uri); &#125; //後續資料如需傳遞到ListView中 需有_id欄位 return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null); &#125; @Override public String getType(Uri uri) &#123; switch(mMatcher.match(uri))&#123; case USER_CODE: return "vnd.android.cursor.dir/multi"; case USERID_CODE: return "vnd.android.cursor.item/single"; &#125; return null; //封閉的app也可以直接回null &#125;&#125; 訪問ContentProviderContentResolver resolver = getContentResolver();//insertContentValues values = new ContentValues(); values.put("_id", 5); values.put("name", "allen");resolver.insert(uri, values);//queryCursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null);//updaterui = Uri.parse(uri + "/" + "7");int result = resolver.update(uri, values, null, null);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2Fhome%2F%2FAndroid%2FActivity.html</url>
    <content type="text"><![CDATA[Activity重建與復用ref 畫面旋轉 或 變更語系 造成Activity重建 連帶影響狀態或物件需要重建 Bundle與Map類似 但key必須是string 用來存放資料 1. Minifest.xml中抑制重建 在minifest加入android:configChanges提示為自行處理 使Activity不進行重建 //android:configChanges="locale|layoutDirection"@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig);&#125; 2. onRetainCustomNonConfigurationInstance 與 getLastCustomNonConfigurationInstance 複寫onRetain將稍後要還原內容交給系統 被重建後再取回 @Overridepublic Object onRetainCustomNonConfigurationInstance() &#123; return netWorkTask;&#125; 3. Retain Fragment (官方建議使用) 設定setRetainInstance(true)即可讓Fragment復用不重建(app狀態須寫在Fragment中) (之後需注意activity/context的更動) //以下code看似在復用MyFragment,但事實上MyFragment仍會在背景被建立//除非fragment設定setRetainInstance(true)if(getSupportFragmentManager().findFragmentByTag(ID) == null) &#123; getSupportFragmentManager().beginTransaction().add(new MyFragment(), ID).commit();&#125; View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 並非所有Android提供的View都實現了狀態儲存 目前測試也僅有EditText 幾種離開Activity的差異 狀況隨android會有所不同…隨機應變 關閉螢幕 與 切到別的app 一定會onSaveInstanceState 在stop中狀態中等待被恢復 暫時不會走onDestory() 恢復時會restart-&gt;start-&gt;resume 不會到restore(因為系統/UI狀態沒變) 螢幕翻轉 一定會onSaveInstanceState activity走向onDestory() 之後隨即再重建Activity 可在create與restore取得舊有狀態 透過back按鍵離開 或 呼叫finish() 離開時不會跑onSaveInstanceState 故既有的狀態復原路徑是無效的 activity走向onDestory() 但app仍保留在stack中 故app中的static或無法被回收的物件仍然進行中 (也能在之後復用) 直接在task中滑掉 或按x關掉 app完全關閉 所有app資源執行緒都將被關閉回收 連activity的onDestory()都不會被呼叫 app迅雷不及掩耳的被刪除 程式中無從得知正要被kill的事件 以保持app是隨時可以被kill的狀態 善用onStop()與適時建立Service 總結 不走onDestory表示稍後就可能被點選恢復 螢幕翻轉或語系改變之類因牽涉整體UI固有重建的需求 App半關 : 即所有Activity都被結束(不跑save state) 僅留static或thread運作 App全關 : 整個App全部強制結束]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view 與 Style]]></title>
    <url>%2Fhome%2F%2FAndroid%2FViewNStyle.html</url>
    <content type="text"><![CDATA[/Users/jimliu/Library/Android/sdk/platforms/android-26/data/res/values/styles.xml 容器類型的view ListView : 列表顯示 RecyclerView : 列表顯示 更為靈活 取代ListView ScrollView : 可滑動的顯示 gridview / gallery / cardview LayoutInflater layout的實體化工具 將layout resource轉成view的實例 Adapter 設計模式中稱作”適配器” 簡單的說就是轉換器 以view容器的應用來說 就是將’資料數據’轉換填充到’ListView裡的各個item view’上 //以simple_list_item_1做為item viewadp = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1);//替adp添加兩筆資料adp.add("first");adp.add("second");//將adp指定給listview使用lv = findViewById(R.id.listView);lv.setAdapter(adp); BaseAdapter@Overridepublic View getView(int pos, View convertView, ViewGroup parent)&#123; //getView用於取得item view //convertView : 先前已建立的view,用於優化效能&#125;notifyDataSetChanged(); //向view通知data有變動 view才會refresh ViewHolder 主要用意在復用item view時避免重複findViewByIdv.setTag(holder);holder = (Holder) v.getTag();//RecyclerView.Adapter不用這樣寫 SurfaceView 有自己的ui thread 用於較佔時間繪圖應用 (VideoView/ImageView) View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 自定義View / ViewGroupref 先分清元件與佈局的角色 大致 需要複寫onMeasure (父要求子做元件尺寸測量measureChildren) (子則量測自己) 量測完執行setMeasuredDimension ViewGroup需複寫 onLayout (排定子的繪出位置) 逐個叫用child.layout View需複寫 onDraw (繪製本身) MeasureSpec定義 為一整數 前3bit做為mode 之後作為size(寬或高) 做為父要求子做尺寸量測時的參考 (由父提供spec 子做量測) UNSPECIFIED : 沒有任何約束 EXACTLY : 約束明確的size AT_MOST : 約束上限的size LayoutParams 一個ViewGroup要遍歷所有子View的LayoutParams才知道每個子View要求被如何佈局 (所以是ViewGroup定義的 但由子View描述給其ViewGroup參照的) child.getLayoutParams Theme與Style aad:Construct a layout using XML or Java code aad:Create a custom view class and add it to a layout aad:Implement a custom application theme aad:Apply a custom style to a group of common widgets 兩者僅有使用廣度上的差別 theme針對app或activity, style針對元件, 基本上都是style 單位 dp : 1dp=160ppi的px長度 (像素隨密度改變)sp : 類似dp 用於文字pt : 點 用於文字px : 像素ppi, dpi : 像素密度 pixel per inch 每英寸像素數mm : 毫米in : 英吋 attr宣告 寫在values/attrs.xml 作為元件的屬性 (元件屬性是從xml建立的 java code僅是依資源ID取值賦予元件) attr及所有資源都會自動產生於R類中的id &lt;attr name ="mycolor" format= "color" /&gt; 屬性名稱一多容易重複混淆 用declare-styleable可將其分類 java code也會比較好讀取 //將多個attr並於declare-styleable有利組織化與讀取 在R類中會是一個resId的陣列&lt;declare-styleable name="MyStyle"&gt; &lt;attr name ="mycolor" format= "color" /&gt;&lt;declare-styleable&gt; attr的賦值//在元件標籤中賦值 (前半部需指定命名空間)&lt;TextView app: mycolor="#00ff00" android:style="@style/MyStyle"&gt;&lt;/TextView&gt; //在style/theme中賦值&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="mycolor"&gt;#0037ff&lt;/item&gt; &lt;item name="android:textViewStyle"&gt;@style/textviewstyle&lt;/item&gt;&lt;/style&gt; 元件取得attr的來源 一個元件的一個attr可能有多個來源 (大致的優先順序) 於元件標籤中或標籤中指定的style有描述 從application或activity指定的theme中有描述 theme中指定的style有描述 (即指android:textViewStyle)(format=”reference”) 元件hardcode裡有預設的style 元件取得attr obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) AttributeSet 即元件標籤中的描述 attrs 欲取得的attr defStyleAttr 預設的style的attr (在theme中經由該attr參考到確切的style)(即指android:textViewStyle) 透過這樣的機制就可在theme中複寫掉元件的整個style defStyleRes 預設的style 若沒有可丟0 public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0); TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.MyStyle, defStyleAttr, defStyleRes); int color = a.getColor(R.styleable.MyStyle_mycolor, Color.BLACK); a. recycle();&#125; 可見性的設定View.visableView.invisable : 看不見 但仍佔位置View.gone : 消失 不佔位置 模糊視窗(blur)getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND); ViewStub一個空的view 用來延遲載入另一個view時當作佔位用 SpannableString v.setText()通常傳入字串 更複雜可以傳入(html, img_getter, tag_handler) 另一種是傳入SpannableString 用途都是達到圖文混排 其他onTouch 和 onTouchEvent onTouch優先於onTouchEvent 若onTouch回傳true則事件就不會再往下傳播onTouch是作用於view處於enable狀態下]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Accessibility]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAccessibility.html</url>
    <content type="text"><![CDATA[Accessibility 無障礙能力官方EventAccessibilityServiceAccessibilityEventAccessibilityService aad:Apply content descriptions to views for accessibility aad:Add accessibility hooks to a custom view 自訂View時需要sendAccessibilityEvent 否則只要注意contentDescription focusable nextFocus]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android環境概念]]></title>
    <url>%2Fhome%2F%2FAndroid%2Fbasic.html</url>
    <content type="text"><![CDATA[編譯流程 Dalvik : Android的JVM dex : 類似jar appt：Android Asset Packaging Tool MinifestMinifest-activity參數 Contextref context可理解為app的執行環境 (包含狀態與工具) ContextWrapper會包含一個Context實例(mBase)達到複製Context Application與Activity與Service雖都能當context用(但非對應同一個mBase) 要注意Activity與Service是有被回收的可能 避免將其當context傳遞 但某些關聯性的動作只能使用activity(像是show dialog) //若context的傳遞會被對方持有時 盡可能使用Application的contextcontext.getApplicationContext() Application 繼承Context 可以理解為另外一個層級的執行環境透過Manifest指定自訂的Application類 &lt;!--Manifest--&gt;&lt;application android:name=".CustomApplication"&gt; SharedPreferencekey/value pair的儲存器 用於儲存app的設定值 MODE_MULTI_PROCESSMODE_PRIVATEsp = PreferenceManager.getDefaultSharedPreferences(context);sp = getSharedPreferences("mysp", Context. MODE_PRIVATE);sp.getBoolean("key", false);sp.edit().putBoolean("key", false);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fhome%2F%2Fgit%2FGit.html</url>
    <content type="text"><![CDATA[working space : 工作區 即源碼開發的目錄 commit history(repo) : 即提交歷史紀錄區 stage(index) : 緩存區 介於工作區與歷史區之間 add進了stage之後commit才會進repo 而不是讓工作區所有檔案都進repo patch : 即commit產生的紀錄點 master : git最初預設的分支 origin : 慣用的預設的遠端別名 用來表示某一個遠端的路徑 HEAD : 指向當下所處的base patch (可以用@符號) HEAD^ : 指HEAD的前一個patch 等同HEAD~或HEAD~1 HEAD@{2} : 歷史紀錄(reflog)的指向簡寫 detached HEAD : 脫離的HEAD(斷頭) 即HEAD未處於分支的末端(git checkout HEAD^) 之後若再建新的patch將難以合併回分支 ORIG_HEAD : 當merge或rebase時會留下的一個記錄點 用於合併出錯時的返回點 參考文章git reflog 查詢# 列出設定git config -lgit config --global -l# 查訊patchgit show HEADgit log --oneline # 當下repo版本的歷史git reflog # 所有操作歷史 (不會進遠端)# 比對git diff # 比對工作區not staged的檔案git diff --cached # 比對工作區與repogit statusgit branch 程式碼還原ref還原前須注意當下工作區與緩存區是否有工作尚未commit 可以先commit或stash做暫存patch checkout 切換patch(branch) 直接影響working space/stage/repo 在任何動前 最好都先知道自己在哪個branch下作業 或直接用checkout確保一定在某個branch下可針對個別檔案還原 resetref 重置回某patch版本可針對個別檔案還原 commit流程 : 修改檔案 -&gt; add進stage -&gt; commit進reporeset流程 : (hard)還原檔案 &lt;- (mixed)stage重置回未add &lt;- (soft)repo重置回某版本 將HEAD移到某patch(即變更repo的版本) 且之後的patch將於數十天後被GC刪除 reset的所有操作都被記錄在reflog中 最算reset沒有起任何作用 最好只在私有的本地分支進行 不要影響到遠端及其他開發者的base 模式 soft : 保留當下的stage與working space mixed(預設) : 保留當下的working space 但stage退回(如同未add) hard : 完全重置 revert 將某個patch逆向重做後當成一個新的patch 如同撤銷某個patch 雖會多一個patch但不會影響既有的history 暫存patch當工作到一半若要切換到其他patch或branch 但又不想commit當下的修改時 可以此法暫存之後再取回 stash 將工作區與緩存區暫存起來 再硬重置回HEADpop動作如同cherry-pick也會有conflict 所以要先回到正確的patch再popgit stash # 暫存git stash save "mywork" # 給定暫存訊息 git stash listgit stash pop stash@&#123;1&#125; # pop出來後就移出list了 合併ref首先要切到要進行合併的分支 cherry-pick 將其他分支中想要的patch複製成新的patch加到當下分支 rebase 將該分支的起點(交叉點)換到新的patch或branch (以cherry-pick實現)達人推薦的合併方式 merge –no-ff 將兩個分支合併產生一個merge patch被併的分支仍能保留末端節點 Fast-Forward指合併的兩個分支原本就重疊在一起 此時合併不需產生merge patch (就看不出分支的起點了) # rebase或merge出錯時 可以此返回合併前狀態git reset --hard ORIG_HEAD 解衝突ref # 完成解衝突git cherry-pick --continue# 取消pickgit cherry-pick --abort 同步遠端分支要push前或每日工作前先pull確保本地端base與遠端相同 一方面及時察覺新版本的變動 二方面確保push時順利 fetch 下載 pull 下載並merge pull –rebase 下載並以rebase合併]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安裝紀錄]]></title>
    <url>%2Fhome%2F%E7%B4%80%E9%8C%84%2FSingle%2FHexo%E5%AE%89%E8%A3%9D%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[Hexo 、NexT 站內連結若用相對連結在首頁跟文章內顯示的連結路徑不同 UTF-8編碼中若參雜其他編碼會讓search.xml錯誤而無法搜索 md檔案若有尖括號未置入code tag 可能造成解析錯誤 目標本地端透過Hexo建立網站骨架 並將markdown文章轉為html 上傳到github做為blog網站 安裝node.js node.js為一本地端的js執行平台 用途廣泛 npm (安裝node.js時會一並安裝) 一個套件管理系統 能透過命令列安裝套件 安裝git 版本控管工具 做為本地端工具與github連結 github 一個線上的版本控管工具 其附加功能使其能成為http伺服器其Repo需命名為”ACCOUNT_NAME.github.io” #安裝hexo命令列工具npm install -g hexo-cli#在該目錄建立blog目錄hexo init blog#安裝node.js環境cd blognpm install#發佈到github的工具npm install hexo-deployer-git --save#使網頁能即時自動更新的工具(會造成一些問題 1.網頁空白 2.搜尋失效)(查問題時最好移除)npm install hexo-browsersync --save#下載慣用的blog主題佈局(NexT)git clone https://github.com/iissnan/hexo-theme-next themes/next#站內搜尋工具 (:category開頭會無法連結)npm install hexo-generator-searchdb --save 常規操作#新增文章hexo new "My New Post"#啟動本地端serverhexo server#產生文件hexo g --watch#上傳到githubhexo d 語法測試12345 1 2 測試 測試 測試 AB aaa bbb]]></content>
      <categories>
        <category>紀錄</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知識樹]]></title>
    <url>%2Fhome%2F%2FAndroid%2F00.index.html</url>
    <content type="text"><![CDATA[開發紀錄 Cheat Sheet 入門知識IDE編譯流程GradleAndroidManifest.xml 供Android系統得知此app包含的組件內容與設定 class Context 可視為app執行環境(上下文) 許多操作都是需要有執行環境才能完成Application/Activity/Service都有各自的Context 但生命週期不同 class Application 做為app的single instance 相當於app的母生命週期 SharedPreferenceProcess 一段已載入記憶體執行的程式碼 例如一個執行中的app就是一個process Thread 實質執行程式碼的單元app中起始的thread稱為main thread又稱為ui thread 其最主要的工作為在每個16ms繪製一次畫面 若沒辦法如期執行就會造成畫面lag ResourceIntent每個app都是獨立的process 無法直接互動 Intent則做為之間互動的意圖/訊息內容. 透過intent描述欲執行的動作 交由android系統執行. 通常執行動作都是啟動某個app或service. PendingIntent PendingIntent會持有一個intent 交給android系統保留 如同委託系統代為於特定時機執行 (此時intent的執行與否已與建立該intent的app無關了) IntentFilter 對於能被intent啟動的對象來說(例如Service) 需要過濾不相干的意圖 (即需預先描述相關的意圖於Filter中) Notification 位於手機上方的通知欄 四大組件即Activity/Service/ContentProvider/Broadcast 這些組件的共通點就是能被別的app透過intent啟動或間接存取 四大組件生命週期互不相同 但都是經由系統實例化誕生 或依系統機制結束 我們僅能發送intent告知意圖 Activity可視為一個頁面的持有者 Activity重建與復用 Activity常有機會被系統重建 例如螢幕翻轉或語系更動 重建後可能造成狀態的喪失 Activity導航Deep Link 使app能透過超連結方式被開啟 TaskStack 相關於頁面的堆疊 即上一頁的功能 launchMode 指定TaskStack堆疊的策略 FLAG_ACTIVITY 用Intent開啟Activity的堆疊策略 Service可視為一個服務 服務能提供給自己或別的app 或常態的在背景默默執行Service衍生出了許多不同的類別 用以達到特定的需求 IntentService Service執行於main thread 但IntentService會切到worker thread佇列執行 JobService 與 JobScheduler 能依系統狀態約定任務的執行 例如有網路時才執行 使更有效率的驅動任務 節約電力 ContentProvider可視為一個資料提供者 提供資料給自己或別的app 透過特定的uri即可存取特定的ContentProvider 例如’電話簿聯絡人’等資訊就是透過ContentProvider運作 Cursor 可以理解為資料指針 其持有一群資料 透過指定cursor的位置即可取得某一筆資料 CursorLoaderBroadcast發送或接收廣播 例如系統電力不足時會發送廣播給有註冊的接收器 Fragment可視為一個頁面中的一小部分的持有者 用意在將整個頁面拆散 其生命週期基本上是依附Activity上 或由FragmentManager管理 Database MySQLAndroid內建的Database Thread / Task為了順利與容易的協調各式工作 各種衍生的類別孕育而生 Handler 一個透過當下執行緒建立的message handler 其目的在使工作能透過該執行緒佇列的被執行 可以作為執行時切換執行緒的手段 或當佇列安插異步工作於執行緒 Looper 一個透過當下執行緒建立的訊息接收器 其內部包含一個message queue 是促成Handler運作的背後推手 AsyncTask 建立一個異步工作 執行於worker thread 且提供機制與main thread互動 AlarmManager 安排定時任務(如鬧鐘般) 用PendingIntent設定 時間到開啟Activity或Service能夠喚醒Android系統 RecyclerViewView &amp; StyleLayoutWidget app widget 手機HomeScreen上的小工具 TestingJUnit Espresso Monkey 壓力循環測試 3rd Party LibraryDagger 依賴注入工具 何謂依賴? A物件需要B物件才能運作 B即為A的依賴物 將依賴物帶進A的實現方式即稱為依賴注入將各個物件實體的建立或獲取寫成函數方法 Dagger會建立其之間的依賴關係 並將依賴注入到物件中 RxJava ReactiveX 響應式編程 將數據流轉化為事件觸發 例如[1,2,3]會分別產生3個事件流之間可經由運算符號(即鏈式函數)加工產生新的流 Gson Json文件的解析 工具uiautomatorviewer 檢視View階層 (方面找ID) draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStack adb shell dumpsys Android-Debug-Database mysql網頁伺服器介面 LeakCanary 記憶體洩漏偵測 其他LruCache 快取 當空間吃緊時能首先移除掉近期最少使用的(Least recent used)三級快取(緩存)策略 即 記憶體中快取-&gt;本地端資料-&gt;網路資料 依其優先順序取得資料 以得到最快速度 Accessibility 輔助殘疾人士 使其便於操作app Animation 動畫 序列化Serializable / ParcelableSerializable 對於javaBean類只要implements Serializable 不用額外實現方法即可對primitive type序列化 特殊物件則須額外實現用反射實現 所以速度慢 Parcelable 要有一個名為CREATOR的靜態變數實現Creator 用以從序列還原物件要實現writeToParcel與createFromParcel (寫讀順序要對應)因為hard coding所以速度快 StorageRoom MySql的另一種操作方式 ArchitectureComponent LifeCycle與Observable的整合 使其產生LiveData 套用MVVM架構 debug過程 操作內建的debug工具 懸浮視窗ref 即將view依LayoutParams加到WindowManager做為remote view處理 inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);removeView = (RelativeLayout)inflater.inflate(R.layout.remove, null);windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);windowManager.addView(removeView, layoutParam); 雜項]]></content>
      <tags>
        <tag>Android</tag>
        <tag>知識樹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2Fhome%2F%2FAndroid%2FService.html</url>
    <content type="text"><![CDATA[Service app透過startService啟動service 執行於UI Thread 不會自動被系統結束 只能自己透過stopSelf結束 onStartCommand的回傳決定Service被系統殺掉後的行為 START_STICKY : Service被殺掉, 系統會重啟, 但是Intent會是null。 START_NOT_STICKY : Service被系統殺掉, 不會重啟。 START_REDELIVER_INTENT : Service被系統殺掉, 重啟且Intent會重傳。 Remote Service 同為Service僅是啟動/取得方式不同 主要用於跨process的應用 即透過bindService(intent, conn, BIND_AUTO_CREATE)取得binder實例操控service 以bindService啟動service會造成Service綁定於App的生命週期 用AIDL建立共通介面 內建已經做好了一個共通的binder 可以透過(Message(msg)).getBinder()建立 基本上是用handler處理message的方式傳遞訊息 (就不用建AIDL了) android:process屬性 : 可讓Service執行於自有的process上(remote service) 通常會設為:remote(這似乎屬於一個自訂的命名) Binder 在android中做process間通訊用 (底層機制應該是linux的share memory) AIDLref Android Interface Definition Language一種程式語言 用於定義介面 用於IPC(Process間通信) 與java的interface寫法類似 //IRemoteService.aidlpackage com.example.service;interface IRemoteService&#123; int getData(String key)&#125; 存成MyDataBinder.aidl,會被自動轉譯產生一個java檔,產生IRemoteService.Stub類別,作為server與client間共通的介面 server端實做IRemoteService.Stub的method即IBinder 並在onBind時回傳 client端也必須有該.aidl檔才能編譯 並透過IRemoteService.Stub.asInterface將IBinder轉為代理物件供使用 Remote Service範例實做介面//RemoteService.javapublic class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getData()&#123; return "hello"; &#125; &#125;;&#125; start service &amp; bind//Activity.java&#123; Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125;IRemoteService mIRemoteService;ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; public void onServiceDisconnected(ComponentName className) &#123; mIRemoteService = null; &#125;&#125;; IntentService Service的子類 需在manifest中宣告 Service+Handler+Looper的封裝 即類似一個task queue 當所有任務執行完時銷毀 有任務再重新建立 public class IntentServiceDemo extends IntentService&#123; public IntentServiceDemo(String name)&#123; //name for HandlerThread super(name); &#125; @Override protected void onHandleIntent(Intent intent)&#123; //進入異步 &#125;&#125;Intent intent = new Intent(this, IntentServiceDemo.class);startService(intent); JobService / JobSchedulerrefandroid-JobScheduler aad:Schedule a background task using JobScheduler Service的子類 排程不緊急或與設備狀態有關的任務(受系統牽制) 以優化系統電力消耗 在(&gt;=Build.VERSION_CODES.N)中限制了interval最小為15m flex最小為5m 比較適合惰性的任務 (時間不會準確) JobScheduler : 整個app僅有一個JobScheduler實體用來排程任務(丟入JobInfo) ComponentName : 一個pkg+cls用以描述元件 Component泛指四大組件 常用於Intent JobInfo : 指定任務執行模式 依時間/網路/Idel/充電 (透過Builder模式構建) 儲存extras當param給JobService執行 JobService : 當onStartJob時得到任務 回傳false表示任務已執行結束 回傳true表示任務進入異步執行 完成後須自行呼叫jobFinished 意象: JobService如同Service般執行 經由JobInfo建立不同任務的參數 由JobScheduler指派執行時機 呼叫JobService.onStartJob執行 執行於ui thread,耗時任務仍需另使用AsyncTask &lt;service android:name=".service.MyJobService" android:permission="android.permission.BIND_JOB_SERVICE" android:exported="true"/&gt; JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); onStopJob僅在系統強制要停止任務時呼叫 AlarmManagerref aad:Schedule a time-sensitive task using alarms 安排定時任務(time-sensitive task) 時間到用PendingIntent開啟服務或Activity 比起Java SE的Timer, AlarmManager能夠喚醒休眠的Android系統(透過PendingIntent) 被限制了interval最小為60s (時間不會準確) val intent = Intent(this, AlarmReceiver::class.java)val pi = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);val am = getSystemService(Context.ALARM_SERVICE) as AlarmManageram.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi)am.setRepeating(RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, pi);am.setRepeating(ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 1000 , 5 * 1000 , pi);class AlarmReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; &#125;&#125; &lt;receiver android:name=".AlarmReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; type(組合) RTC : 以系統時間判斷 (也就是說系統時間更改將立即反應到鬧鐘上) ELAPSED_REALTIME : 以系統流逝的時間差判斷 WAKEUP : 能於睡眠中喚醒 POWER_OFF_WAKEUP : 能於關機中喚醒]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fhome%2F%2Fgit%2Fgit_.html</url>
    <content type="text"><![CDATA[***Git的好習慣 Git版本控制视频教程 SVN(subversion) 與 Gitcvs 集中式 svn 集中式: 所有版本都在svn server上,client端僅存有某一特定版本,所以版本切換時很慢 server一掛就全部死光. 紀錄diff patch,每個版本透過patch還原,所以換版本時也很慢. git 分散式 本地端含有所有版本,遠端僅進行與各個用戶端同步. 紀錄個別檔案 使用ssh連結遠端git//產生公私鑰ssh-keygen -t rsa -b 4096 -C jimliuxyz@gmail.com//將pub key貼到gitbut網站的setting&gt;SSH keys&gt;new key//針對目錄設定就不要加globalgit config --global user.name jimliuxyzgit config --global user.email jimliuxyz@gmail.comgit config --listgit remote add origin https://github.com/jimliuxyz/wovo.git ssh機制與私人repo較有關聯ssh config 常用指令常用指令 //取得remote repo變數設定git remote -v//取得所有branch與當下使用的branch (與本地追蹤狀況)git branch -a//取得遠端分支資訊git ls-remote//取得當下branch名稱與其版本狀態git status //測試git clone ... //會自建一個目錄touch file.txtecho 123 &gt;&gt; file.txtgit add file.txtgit commit -a -m comment...git push //建立project (wovo)git initgit add &lt;...&gt;git commit -m "first commit"//建立origin(remote repo var)並對應到remote url//origin是慣用預設對remote repo的命名git remote add origin https://github.com/jimliuxyz/wovo.git//將本地版本推送到 origin/master (remote repo/branch)//master是慣用預設對主要branch的命名//-u | --set-upstream設定master的remote repo是origingit push -u origin master //建立新分支newfeature,從master分出git branch newfeature master//切換分支git checkout newfeature//推送分支到remotegit push -u origin newfeature//之後的push動作git push origin//本地端分支:遠端分支git push -u origin master:master //更新local repo,但不合併git fetch//合併git merge origin/master// (fetch + merge)git pull 初建立rm -rf .gitgit init//重新commitgit commit -a -m "first commmit"//增加遠端origin路徑git remote add origin https://github.com/jimliuxyz/...//push到遠端origingit push -u origin master 參數-u設定本地端master追蹤遠端origin/master,設定一次後以後可以直接使用git push上傳 標籤感覺標籤像一個release的紀錄點,至少在github上確實會產生release的內容 git tag -a 1.0 -m &quot;first release&quot;git push origin 1.0]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
