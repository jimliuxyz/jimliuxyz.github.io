<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Broadcast]]></title>
    <url>%2F%2FAndroid%2FChapter%2FBroadcast%2F</url>
    <content type="text"><![CDATA[Broadcast 發送或接收系統事件廣播 如低電量/簡訊生命週期在onReceive()結束後終止以靜態方式(manifest)註冊接收器 可以不用開app 也能接收事件 registerReceiver(new BroadcastReceiver()&#123;&#125;, new IntentFilter("action..."));unregisterReceiver(mybc);Intent intent = new Intent(this, MyBC.class)Intent intent = new Intent("action...")intent.putExtra("data", "mydata");sendBroiadcast(intent);class MyReceiver extends BroadcastReceiver&#123; onReceive(content, intent);&#125; 或以常駐的方式(不論app是否啟動或kill都能被執行) &lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.EDIT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Dev Log]]></title>
    <url>%2F%2FAndroid%2FChapter%2FDevLog%2F</url>
    <content type="text"><![CDATA[TextView行高在編輯文字時會改變addTextChangedListener(object:TextWatcher&#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; //每次文字更動時都在設定一次行高 setLineSpacing(0f, 1f) setLineSpacing(20f, 1f) &#125;&#125;)]]></content>
      <tags>
        <tag>開發紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2F%2FAndroid%2FChapter%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[加入RecyclerView//0. 取得viewvar view = findViewById&lt;RecyclerView&gt;(R.id.recyclerView)//1. 設定layoutval layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)view.layoutManager = layoutManager//2. 設定adapterview.adapter = MyAdapter(data)//3. 設定分隔線view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); class MyAdapter : RecyclerView.Adapter() &#123; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; //建立ItemView並存於ViewHolder回傳 &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; //將欲顯示的內容抽換到holder中的view &#125; override fun getItemCount(): Int &#123; &#125; //自訂ItemView的Holder class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2F%2FAndroid%2FChapter%2FFragment%2F</url>
    <content type="text"><![CDATA[加入Fragment fragment要被砍入的位置 R.id.contentFrame fragment自身的佈局 R.layout.main_frag var fragment = supportFragmentManager.findFragmentById(R.id.contentFrame)?:MainFragment().also &#123; supportFragmentManager.beginTransaction().apply &#123; add(R.id.contentFrame, it) commit() &#125;&#125; class MainFragment : Fragment()&#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; var view = inflater?.inflate(R.layout.main_frag, container, false) return view &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2F%2FAndroid%2FChapter%2FGradle%2F</url>
    <content type="text"><![CDATA[Groovy 語言特性介紹 加快編譯//gradle.propertiesorg.gradle.jvmargs=-Xmx512morg.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.configureondemand=true 異常”Gradle project sync failed”在android sample中加入kotlin一直不成功 但new project中卻沒問題 把code移入new project中確認也沒問題 可見是環境造成 rm -rf .gradle/ .idea/ build gradle 最後是把src root folder從Application改名(Refacotr)為app才正常 buildTypes 控制編譯流程 debug / release productFlavors 分歧編譯目錄 mock / prod 不同選擇即用不同目錄下的檔案編譯 flavorDimensions : 對flavor再進行一次分類 例如platform,vertype 組合出多個目錄 BuildConfig設定會透過BuildConfig類帶入java中 applicationId作用在google play store上 用以辨識app, 不同的release要有不同的applicationId, 否則會被視為同一個app 可寫在defaultConfig或個別的buildType/productFlavors中 也可用applicationIdSuffix]]></content>
  </entry>
  <entry>
    <title><![CDATA[IDE_ENV]]></title>
    <url>%2F%2FAndroid%2FChapter%2FIDE-ENV%2F</url>
    <content type="text"><![CDATA[API版本 SDK TOOL路徑cd ~/Library/Android/sdk/tools/bin/ export JAVA_HOME=`/usr/libexec/java_home -v 1.8`export SDK_HOME=/Users/jimliu/Library/Android/sdkexport ANDROID_HOME=/Users/jimliu/Library/Android/sdkexport GRADLE_HOME=/Applications/Android\ Studio.app/Contents/gradle/gradle-3.2/export PATH=$JAVA_HOME/bin:$&#123;SDK_HOME&#125;/tools/bin:$&#123;SDK_HOME&#125;/platform-tools:$GRADLE_HOME/bin:$PATH cat &gt; ~/.bash_profile貼上之後ctrl+c 添加Library Adding a Library Project Adding a Jar library 快速鍵//自動完成不分大小寫editor&gt;general&gt;code completion的case sensitive completion要調為none//自加cmd IKJL : 上下左右cmd+sft J/L : to line start/endcmd+sft I/K : extend/shrink selectioncmd p : parameter infocmd ;或z : Basic/ in Code Completion 函數自動完成 (api doc)cmd , : insert live template 插入樣板//mousecmd click : Declaration/ in Main menu Naviagte 查原始碼 (或xml)//視窗檔案切換ctrl tab//游標opt 左右 : 左右移 擴大/縮小選取sft opt : 上/下移動行sft enter : end + entercmd enter : enter + 上 (游標位置不動產生一空行)//快速產生程式碼 souf fori logi cmd j : 插入樣板cmd opt t : if / try / while//開啟燈泡內的選項opt enter//查詢物件的method/field 或任何可能的字串ctrl space : 查詢method/field (選定後按tab!!!!) 或 提示字串自動完成//建立methodcmd n : 各式選單ctrl o : select override/implement//單純查詢ctrl j : 查詢文件定義cmd p : 顯示參數定義 ****cmd b : 查原始碼 (或xml)cmd u : 跳到父類cmd opt L : 自動格式化cmd F9 : 編譯執行//搜尋內容或檔案sft sftsft F6 : 變數改名cmd + d : 複製貼上一整行 或貼上已選取的內容cmd sft a : 開啟系統功能搜索]]></content>
  </entry>
  <entry>
    <title><![CDATA[Resource]]></title>
    <url>%2F%2FAndroid%2FChapter%2FResource%2F</url>
    <content type="text"><![CDATA[資源引用出現的樣式[@|?][namespace:]type/name//type : string，dimen，drawable，layout，color，anim，animator，mipmap，raw，id，style，attr，array//@ : 引用切確資源@android:string/title //Android本身的資源@string/title //省略namespace即引用自建資源//? : 引用自主題屬性 (如果主題沒定義該屬性會報InflateException)android:background="?attr/colorPrimary"//+ : 通常是替自己建立資源設定ID時使用android:id="@+id/myViewId"//@null : 應該是一個特別的id 讓某些屬性能夠不執行android:button="@null"android:background="@null" assets與raw assets不會產生id於R資源 可有目錄結構 透過AssetManager讀取 raw屬於R資源 透過R.id讀取 AssetManager am = getAssets(); InputStream is = am.open("filename"); InputStream is = getResources().openRawResource(R.id.fileNameID);VideoView.setVideoUri(Uri.parse("android.resource://" + getpackageName() + "/" + R.raw.movie)); 多國語言只需透過IDE編輯即可 (勾選不需要翻譯的字串) Drawable 可被畫出在View上的 例如圖檔來源 from BitmapDrawable 也可從xml定義 color shape : 形狀 方圓線等 stroke 描邊 solid 填充 corners 邊角 padding selector : 狀態 每個item搭配一個狀態對應一個drawable state_pressed / state_focused / state_selected / state_checkable state_checked/ state_enabled / state_activated / state_hovered state_window_focused layer-list : 圖層 越先執行的在越底層 用很多層疊出一個drawable]]></content>
  </entry>
  <entry>
    <title><![CDATA[Storage]]></title>
    <url>%2F%2FAndroid%2FChapter%2FStorage%2F</url>
    <content type="text"><![CDATA[Storage internal與external是以app間分享的角度,external表示可被分享 無論internal或external 在app移除都會跟著移除 除非用是PublicDirectory internal /data/data/ 被連結到(/data/user/...) 一定存在 別的app不能訪問 用Context.filesDir取得 primary external /Android/data/PACKAGE_NAME 被連結到(/storage/emulated/...) 可能是內部記憶體卡的分割或外部記憶裝置(Adoptable Storage) 用Context.getExternalFilesDir取得 secondary external 外部記憶裝置 不一定存在 //Context.filesDir (/data/data的連結) /data/user/0/PACKAGENAME/files//Context.getExternalFilesDir /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures//Context.getExternalFilesDirs (Primary/Secondary) /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures /storage/12E9-1105/Android/data/PACKAGENAME/files/Pictures //Environment.getExternalStorageDirectory /storage/emulated/0 //Environment.getExternalStoragePublicDirectory /storage/emulated/0/Pictures //Environment.getDataDirectory /data//Environment.getDownloadCacheDirectory /cache//Environment.getRootDirectory /system//Environment.getExternalStorageState mounted]]></content>
  </entry>
  <entry>
    <title><![CDATA[Layout]]></title>
    <url>%2F%2FAndroid%2FChapter%2FLayout%2F</url>
    <content type="text"><![CDATA[Layout view跟layout定義上的差別: view是通常形容元件 layout則是容器(容器內的排版)layout是view的子類 RelativeLayout定位於 某元件 或 所處容器 的相對位置 FrameLayout定位於左上角 (view會重疊) LinearLayout水平或垂直 接續排列 權重分佈 TableLayout格狀排列 ConstraintLayout約束排列 約束元間之間的相對關係 (取代RelativeLayout) LayoutParams.FILL_PARENT //依父容器大小 填滿父容器LayoutParams.WRAP_CONTENT //依內容大小 適當顯示 SwipeRefreshLayout有下拉Refresh功能 findViewById&lt;SwipeRefreshLayout&gt;(R.id.refresh_layout)?.apply &#123; isRefreshing = true //設定為正在refresh setColorSchemeColors( ContextCompat.getColor(activity, R.color.colorPrimary), ContextCompat.getColor(activity, R.color.colorAccent), ContextCompat.getColor(activity, R.color.colorPrimaryDark) ) setOnRefreshListener&#123; println("do refresh...") postDelayed(&#123; println("done refresh...") isRefreshing = false //設定為沒在refresh &#125;, 3000) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ArchitectureComponent]]></title>
    <url>%2F%2FAndroid%2FChapter%2FArchitectureComponent%2F</url>
    <content type="text"><![CDATA[video video LifecycleOwner : lifecycle的擁有者 像activity或fragment都是LifecycleOwner 可透過getLifecycle()取得Life LifecycleObserver : 一個介面 實作這個介面 就能透過Life.addObserver加入監聽lifecycle事件的行列 ViewModel :]]></content>
  </entry>
  <entry>
    <title><![CDATA[Misc]]></title>
    <url>%2F%2FAndroid%2FChapter%2FMisc%2F</url>
    <content type="text"><![CDATA[Launcher 即手機home鍵看到的畫面 以及其延伸的機制 本身同樣為activity HomeScreen WorkSpace 上半部的大範圍 HotSeat 底下的熱連結 AppList (GridView) 應用 Shortcut 將app中某些功能結合user需求產生快捷 LiveFolder 類似將一個content provider封裝 AppWidget WallPaper]]></content>
  </entry>
  <entry>
    <title><![CDATA[Widget]]></title>
    <url>%2F%2FAndroid%2FChapter%2FWidget%2F</url>
    <content type="text"><![CDATA[Widget 一個自訂的service(app)顯示且整合於WorkSpace中 整合困難的部分在於launcher與widget執行於兩個不同的process中 AppWidget 即自訂的app AppWidgetHost 一個AppWidget的宿主 負責與AppWidget交互 AppWidgetHostView AppWidgetManager AppWidgetProvider 提供view的更新 是一個BroadReceiver (即使是空的也無所謂) AppWidgetProviderInfo 提供資料的更新(mata-data) 寫code只需要AppWidgetProvider與Manifest+provider_info+layout的設定即可 RemoteViews 一個能夠對映view的投射物件(兩者都從相同的layout建立) 透過RomoteViews操作view 再將此RomoteViews丟到遠端 遠端即可知道如何更新實際的view 達到跨process的view操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[Animation]]></title>
    <url>%2F%2FAndroid%2FChapter%2FAnimation%2F</url>
    <content type="text"><![CDATA[*post animation property (透過修改view實例自動產生動畫) view animation (tween) (Alpha Rotate Scale Translate Set) drawable animation (frame by frame) 單位: 數字 : px 50% : 自己寬度的50% 50p : 容器寬度的50% //Tweenanim.setDurationanim.repeatMode // 重頭再開始 / 倒退再開始anim.fillAfter // 停在結束anim_set.add(anim)view.startAnimation(...)anim = animationUtils.loadAnimation(R.id....) // from xmlaty.overridePendingTransition() //過場動畫 //viewFlipperfilper.setInAnimation(...)filper.setOutAnimation(...) android:activityOpenEnterAnimation&lt;ViewAnimator android:inAnimation="@android:anim/slide_in_left"&gt; &lt;TextView/&gt; &lt;TextView/&gt;&lt;/ViewAnimator&gt; youtube Animation Tweened alpha 透明(淡入淡出) rotate scale translate 移動 Frame-by-Frame TweenedAlphaAnimation animate = new AlphaAnimation(1, 0);animate.setStartOffset(1000);animate.setDuration(1000);animate.setFillAfter(true); //動畫後停留在最後animate.setFillBefore(false); //動畫後回到起點animate.setRepeatCount(1);AnimationSet aset = new AnimationSet(true); //共用interpolatoraset.addAnimation(animate);imageview.startAnimation(aset); //rotate需定義旋轉的中心點,中心點可相對於自己或containarRotateAnimation animate = new RotateAnimation(0, 360 Animation.RELATIVE_TO_PARENT, 1f, Animation.RELATIVE_TO_PARENT, 0f); //scale需定義縮放的軸心,軸心可相對於自己或containarScaleAnimation animate = new ScaleAnimation(1, 0.1f, 1, 0.1f Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); //向中心點縮小 ####用xml建動畫流程建res/anim目錄,寫alpha.xml,android studio會自動產生對應的code在gen/R.java &lt;set ...&gt; &lt;alpha ... /&gt;&lt;/set&gt; Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha); Interpolator用途示範插值器 補插動畫效果 Frame-by-Frame&lt;animation-list ...&gt; &lt;item android:drawable="..." android:duration="500" /&gt;&lt;/animation-list&gt; imageview.setBackgroundResource(R.drawable.animff);AnimationDrawable ad = (AnimationDrawable)imageview.getBackground();ad = AnimationUtils.loadAnimation(this, R.anim.alpha); LayoutAnimationController控制layout group中動畫的順序 ####從java建立Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha);LayoutAnimationController lac = new LayoutAnimationController(animate);lac.setDelay(0.5f);lac.setOrder(LayoutAnimationController.ORDER_NORMAL);listview.setLayoutAnimation(lac); ####從xml導入&lt;LayoutAnimation delay="0.5" animationOrder="normal" animation="@anim/alpha"/&gt; &lt;ListView layoutAnimation ="@..."/&gt; AnimationListeneranimation.setAnimationListener(new AnimationListener()&#123; onAnimationStart() onAnimationEnd() onAnimationRepeat()&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thread的各式需求]]></title>
    <url>%2F%2FSingle%2FThread%E7%9A%84%E5%90%84%E5%BC%8F%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[相關知識 program : binary code,一段機械碼或可被執行的檔案 process : 執行一個program後形成一個process,其中包含一塊記憶體空間(code/heap)與thread. process間是不共用的,互相通信需特殊的機制 thread : 實際執行程式碼的單元 包含一stack儲存原生變數與參考及函數流程等執行位址 task : 任務,軟體概念,task是指派給thread執行的,類似Runnable corutine: 協程,軟體概念,由應用程式或編譯器實作的軟體架構,目的在於有效與便利運用thread與thread間的切換 corutine例如要完成一個取得一筆資料顯示到ui上,額外需要一個io thread避免ui thread被較慢的io thread阻塞,程式的編寫上可能需要一個func切換到io thread執行,還要一個callback func返回執行結束,以及一個組合這些流程的func,一整個流程散落各處. 協程相當於將block排程到thread中,由背景系統決定執行時機,也就是說該block成為該thread中一個異步執行的任務,我們只需透過async宣告異步任務與await等待任務,就能將前述的動作寫在一個block中. 用於單執行緒的javascript中最為顯著. async&#123; value = await getData();&#125; concurrent vs parallel concurrent : 並行 N -&gt; 1 像是排程(Javascript) parallel : 平行 N -&gt; N Thread的切換一個流程中某些動作必須跳到異步執行 待執行完再切回原本的thread 這些切換thread的動作將使一個流程無法順暢的寫完 舉例: user按下執行按鈕 (ui) 下載url的內容 (network) 存成本地檔案 (i/o) 取得執行狀況 將內容顯示於ui (ui) coroutine 協程 透過async/await讓工作不立即執行 且能夠被等待 相當於排程的概念 更有效率的使用thread 例如 : 在main thread中連續執行ABC三函數 一般情況下執行的順序是ABC 若B能進入異步 順序會變為AC…B (B不確定何時執行) 若B能進入異步 且C能等待B執行完 順序又變回ABC 假若B在異步執行時是透過其他thread 那C等待B時main thread還能繼續其他工作 Javamessage handler適合簡單的切換 多個連續流程仍難以處理 exector 預先做好各個thread,執行時丟入runnable 切換越多次巢狀越明顯 沒辦法等待(await) (等待會進入blocking) public class AppExecutors &#123; //seeu 建立Thread切換機制 private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors() &#123; diskIO = Executors.newSingleThreadExecutor(); networkIO = Executors.newFixedThreadPool(THREAD_COUNT); mainThread = new MainThreadExecutor()); &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; private static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; Kotlin (透過協程)RxJavaEventBus]]></content>
  </entry>
  <entry>
    <title><![CDATA[Room]]></title>
    <url>%2F%2FAndroid%2FChapter%2FRoom%2F</url>
    <content type="text"><![CDATA[TypeConverter 建立物件與database primitive type的轉換 data class Word( @SerializedName("naText") var naText: String, @SerializedName("taText") var taText: String)//透過TypeConverter建立object與json字串的轉換class WordConverter &#123; @TypeConverter fun word2Json(words: ArrayList&lt;Word&gt;): String &#123; val json = Gson().toJson(words) return json &#125; @TypeConverter fun json2Word(json: String): ArrayList&lt;Word&gt; &#123; val turnsType = object : TypeToken&lt;ArrayList&lt;Word&gt;&gt;() &#123;&#125;.type val list = Gson().fromJson&lt;ArrayList&lt;Word&gt;&gt;(json, turnsType) return list &#125;&#125;@Entity(foreignKeys = [ForeignKey(entity = BookInfo::class, parentColumns = ["id"], childColumns = ["bookId"], onDelete = CASCADE)])@TypeConverters(WordConverter::class) //加入需要的TypeConverterdata class BookContent(@PrimaryKey(autoGenerate = true) var id: Long, var bookId: Long, var words: ArrayList&lt;Word&gt; = ArrayList&lt;Word&gt;()) ForeignKey (外鍵) 使該table(child)與外界的table(parent)連動 例如一起被刪除 Embedded 在table中坎入其他table或pojo class 避免宣告裡必須攤平所有欄位失去結構 可作為查詢時暫用的表 實際的解析上有點像是將Embedded表的欄位名(變數名)平面化 所以各個表中的欄位名還不能重複 若重複還要加prefix將整個表的欄位名加前綴 select語句針對prefix的部分必須一一列出(太麻煩了) SELECT *, tbl_b.id as prefix_id FROM tbl_a INNER JOIN tbl_b ON tbl_a.id=tbl_b.id WHERE ... Relation 可以建立一個連動的查詢 整合到一個table中 (用起來方便但要多建一個class) @Entitydata class BookSet( @Embedded var info: BookInfo?=null,//BookContent.bookId對映BookInfo.id//查詢的結果必須是List或Set @Relation(parentColumn = "id", entityColumn = "bookId") var content: List&lt;BookContent&gt;?=null) Migration 升級]]></content>
  </entry>
  <entry>
    <title><![CDATA[DB-MySQL]]></title>
    <url>%2F%2FAndroid%2FChapter%2FDB-MySQL%2F</url>
    <content type="text"><![CDATA[SQLiteOpenHelperref public class DBHelper extends SQLiteOpenHelper &#123; public DBHelper(Context context) &#123; super(context, "mydb.db", null, 0); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("CREATE TABLE IF NOT EXISTS user(\ _id INTEGER PRIMARY KEY AUTOINCREMENT, \ name TEXT)" ); &#125;&#125;dbHelper = new DatabaseHelper(context);SQLiteDatabase db = dbHelper.getWritableDatabase();SQLiteDatabase db = dbHelper.getReadableDatabase();db.close();//insertContentValues values = new ContentValues();values.put("id", 1);values.put("name", "jim");db.insert("user", null, values);db.execSQL("insert into user (id,name) values (1,'carson')") //updatevalues.put("name", "jim2");db.update("user", values, "_id=?", new String[] &#123; "1" &#125;);db.execSQL("update [user] set name = 'jim2' where _id=1");//deletedb.delete("user", "_id=?", new String[]&#123;"1"&#125;);db.execSQL("delete from user where _id=1");//seleteCursor c = db.rawQuery("select * from user where id=?",new Stirng[]&#123;"1"&#125;);c = db.rawQuery("SELECT _id, name FROM user");c = db.query("user", new String[] &#123; "_id", "name" &#125;, "_id=?", new String[] &#123; "1" &#125;, null, null, null); Cursor//遍歷1while (c.moveToNext()) &#123; int idx = c.getColumnIndex("_id"); //取得欄位idx int id = c.getInt(idx); //取得資料&#125; //遍歷2c.moveToFirst(); while(!c.isAfterLast())&#123; //dosomething c.moveToNext(); &#125;//記得關閉c.close();]]></content>
  </entry>
  <entry>
    <title><![CDATA[Task]]></title>
    <url>%2F%2FAndroid%2FChapter%2FTask%2F</url>
    <content type="text"><![CDATA[Activity.runOnUiThread activity內建的一方法 便於異步切回main thread AsyncTaskref aad : Execute a background task inside of a Service thread pool+handler應用的再封裝 易於與main(UI) thread切換 需在main thread建立與執行 (最終記得cancel) class MyTask extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123;//&lt;傳入型態, 進度值型態, 結果型態&gt; @Override public Bitmap doInBackground(String ...args)&#123; //進入異步 不要做view操作 publishProgress(...); activity.runOnUiThread &#125; onPreExecute() //回main thread onProgressUpdate(Integer... values) //回main thread onPostExecute(Bitmap bitmap) //回main thread&#125;new MyTask().execute("str"); CountDownLatch// 1.設定好要count down的數量final CountDownLatch countDownLatch = new CountDownLatch(1);// 2.在異步thread結束後countDown使其歸零countDownLatch.countDown();// 3.一直等到countDownLatch為0才返回countDownLatch.await(); Timer &amp; TimerTaskTimer timer = new Timer()timer.schedule(new TimerTask() &#123; @Override public void run() &#123; //... &#125;&#125;, 1000, 1000);timer.cancel() Looper + Handler Looper消息接收器 建立時連帶建立一個MessageQueue Handler消息處理/發送器 用途在於將msg或task隊列執行 Looper與Handler內部都是利用current thread做為key 所以建立與呼叫時所處的thread很重要 //自訂的class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; //以當下thread建立looper (內部會存於map中) Looper.prepare(); //以當下thread建立Handler 並取得當下thread的looper中的MessageQueue //於是looper與handler都有共通的msgQueue //之後外部可用handler建立傳遞msg進入msgQueue //loop即能收到msg並透過msg的callback回叫handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; &#125; &#125;; //以當下thread執行loop (當下thread會進入等待msg的loop而block住) Looper.loop(); &#125;&#125; MessageQueue 內部是透過native code實現主要機制 HandlerThread 同上方範例 但沒有handler public void download2(String url) &#123; HandlerThread ht = new HandlerThread("MyHandlerThread"); ht.start();//必須先啟動thread (執行prepare後looper才會建立) //直接指定Handler的looper Handler handler = new Handler(ht.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //H:MyHandlerThread System.out.println("H:"+Thread.currentThread().getName()); if (msg.obj=="quit") getLooper().quit(); &#125; &#125;; handler.post(new Runnable()&#123; public void run()&#123; //R:MyHandlerThread System.out.println("R:"+Thread.currentThread().getName()); &#125; &#125;); handler.obtainMessage(0, "url").sendToTarget(); handler.obtainMessage(0, "quit").sendToTarget();&#125; main thread預設已執行prepare 所以在main thread下Handler能直接使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[壓力循環測試]]></title>
    <url>%2F%2FAndroid%2FChapter%2FMonkeyTest%2F</url>
    <content type="text"><![CDATA[Android測試 adb (android debug bridge)Android SDK本地端執行程式 crash / anr(activity not responding) //列出deviceadb devices//進入手機shell (如果Permission denied可執行su)adb shell//到安裝路徑cd /data/data/com.jimliuxyz.vocabook.mock///安裝apkadb install package.apk//取得 device logadb logcat monkeyAndroid OS上的測試程式 monkey 自動壓力測試(隨機操作)//執行測試 (隨機點擊操作)adb shell monkey 100//執行100個操作 每1000ms執行一次 以50為操作seedadb shell monkey -p tw.com.langstar.t1 -v -s 50 --throttle 1000 100-v : detial info-s : seed操作種子 固定的種子能複製出同樣的操作行為--pct-touch : touch操作的百分比--ignore-crashes : crash後自動重啟再測試---//手機內存放anr的log目錄data/anr monkey 自訂測試腳本//Android SDK內建的UI元件檢視器 能查詢執行中的app/Users/jimliu/Library/Android/sdk/tools/bin/uiautomatorviewer//上傳檔案adb push myscript /data/local/tmp//執行測試 (隨機點擊操作)adb shell monkey -f /data/local/tmp/myscript 100 // 點擊DispatchPointer(downtime,eventide,press:0/release:1,x,y,pressure,size,metastate,xpresision,ypresision,device,edgeflags)DispatchPointer(10,10,0,100,100,1,1,-1,1,1,0,0)DispatchString(mystr)//manifest的activity須加exported="true"屬性LaunchActivity(package, package + ActivityName)UserWait(1000) //msDispatchPress(66) //keycode monkeyrunnerAndroid SDK本地端程式/Users/jimliu/Library/Android/sdk/tools/bin/monkeyrunner從本地端執行python控制測試流程 可抓圖 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#MonkeyRunner.alert("msg", "title", "okText")device = MonkeyRunner.waitForConnection(3, "emulator-5554")device.startActivity("package/package.activityname")MonkeyRunner.sleep(2)device.touch(100, 100, "DOWN_AND_UP")device.type("string")device.press("KEYCODE_ENTER", "DOWN_AND_UP")image = device.takeSnapshot()image.writeToFile("./test.png", "png") monkeyrunner demo.py]]></content>
  </entry>
  <entry>
    <title><![CDATA[ShellCmd]]></title>
    <url>%2FLinux%2FSingle%2FShellCmd%2F</url>
    <content type="text"><![CDATA[refref find grep awk//資料夾中搜尋文件內容grep -r '導航' ~/GoogleDrive/grep -r --include="*.java" "service" .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[頁面導航]]></title>
    <url>%2F%2FAndroid%2FChapter%2FNav%2F</url>
    <content type="text"><![CDATA[task back stack行為設定參考官方中文說明Android 深入ActivityAndroid基礎知識 launchMode intent flag minifest activity Deep Link(App Links) 超連結啟動apprefref aad:Implement non-standard task stack navigation (deep links) &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;!--從adb啟動--&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!--從browser啟動--&gt; &lt;data android:scheme="app" android:host="jimliuxyz.com"&gt;&lt;/data&gt;&lt;/intent-filter&gt; adb shell am start -W -a android.intent.action.VIEW -d "app://jimliuxyz.com" com.jimliuxyz.tsnoteam : activity maneger-W : wait for launch to complete[-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;]package不一定要 如果要用override fun onNewIntent()處理 activity要為singleTop之類 TaskStackBuilderrefref 用於憑空建立parent activity於TaskStack中當MsgActivity是從其他app(intent或deep link)啟動時 並沒有自己的back stack 所以按下back按鈕時 無法回到MainActivity 此時就需要NavUtils工具 Minifest 指定android:parentActivityName為欲返回的MainActivity &lt;activity android:name="com.example.myfirstapp.MsgActivity" android:label="display_message" android:parentActivityName="com.example.myfirstapp.MainActivity" &gt; &lt;!-- Parent activity meta-data to support 4.0 and lower --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.myfirstapp.MainActivity" /&gt;&lt;/activity&gt; //通常都經由ActionBar左上角的箭頭驅動返回事件(android.R.id.home)getActionBar().setDisplayHomeAsUpEnabled(true); //測試不okIntent upIntent = NavUtils.getParentActivityIntent(this);if (NavUtils.shouldUpRecreateTask(this, upIntent)) &#123; //非處於自己app的back stack中時 TaskStackBuilder.create(this) .addNextIntentWithParentStack(upIntent) .startActivities();&#125; else NavUtils.navigateUpTo(this, upIntent); 透過PendingIntent預先設定好(測試ok)notify-user Intent intent = new Intent(this, MsgActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addNextIntentWithParentStack(intent); //依manifest設定的android:parentActivityNamepi = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); launchMode manifest可設定activity的android:launchMode standard : 不斷新建堆疊a - a&apos; - a&apos;&apos; singleTop : 同standard,但當該activity已處於stack top時不會再新建a - a - a - b - a&apos; - a&apos; singleTask : 不會重開,該activity出現時勢必將task中其他task全部拋掉a - a - b - c - d - a [back]離開app singleInstance : 不會新建,該activity的task僅允許自己使用a - a - a [back]離開a回到b b - [back]離開b回到home 簡述 standard - 不斷重開堆疊 : 預設 (可能有多個aty重複) singleTop - 頂端不新建 : 合理避免重複 (可能有多個aty重複) singleTask - 頂端排他 task pop all : Home singleInstance - 獨佔 : 供別的app使用 single指的是activity不新建 但會執行onNewIntent() taskAffinity allowTaskReparenting同樣與task相關 有點像是群組的概念 例如使一群activity全被退出 FLAGACTIVITY透過intent開啟的activity該依循何策略進入task或操作stack FLAG_ACTIVITY_NEW_TASK(同singleTask) : aty會在自己的task中 new aty : 為aty新增tasknew aty : push進aty原屬的taskold aty : 顯示task但aty不會到top (怪怪的) FLAG_ACTIVITY_CLEAR_TOP : pop出原本在其上者 b是FLAG_ACTIVITY_CLEAR_TOPa - b - c - d - b (此時cd會被pop出,剩下ab) FLAG_ACTIVITY_BROUGHT_TO_FRONT : activity會to front FLAG_ACTIVITY_MULTIPLE_TASK : 能以另一個task啟動(act實體個別存在不同的task) FLAG_ACTIVITY_SINGLE_TOP(同singleTop) FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET與FLAG_ACTIVITY_RESET_TASK_IF_NEEDED : 1.設定清除點 2.pop掉清除點與之後的 還有很多…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Intent]]></title>
    <url>%2F%2FAndroid%2FChapter%2FIntent%2F</url>
    <content type="text"><![CDATA[概述 一個意圖/命令的容器putExtra僅能傳遞native type,或序列化物件(Serializable或Parcelable) 顯示 : 指定元件的類別 隱式 : 僅提供ACTION 不指定元件的類別 intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(file), "image/*");startActivity(intent);intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://..."));startActivity(intent); Intent導航與返航####導航 //啟動startActivity(intent)startActivityForResult(intent, req_id) //透過activity或fragment呼叫//被啟動override fun onCreate(savedInstanceState: Bundle?) //首次啟動override fun onNewIntent(intent: Intent?) //已啟動 但有新intent ####返航 setResult() //均透過activityoverride fun onActivityResult(int requestCode, int resultCode, Intent data) fragment有startActivityForResult與onActivityResult,但沒有setResult PendingIntent 封裝執行intent的機制 類似於將startActive/startService與intent封裝起來 丟給系統 透過系統機制讓user觸發intent此外尚有些flag策略 通常就是和Notification合用 Notification 位於手機上方的通知欄 可作為service的ui使其能顯示狀態與被使用者操作 //NotificationManagernm = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);//Intentintent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);//PendingIntentpi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);//NotificationCompat.Builderbuilder = new NotificationCompat.Builder(this, "practice_channel") .setSmallIcon(android.R.drawable.ic_dialog_info) .setContentTitle(getString(R.string.time_to_practice)) .setContentText(getString(R.string.it_is_time_to_practice)) .setAutoCancel(true) .setContentIntent(pi);//產生與取消nm.notify(NOTIFICATION_ID, builder.build());nm.cancel(NOTIFICATION_ID);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android CheatSheet]]></title>
    <url>%2F%2FAndroid%2FChapter%2FCheatSheet%2F</url>
    <content type="text"><![CDATA[//下載圖片img = Drawable.createFromStream(new URL(url).openStream(), "");//顯示短暫訊息Toast.makeText(this, "...", Toast.LENGTH_SHORT).show();getResources().getStringArray(R....);getResources().getXml(R....); //XmlResourcesParsergetAssets().open("...")getSystemService(Service...)//URIMediaStore.Images.Media.INTERNAL_CONTENT_URI 查看activity back stackadb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' | sed -En -e '/com.jimliuxyz/p']]></content>
      <tags>
        <tag>CheatSheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[協助工具]]></title>
    <url>%2F%2FAndroid%2FChapter%2FHelpingTools%2F</url>
    <content type="text"><![CDATA[uiautomatorviewer 檢視View階層 (方面找ID) cd ~/Library/Android/sdk/tools/bin/ uiautomatorviewer draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStackadb shell dumpsysadb shell dumpsys Android-Debug-Databaseref, 本地端連結 dependencies &#123; debugImplementation 'com.amitshekhar.android:debug-db:1.0.0'&#125; # Working with emulatorcd /Users/jimliu/Library/Android/sdk/platform-tools./adb forward tcp:8080 tcp:8080 LeakCanaryLeakCanary 檢測記憶體洩漏 (針對activity生命週期) dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'&#125; public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) return; LeakCanary.install(this); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[功能測試]]></title>
    <url>%2F%2FAndroid%2FChapter%2FTesting%2F</url>
    <content type="text"><![CDATA[JUnit 僅於本地JVM上測試 又稱單元測試(函數功能測試) 不依靠android環境 以滑鼠右鍵選單”Go To&gt;Test”快速建立test class Annotation @Test 註解一函數為 測試使用 @Test(expected = Exception.class) 使符合預期時拋出異常 @Test(timeout=100) 指定測試需在100ms內完成 @Before 註解一函數為 每個測試函數執行要先執行的函數 @After 邏輯同上 @BeforeClass @AfterClass 邏輯同上 但僅為整個class執行一次 @Mock 宣告一個假物件 @Captor 宣告一個叫用參數捕捉器(以取得叫用參數) @Spy 監視一個真物件 @Rule 修飾TestRule Matchers 比對器 類似過濾行為 能以廣義的形容區別物件 eqis 是某個objectisA 是某個classnotanyInthasItem Assert 斷言結果 判斷值是否符合預期 若不符合斷言即為測試失敗 //斷言結果需為trueassertTrue("test failure", mockins.func() == 1);//斷言instance.func()執行回傳為1assertThat("test failure", mockins.func(), is(1)); //用Matcher判斷assertThat(mockins.getList(), not(hasItem(not_expected));//assertEquals mockito 製作假物件ref 通過製作假物件與指定其反應回傳 來驗證該假物件是否被呼叫?以何參數呼叫? 通常被測物需為真物件(因為要測試他的邏輯) 其依賴物為假物件(不著重邏輯是否正確或回傳什麼 僅著重是否被真物件正確叫用) //1. 產生mock物件@Mock MyClass mockIns; //不需要newMockitoAnnotations.initMocks(this); //但之後要做init使class內的@Mock生效//1. 產生mock物件LinkedList mockList = mock(LinkedList.class);LinkedList mockList = mock(LinkedList.class, Mockito.RETURNS_SMART_NULLS); //指定預設的回傳//2. 指定mock物件的反應 (此動作稱為Stubbing)when(mockList.get(0)).thenReturn("it's a mock string");when(mockList.get(1)).thenThrow(new RuntimeException());when(mockList.get(anyInt())).thenReturn("element");when(mockList.size()).thenReturn(1, 2, 3); //每次回傳都不同//doReturn, doThrow, doAnswer, doNothing, doCallRealMethoddoThrow(new RuntimeException()).when(mockList).clear();reset(mockList); //清除所有Stubbing//3. 經過某些動作操作後...即可進入驗證mockedList.add("once");//驗證1. 驗證mock物件的方法是否被呼叫(times, atLeast, atMost, atLeastOnce, never, timeout)verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); verify(mockedList).set(anyInt(), eq("element")); //用Matchers便於廣義的驗證//驗證2. 連帶驗證呼叫順序InOrder inOrder = inOrder(mockedList);inOrder.verify(mockedList).add("first");inOrder.verify(mockedList).add("second");//驗證3. 捕捉呼叫參數ArgumentCaptor&lt;String&gt; args = ArgumentCaptor.forClass(String.class);mockedList.add("John");verify(mockedList).add(args.capture()); //驗證add的叫用 同時捕捉叫用的參數assertEquals("John", args.getValue()); spy監視真物件List list = new LinkedList();List spy = spy(list);//之後spy即類似mockito的操作 TestRule 能在測試函數前後插入動作 例如偵測測試函數的執行時間 加入TestRule時需用@Rule註解才能與JUnit掛鉤 public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; //base : 一個能夠驅使測試函數被執行的物件 //description : 一個相關於測試函數環境的描述 return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; //即測試前 base.evaluate(); //即測試後 &#125; &#125;; &#125;&#125;@RuleMyRule rule = new MyRule() EspressoAndroid testing samples 依賴於JUnit的一個測試框架 UI測試 依靠android環境執行 針對view元件進行驗證 基本三步驟 取得view或data的互動 onView / onData 執行動作 perform 檢查驗證 check 大致動作//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); onView ViewInteraction onView(Matcher viewMatcher) 透過matcher取得view的控制 //Matcher&lt;View&gt;allOf 合併多個matcherwithIdwithTextisDisplayed//其父view的id為R.id.recyclerViewisDescendantOfA(withId(R.id.recyclerView))//其父view為ListView.classisDescendantOfA(isAssignableFrom(ListView.class))hasDescendanthasSibling perform ViewInteraction perform(final ViewAction… viewActions) 執行動作 //ViewActionclick()LongClick()clearText()replaceText("")typeText("")closeSoftKeyboard()//專為RecyclerView設計(actionOnItem)onView(allOf(withId(R.id.recyclerView))) .perform(actionOnItem(hasDescendant(withText("title")), click())); check ViewInteraction check(final ViewAssertion viewAssert) 斷言 //ViewAssertionmatches(isDisplayed()) //使用view matcher來斷言doesNotExist()isChecked() 其他pressBack() //按下返回鍵TestUtils.rotateXXX() //控制手機旋轉TestUtils.getCurrentActivity() TestUtils 一個工具類 提供靜態方法控制手機裝置 rotate / getCurrentActivity 自訂Matcher//一個回傳Matcher的functionprivate Matcher&lt;View&gt; withItemText(final String itemText) &#123; return new TypeSafeMatcher&lt;View&gt;() &#123; @Override public boolean matchesSafely(View item) &#123; return allOf( //其父view為ListView.class isDescendantOfA(isAssignableFrom(ListView.class)), //且text為itemText withText(itemText) ).matches(item); &#125; @Override public void describeTo(Description description) &#123; description.appendText("is isDescendantOfA LV with text " + itemText); &#125; &#125;; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2F%2FAndroid%2FChapter%2FContentProvider%2F</url>
    <content type="text"><![CDATA[Loader Fetch local data from disk using a Loader on a background thread Propagate data changes through a Loader to the UI refvideo 簡單理解為一個監聽器介面機制 很主要目的在實現LiveData(即時資料顯現)(ContentObserver) Activity重建時LoaderManager中已建立的Loader不需重建 能透過id續用 AsyncTaskLoader (abstract extends Loader) 分離IO與UI使用的執行緒 因為ContentProvider執行的thread是caller提供的 透過AsyncTaskLoader能讓caller處於非main thread 避免影響ui CursorLoader (extends AsyncTaskLoader) 建立cursor並透過cursor監聽uri是否被通知為變更 若是則Loader會叫用callback 使用loader//實作介面this implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;override fun onCreateLoader(id: Int, args: Bundle?): Loader&lt;Cursor&gt; &#123; //要求建立cursor (語句與用contentResolver.query建立時相同) return CursorLoader(this, URIContract.MyEntry.URI, arrayOf("_id", "value", "time"), null, null, null)&#125;override fun onLoadFinished(loader: Loader&lt;Cursor&gt;?, data: Cursor?) &#123; //loader建立完成 (cursor設定監聽的uri) data?.setNotificationUri(contentResolver, URIContract.MyEntry.URI) adapter!!.swapCursor(data)&#125;override fun onLoaderReset(loader: Loader&lt;Cursor&gt;?) &#123; //loader需被結束(釋放資源) adapter!!.swapCursor(null)&#125;//建立CursorAdapteradapter = SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, null, arrayOf("value"), intArrayOf(android.R.id.text1), 0)var lv = findViewById&lt;ListView&gt;(R.id.lv)lv.adapter = adapter//啟動loader (啟動後的實體manager自己會管理)loaderManager.initLoader(0, null, this) 自訂Loaderpublic class StringLoader extends AsyncTaskLoader&lt;String&gt; &#123; private String mCache; public StringLoader(Context context) &#123; super(context); &#125; @Override protected void onStartLoading() &#123; if (mCache != null) &#123; //跳過loadInBackground super.deliverResult(mCache); &#125; else &#123; //驅動loadInBackground與deliverResult達到資料更新 forceLoad(); &#125; &#125; @Override public void deliverResult(String data)&#123; mCache = data super.deliverResult() &#125; @Override public String loadInBackground() &#123; return "data"; &#125; @Override public void onReset()&#123; //結束該loader 釋放資源 super.onReset() &#125;&#125; ContentProviderrefref 行為 提供資料存取的獨立個體 應該是被動的存在 有權限的約束 Activity靠ContentResovler與ContentProvider聯繫 以uri指定資源的路徑 回傳Cursor給外部使用 MINE type 即 類型/子類型 (應用類型/文件類型) 例如 text/html ContentProvider的應用類型固定為cursor 文件類型可以自訂 "vnd.android.cursor.dir/multi" //multiple record"vnd.android.cursor.item/single" //single record uri ContentUris URI解析工具 //建立uriUri uri = Uri.parse("content://com.jxyz.provider/user") //添加iduri = ContentUris.withAppendedId(uri, 5); //取出idlong personid = ContentUris.parseId(uri); UriMatcher URI比對工具 matcher = new UriMatcher(NO_MATCH); //不匹配時回傳NO_MATCHmatcher.addURI("com.jxyz.provider", "user", USER); //匹配回傳URI_USERmatcher.addURI("...", "user/#", USER_ID); //# : intmatcher.addURI("...", "user/info/*", USER_NAME); //* : stringswitch(matcher.match(uri))&#123; case URI_USER: ...&#125; ContentObserver 監視uri對應內容的變化 //監聽uri變動contentResolver.registerContentObserver(uri, true, mContentObserver)//通知uri變動contentResolver.notifyChange(uri, null);//要求cursor監聽uri (使CursorLoader能自動更新)cursor.setNotificationUri(context.contentResolver, uri) 權限//宣告本app自訂的權限&lt;permission android:name="com.jxyz.provider.READ" android:protectionLevel="normal"/&gt;//provider就可用該權限指定需要受約束的元件&lt;providerandroid:name=".MyProvider"android:authorities="com.jxyz.provider"android:readPermission="com.jxyz.provider.READ"android:exported="true"&gt;&lt;/provider&gt;//其他app若要有該權限 則需如下宣告讓user同意該使用權限&lt;uses-permission android:name="com.jxyz.provider.READ"/&gt; public class MyProvider extends ContentProvider &#123; private Context mContext; DBHelper mDbHelper = null; SQLiteDatabase db = null; //Application.instance.packageName() + ".provider" public static final String AUTOHORITY = "com.jxyz.provider"; public static final int USER_CODE = 1; public static final int USERID_CODE = 1; private static final UriMatcher mMatcher; static&#123; mMatcher = new UriMatcher(UriMatcher.NO_MATCH); mMatcher.addURI(AUTOHORITY,"user", USER_CODE); mMatcher.addURI(AUTOHORITY,"user/#", USERID_CODE); &#125; @Override public boolean onCreate() &#123; mContext = getContext(); mDbHelper = new DBHelper(mContext); db = mDbHelper.getWritableDatabase(); //init mock db.execSQL("delete from user"); db.execSQL("insert into user values(1,'Carson');"); db.execSQL("insert into user values(2,'Kobe');"); return true; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; db.insert("user", null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; int code = mMatcher.match(uri); if (code == USERID_CODE)&#123; long userid = ContentUris.parseId(uri); &#125; //後續資料如需傳遞到ListView中 需有_id欄位 return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null); &#125; @Override public String getType(Uri uri) &#123; switch(mMatcher.match(uri))&#123; case USER_CODE: return "vnd.android.cursor.dir/multi"; case USERID_CODE: return "vnd.android.cursor.item/single"; &#125; return null; //封閉的app也可以直接回null &#125;&#125; 訪問ContentProviderContentResolver resolver = getContentResolver();//insertContentValues values = new ContentValues(); values.put("_id", 5); values.put("name", "allen");resolver.insert(uri, values);//queryCursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null);//updaterui = Uri.parse(uri + "/" + "7");int result = resolver.update(uri, values, null, null);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2F%2FAndroid%2FChapter%2FActivity%2F</url>
    <content type="text"><![CDATA[Activity重建與復用ref 畫面旋轉 或 變更語系 造成Activity重建 連帶影響狀態或物件需要重建 Bundle與Map類似 但key必須是string 用來存放資料 1. Minifest.xml中抑制重建 在minifest加入android:configChanges提示為自行處理 使Activity不進行重建 //android:configChanges="locale|layoutDirection"@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig);&#125; 2. onRetainCustomNonConfigurationInstance 與 getLastCustomNonConfigurationInstance 複寫onRetain將稍後要還原內容交給系統 被重建後再取回 @Overridepublic Object onRetainCustomNonConfigurationInstance() &#123; return netWorkTask;&#125; 3. Retain Fragment (官方建議使用) 設定setRetainInstance(true)即可讓Fragment復用不重建(app狀態須寫在Fragment中) (之後需注意activity/context的更動) //以下code看似在復用MyFragment,但事實上MyFragment仍會在背景被建立//除非fragment設定setRetainInstance(true)if(getSupportFragmentManager().findFragmentByTag(ID) == null) &#123; getSupportFragmentManager().beginTransaction().add(new MyFragment(), ID).commit();&#125; View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true]]></content>
  </entry>
  <entry>
    <title><![CDATA[view 與 Style]]></title>
    <url>%2F%2FAndroid%2FChapter%2FViewN'Style%2F</url>
    <content type="text"><![CDATA[/Users/jimliu/Library/Android/sdk/platforms/android-26/data/res/values/styles.xml 容器類型的view ListView : 列表顯示 RecyclerView : 列表顯示 更為靈活 取代ListView ScrollView : 可滑動的顯示 gridview / gallery / cardview LayoutInflater layout的實體化工具 將layout resource轉成view的實例 Adapter 設計模式中稱作”適配器” 簡單的說就是轉換器 以view容器的應用來說 就是將’資料數據’轉換填充到’ListView裡的各個item view’上 //以simple_list_item_1做為item viewadp = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1);//替adp添加兩筆資料adp.add("first");adp.add("second");//將adp指定給listview使用lv = findViewById(R.id.listView);lv.setAdapter(adp); BaseAdapter@Overridepublic View getView(int pos, View convertView, ViewGroup parent)&#123; //getView用於取得item view //convertView : 先前已建立的view,用於優化效能&#125;notifyDataSetChanged(); //向view通知data有變動 view才會refresh ViewHolder 主要用意在復用item view時避免重複findViewByIdv.setTag(holder);holder = (Holder) v.getTag();//RecyclerView.Adapter不用這樣寫 SurfaceView 有自己的ui thread 用於較佔時間繪圖應用 (VideoView/ImageView) View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 自定義View / ViewGroup 先分清元件與佈局的角色 大致 需要複寫onMeasure (父要求子做元件尺寸測量measureChildren) (子則量測自己) 量測完執行setMeasuredDimension ViewGroup需複寫 onLayout (排定子的繪出位置) 逐個叫用child.layout View需複寫 onDraw (繪製本身) MeasureSpec定義 為一整數 前3bit做為mode 之後作為size(寬或高) 做為父要求子做尺寸量測時的參考 (由父提供spec 子做量測) UNSPECIFIED : 沒有任何約束 EXACTLY : 約束明確的size AT_MOST : 約束上限的size LayoutParams 一個ViewGroup要遍歷所有子View的LayoutParams才知道每個子View要求被如何佈局 (所以是ViewGroup定義的 但由子View描述給其ViewGroup參照的) child.getLayoutParams Theme與Style aad:Construct a layout using XML or Java code aad:Create a custom view class and add it to a layout aad:Implement a custom application theme aad:Apply a custom style to a group of common widgets 兩者僅有使用廣度上的差別 theme針對app或activity, style針對元件, 基本上都是style 單位dp : 1dp=160ppi的px長度 (描述元件)sp : 類似dp 用於文字pt : 點 用於文字px : 像素ppi, dpi : 像素密度 pixel per inch 每英寸像素數mm : 毫米in : 英吋 attr宣告 寫在values/attrs.xml 作為元件的屬性 (元件屬性是從xml建立的 java code僅是依資源ID取值賦予元件) attr及所有資源都會自動產生於R類中的id &lt;attr name ="mycolor" format= "color" /&gt; 屬性名稱一多容易重複混淆 用declare-styleable可將其分類 java code也會比較好讀取 //將多個attr並於declare-styleable有利組織化與讀取 在R類中會是一個resId的陣列&lt;declare-styleable name="MyStyle"&gt; &lt;attr name ="mycolor" format= "color" /&gt;&lt;declare-styleable&gt; attr的賦值//在元件標籤中賦值 (前半部需指定命名空間)&lt;TextView app: mycolor="#00ff00" android:style="@style/MyStyle"&gt;&lt;/TextView&gt; //在style/theme中賦值&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="mycolor"&gt;#0037ff&lt;/item&gt; &lt;item name="android:textViewStyle"&gt;@style/textviewstyle&lt;/item&gt;&lt;/style&gt; 元件取得attr的來源 一個元件的一個attr可能有多個來源 (大致的優先順序) 於元件標籤中或標籤中指定的style有描述 從application或activity指定的theme中有描述 theme中指定的style有描述 (即指android:textViewStyle)(format=”reference”) 元件hardcode裡有預設的style 元件取得attr obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) AttributeSet 即元件標籤中的描述 attrs 欲取得的attr defStyleAttr 預設的style的attr (在theme中經由該attr參考到確切的style)(即指android:textViewStyle) 透過這樣的機制就可在theme中複寫掉元件的整個style defStyleRes 預設的style 若沒有可丟0 public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0); TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.MyStyle, defStyleAttr, defStyleRes); int color = a.getColor(R.styleable.MyStyle_mycolor, Color.BLACK); a. recycle();&#125; 可見性的設定View.visableView.invisable : 看不見 但仍佔位置View.gone : 消失 不佔位置 模糊視窗(blur)getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND); ViewStub一個空的view 用來延遲載入另一個view時當作佔位用 SpannableString v.setText()通常傳入字串 更複雜可以傳入(html, img_getter, tag_handler) 另一種是傳入SpannableString 用途都是達到圖文混排]]></content>
  </entry>
  <entry>
    <title><![CDATA[Accessibility]]></title>
    <url>%2F%2FAndroid%2FChapter%2FAccessibility%2F</url>
    <content type="text"><![CDATA[Accessibility 無障礙能力官方EventAccessibilityServiceAccessibilityEventAccessibilityService aad:Apply content descriptions to views for accessibility aad:Add accessibility hooks to a custom view 自訂View時需要sendAccessibilityEvent 否則只要注意contentDescription focusable nextFocus]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android環境概念]]></title>
    <url>%2F%2FAndroid%2FChapter%2Fbasic%2F</url>
    <content type="text"><![CDATA[編譯流程 Dalvik : Android的JVM dex : 類似jar appt：Android Asset Packaging Tool MinifestMinifest-activity參數 Contextref context可理解為app的執行環境 (包含狀態與工具) ContextWrapper會包含一個Context實例(mBase)達到複製Context Application與Activity與Service雖都能當context用(但非對應同一個mBase) 要注意Activity與Service是有被回收的可能 避免將其當context傳遞 但某些關聯性的動作只能使用activity(像是show dialog) //若context的傳遞會被對方持有時 盡可能使用Application的contextcontext.getApplicationContext() Application 繼承Context 可以理解為另外一個層級的執行環境透過Manifest指定自訂的Application類 &lt;!--Manifest--&gt;&lt;application android:name=".CustomApplication"&gt; SharedPreferencekey/value pair的儲存器 用於儲存app的設定值 MODE_MULTI_PROCESSMODE_PRIVATEsp = PreferenceManager.getDefaultSharedPreferences(context);sp = getSharedPreferences("mysp", Context. MODE_PRIVATE);sp.getBoolean("key", false);sp.edit().putBoolean("key", false);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java知識樹]]></title>
    <url>%2FJava%2FJava%2Findex%2F</url>
    <content type="text"><![CDATA[… Daemon Thread thread的一項設定setDaemon(true) 使其自動結束於沒有其他thread需執行時 又稱守護線程 例如GC的thread便是屬於此類daemon的結束是屬於強制中斷 無法預期中斷點 故其執行任務是有限制的 多線程設計模式Thread-Per-Message 即每個message都建立一個新的thread處理 message執行完thread就結束 Worker Thread 即重複不斷接受工作的thread 如同thread pool般運作 又稱background thread ThreadTimer 與 TimerTask 依時間參數 以worker thread執行TimerTask]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知識樹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知識樹]]></title>
    <url>%2FAndroid%2FAndroid%2Findex%2F</url>
    <content type="text"><![CDATA[…開發紀錄 Cheat Sheet 入門知識 IDE 編譯流程 Gradle AndroidManifest.xml 供Android系統得知此app包含的組件內容與設定 class Context 可視為app執行環境(上下文) 許多操作都是需要有執行環境才能完成Application/Activity/Service都有各自的Context 但生命週期不同 class Application 做為app的single instance 相當於app的母生命週期 SharedPreference Process 一段已載入記憶體執行的程式碼 例如一個執行中的app就是一個process Thread 實質執行程式碼的單元app中起始的thread稱為main thread又稱為ui thread 其最主要的工作為在每個16ms繪製一次畫面 若沒辦法如期執行就會造成畫面lag Resource Intent每個app都是獨立的process 無法直接互動 Intent則做為之間互動的意圖/訊息內容. 透過intent描述欲執行的動作 交由android系統執行. 通常執行動作都是啟動某個app或service. PendingIntent PendingIntent會持有一個intent 交給android系統保留 如同委託系統代為於特定時機執行 (此時intent的執行與否已與建立該intent的app無關了) IntentFilter 對於能被intent啟動的對象來說(例如Service) 需要過濾不相干的意圖 (即需預先描述相關的意圖於Filter中) Notification 位於手機上方的通知欄 四大組件即Activity/Service/ContentProvider/Broadcast 這些組件的共通點就是能被別的app透過intent啟動或間接存取 四大組件生命週期互不相同 但都是經由系統實例化誕生 或依系統機制結束 我們僅能發送intent告知意圖 Activity可視為一個頁面的持有者 Activity重建與復用 Activity常有機會被系統重建 例如螢幕翻轉或語系更動 重建後可能造成狀態的喪失 Activity導航 Deep Link 使app能透過超連結方式被開啟 TaskStack 相關於頁面的堆疊 即上一頁的功能 launchMode 指定TaskStack堆疊的策略 FLAG_ACTIVITY 用Intent開啟Activity的堆疊策略 Service可視為一個服務 服務能提供給自己或別的app 或常態的在背景默默執行Service衍生出了許多不同的類別 用以達到特定的需求 IntentService Service執行於main thread 但IntentService會切到worker thread佇列執行 JobService 與 JobScheduler 能依系統狀態約定任務的執行 例如有網路時才執行 使更有效率的驅動任務 節約電力 ContentProvider可視為一個資料提供者 提供資料給自己或別的app 透過特定的uri即可存取特定的ContentProvider 例如’電話簿聯絡人’等資訊就是透過ContentProvider運作 Cursor CursorLoader Broadcast發送或接收廣播 例如系統電力不足時會發送廣播給有註冊的接收器 Fragment可視為一個頁面中的一小部分的持有者 用意在將整個頁面拆散 其生命週期基本上是依附Activity上 或由FragmentManager管理 Database MySQLAndroid內建的Database Thread / Task為了順利與容易的協調各式工作 各種衍生的類別孕育而生 Handler 一個透過當下執行緒建立的message handler 其目的在使工作能透過該執行緒佇列的被執行 可以作為執行時切換執行緒的手段 或當佇列安插異步工作於執行緒 Looper 一個透過當下執行緒建立的訊息接收器 其內部包含一個message queue 是促成Handler運作的背後推手 AsyncTask 建立一個異步工作 執行於worker thread 且提供機制與main thread互動 AlarmManager 安排定時任務(如鬧鐘般) 用PendingIntent設定 時間到開啟Activity或Service能夠喚醒Android系統 RecyclerView View &amp; Style Layout Widget app widget 手機HomeScreen上的小工具 Testing JUnit Espresso Monkey 壓力循環測試 工具uiautomatorviewer 檢視View階層 (方面找ID) draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStack adb shell dumpsys Android-Debug-Database mysql網頁伺服器介面 LeakCanary 記憶體洩漏偵測 其他 LruCache 快取 當空間吃緊時能首先移除掉近期最少使用的(Least recent used) Accessibility 輔助殘疾人士 使其便於操作app Animation 動畫 Storage Room MySql的另一種操作方式 ArchitectureComponent LifeCycle與Observable的整合 使其產生LiveData 套用MVVM架構 debug過程 操作內建的debug工具 雜項]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>知識樹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2F%2FAndroid%2FChapter%2FService%2F</url>
    <content type="text"><![CDATA[Service app透過startService啟動service 執行於UI Thread 不會自動被系統結束 只能自己透過stopSelf結束 onStartCommand的回傳決定Service被系統殺掉後的行為 START_STICKY : Service被殺掉, 系統會重啟, 但是Intent會是null。 START_NOT_STICKY : Service被系統殺掉, 不會重啟。 START_REDELIVER_INTENT : Service被系統殺掉, 重啟且Intent會重傳。 Remote Service 同為Service僅是啟動/取得方式不同 主要用於跨process的應用 即透過bindService(intent, conn, BIND_AUTO_CREATE)取得binder實例操控service 以bindService啟動service會造成Service綁定於App的生命週期 用AIDL建立共通介面 內建已經做好了一個共通的binder 可以透過(Message(msg)).getBinder()建立 基本上是用handler處理message的方式傳遞訊息 (就不用建AIDL了) Binder 在android中做process間通訊用 (底層機制應該是linux的share memory) AIDL Android Interface Definition Language一種程式語言 用於定義介面 用於IPC(Process間通信) 與java的interface寫法類似 //IRemoteService.aidlpackage com.example.service;interface IRemoteService&#123; int getData(String key)&#125; 存成MyDataBinder.aidl,會被自動轉譯產生一個java檔,產生.Stub類別,作為server與client間共通的介面client端也必須有該.aidl檔才能編譯與正確執行. Remote Service範例實做介面//RemoteService.javapublic class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getData()&#123; return "hello"; &#125; &#125;;&#125; start service &amp; bind//Activity.java&#123; Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125;IRemoteService mIRemoteService;ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; public void onServiceDisconnected(ComponentName className) &#123; mIRemoteService = null; &#125;&#125;; IntentService Service的子類 需在manifest中宣告 Service+Handler+Looper的封裝 public class IntentServiceDemo extends IntentService&#123; public IntentServiceDemo(String name)&#123; //name for HandlerThread super(name); &#125; @Override protected void onHandleIntent(Intent intent)&#123; //進入異步 &#125;&#125;Intent intent = new Intent(this, IntentServiceDemo.class);startService(intent); JobService / JobSchedulerrefandroid-JobScheduler aad:Schedule a background task using JobScheduler Service的子類 排程不緊急或與設備狀態有關的任務(受系統牽制) 以優化系統電力消耗 在(&gt;=Build.VERSION_CODES.N)中限制了interval最小為15m flex最小為5m 比較適合惰性的任務 (時間不會準確) JobScheduler : 整個app僅有一個JobScheduler實體用來排程任務(丟入JobInfo) ComponentName : 一個pkg+cls用以描述元件 Component泛指四大組件 常用於Intent JobInfo : 指定任務執行模式 依時間/網路/Idel/充電 (透過Builder模式構建) 儲存extras當param給JobService執行 JobService : 當onStartJob時得到任務 回傳false表示任務已執行結束 回傳true表示任務進入異步執行 完成後須自行呼叫jobFinished 意象: JobService如同Service般執行 經由JobInfo建立不同任務的參數 由JobScheduler指派執行時機 呼叫JobService.onStartJob執行 執行於ui thread,耗時任務仍需另使用AsyncTask &lt;service android:name=".service.MyJobService" android:permission="android.permission.BIND_JOB_SERVICE" android:exported="true"/&gt; JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); onStopJob僅在系統強制要停止任務時呼叫 AlarmManagerref aad:Schedule a time-sensitive task using alarms 安排定時任務(time-sensitive task) 時間到用PendingIntent開啟服務或Activity 比起Java SE的Timer, AlarmManager能夠喚醒休眠的Android系統(透過PendingIntent) 被限制了interval最小為60s (時間不會準確) val intent = Intent(this, AlarmReceiver::class.java)val pi = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);val am = getSystemService(Context.ALARM_SERVICE) as AlarmManageram.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi)am.setRepeating(RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, pi);am.setRepeating(ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 1000 , 5 * 1000 , pi);class AlarmReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; &#125;&#125; &lt;receiver android:name=".AlarmReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; type(組合) RTC : 以系統時間判斷 (也就是說系統時間更改將立即反應到鬧鐘上) ELAPSED_REALTIME : 以系統流逝的時間差判斷 WAKEUP : 能於睡眠中喚醒 POWER_OFF_WAKEUP : 能於關機中喚醒]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo安裝紀錄]]></title>
    <url>%2F%E7%B4%80%E9%8C%84%2FHexo%E5%AE%89%E8%A3%9D%E7%B4%80%E9%8C%84%2F</url>
    <content type="text"><![CDATA[Hexo 、NexT 目標本地端透過Hexo建立網站骨架 並將markdown文章轉為html 上傳到github做為blog網站 安裝node.js node.js為一本地端的js執行平台 用途廣泛 npm (安裝node.js時會一並安裝) 一個套件管理系統 能透過命令列安裝套件 安裝git 版本控管工具 做為本地端工具與github連結 github 一個線上的版本控管工具 其附加功能使其能成為http伺服器其Repo需命名為”ACCOUNT_NAME.github.io” #安裝hexo命令列工具npm install -g hexo-cli#在該目錄建立node.js執行環境npm install#在該目錄建立bloghexo init blog#發佈到github的工具npm install hexo-deployer-git --save#使網頁能即時自動更新的工具npm install hexo-browsersync --save#下載慣用的blog主題佈局(NexT)git clone https://github.com/iissnan/hexo-theme-next themes/next 常規操作#新增文章hexo new "My New Post"#啟動本地端serverhexo server#產生文件hexo g --watch#上傳到githubhexo d 語法測試測試 測試 測試]]></content>
      <categories>
        <category>紀錄</category>
      </categories>
  </entry>
</search>
