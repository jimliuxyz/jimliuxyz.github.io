<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FFinTech%2FCoinPocket%2FDemo%E6%9E%B6%E6%A7%8B.html</url>
    <content type="text"><![CDATA[基本知識區塊鏈節點 礦工節點 主要負責區塊鏈資料的維護 私有節點 用以介接應用程式與區塊鏈 (建立帳號(keystore)/執行交易/取得資訊) 應用程式接入區塊鏈的方法 1.自建私有節點加入區塊網絡 2.透過第三方節點開放的rpc介面 智能合約 如同一個可程式化的資料表(資料庫) 在區塊鏈裡如一個’公證人’帳號 該帳號如同一記帳人(帳本) 與該帳號的交易行為就如同執行合約一般 其執行結果同樣寫入區塊鏈 私有鏈優點 所有節點都自己安插 安全 缺點 大致行為無異於分散式資料庫 區塊鏈形同虛設 公有鏈優點 可使用乙太坊公共網絡 與第三方應用的結合較為多元 缺點 在乙太坊公共網絡執行交易須支付額外的費用 Demo 原始碼私鏈(PoA)Docker用戶服務器Android用戶端 附錄電子錢包應用BitoEx 台廠 幣託 以email申請一個帳號 透過web/phone介面查詢 台灣可透過FamiPort繳費&gt;虛擬帳號&gt;廠商代號&gt;輸入手機號碼&gt;買多少台幣的BTC 現金結帳取得收據與手機簡訊 回BitoEx介面&gt;超商兌換 可綁定信用卡/銀行帳號(可出帳) 等於私鑰託管給BitoEx MaiCoin 台廠Coinbase 美加密貨幣交易所 可綁定信用卡/銀行帳號/paypal/wire transfer 台灣第三方金流服務台景達TaiPay智付通Spgateway綠界ECPay]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FFinTech%2FCoinPocket%2FAWS.html</url>
    <content type="text"><![CDATA[#連接# (Permissions too open)chmod 0600 ~/Downloads/AwsKeyStore.pem# 用key連接ssh進入主機ssh -i "~/Downloads/AwsKeyStore.pem" ec2-user@ec2-18-221-14-16.us-east-2.compute.amazonaws.com# 透過security group的設定控制port的開放與否 #安裝Docker 安装Ubuntu 系列安裝 Docker # 安裝yumrpm -qa | grep yum# 切換到super usersudo su# 安裝dockeryum -y install docker-io# 安裝docker-composesudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /bin/docker-compose# 啟動docker daemondservice docker startsudo service docker start# 或sudo dockerd# 安裝gityum install git-core #安裝最新版nodejsapt-get update apt-get install -y python-software-properties software-properties-common add-apt-repository ppa:chris-lea/node.js apt-get update apt-get install nodejs #方法二cd ~curl -sL https://deb.nodesource.com/setup_8.x -o nodesource_setup.shbash nodesource_setup.shapt-get install nodejs#或...curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash - #安裝mongodb yum -y install mongodb-orgservice mongod start #安裝其他 npm i -g trufflenpm install -g ethereumjs-testrpctestrpc #操作dockergit clone https://github.com/jimliuxyz/coinpocket.gitgit clone https://github.com/jimliuxyz/ethereum-poa-docker.git# 或 下載imagedocker pull jlxyz/coinpocket #bash# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/.local/bin:$HOME/binexport DOCKER_HOST=127.0.0.1export PATH yum-config-manager \ –add-repo \ https://download.docker.com/linux/centos/docker-ce.repo # renice -n +10 -p 22609renice -n +10 -p 22751 異常用newAccount函數測試區塊鏈 通常會成功一次 之後節點似乎會自己死掉 const Web3 = require('web3')const httpsoc = `http://127.0.0.1:8545`const provider = new Web3.providers.HttpProvider(httpsoc);const web3 = new Web3(provider);console.log(`web3.eth.coinbase : $&#123;web3.eth.coinbase&#125;`)setTimeout(async () =&gt; &#123; console.log("A") let account = await web3.personal.newAccount(""); console.log("B ", account)&#125;, 1000); (node:3029) UnhandledPromiseRejectionWarning: Error: Invalid JSON RPC response: undefined at Object.InvalidResponse (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/errors.js:38:16) at HttpProvider.send (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/httpprovider.js:91:22) at RequestManager.send (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/requestmanager.js:58:32) at Personal.send [as newAccount] (/home/ubuntu/coinpocket/node_modules/web3/lib/web3/method.js:145:58) at Timeout.setTimeout [as _onTimeout] (/home/ubuntu/coinpocket/test.js:18:37) #安裝web3@1.0.0 yum install gcc-c++sudo npm install --save web3@1.0.0-beta.26 --unsafe-perm --verbosesudo npm install --save web3@0.19.0]]></content>
  </entry>
  <entry>
    <title><![CDATA[MWeb]]></title>
    <url>%2Fhome%2F%2FSingle%2FMWeb%E7%95%AB%E5%9C%96.html</url>
    <content type="text"><![CDATA[教學 @startumlnode node1node node2node node3node node4node node5node1 -- node2node1 .. node3node1 ~~ node4node1 == node5@enduml graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; 範例 option = &#123; title : &#123; text: &apos;某地区蒸发量和降水量&apos;, subtext: &apos;纯属虚构&apos; &#125;, tooltip : &#123; trigger: &apos;axis&apos; &#125;, legend: &#123; data:[&apos;蒸发量&apos;,&apos;降水量&apos;] &#125;, toolbox: &#123; show : true, feature : &#123; dataView : &#123;show: true, readOnly: false&#125;, magicType : &#123;show: true, type: [&apos;line&apos;, &apos;bar&apos;]&#125;, restore : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125; &#125; &#125;, calculable : true, xAxis : [ &#123; type : &apos;category&apos;, data : [&apos;1月&apos;,&apos;2月&apos;,&apos;3月&apos;,&apos;4月&apos;,&apos;5月&apos;,&apos;6月&apos;,&apos;7月&apos;,&apos;8月&apos;,&apos;9月&apos;,&apos;10月&apos;,&apos;11月&apos;,&apos;12月&apos;] &#125; ], yAxis : [ &#123; type : &apos;value&apos; &#125; ], series : [ &#123; name:&apos;蒸发量&apos;, type:&apos;bar&apos;, data:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3], markPoint : &#123; data : [ &#123;type : &apos;max&apos;, name: &apos;最大值&apos;&#125;, &#123;type : &apos;min&apos;, name: &apos;最小值&apos;&#125; ] &#125;, markLine : &#123; data : [ &#123;type : &apos;average&apos;, name: &apos;平均值&apos;&#125; ] &#125; &#125;, &#123; name:&apos;降水量&apos;, type:&apos;bar&apos;, data:[2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3], markPoint : &#123; data : [ &#123;name : &apos;年最高&apos;, value : 182.2, xAxis: 7, yAxis: 183&#125;, &#123;name : &apos;年最低&apos;, value : 2.3, xAxis: 11, yAxis: 3&#125; ] &#125;, markLine : &#123; data : [ &#123;type : &apos;average&apos;, name : &apos;平均值&apos;&#125; ] &#125; &#125; ]&#125;; 张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FFinTech%2FCoinPocket%2Fethereum-docker(Capgemini-AIE).html</url>
    <content type="text"><![CDATA[ethereum-docker中文 docker stop $(docker ps -a -q)docker rm $(docker ps -a -q)#強制移除所有imagesdocker rmi -f $(docker images -q)#啟動docker-compose.ymldocker-compose up -d 基本上會啟動3個服務bootstrap 對外開放8545 ethereumdocker_eth_1 礦工節點 netstats http://localhost:3000 #bootstrap #啟動單一節點docker-compose up bootstrapdocker-compose up ethereumdocker_eth_1#關閉或移除所有containerdocker-compose stopdocker-compose rmdocker-compose killdocker exec -it bootstrap /bin/bashdocker exec -it bootstrap geth attach ipc://root/.ethereum/devchain/geth.ipcdocker exec -it ethereumdocker_eth_1 geth attach ipc://root/.ethereum/devchain/geth.ipc#???docker logs --follow bootstrap admin.nodeInfo.enodeeth.miningminer.start()eth.coinbaseeth.accounts[0]personal.unlockAccount(web3.eth.accounts[0])personal.unlockAccount(web3.eth.accounts[0], &quot;&quot;, 99999999)eth.pendingTransactionsadmin.addPeer(&quot;enode://6814e667f9feef605b9f168d7ea51a5b7d555936974683e51fab1d8d3d4ac9be2f098405b8c17024ba3800a30ce308470b006bb322bcc1b2918b40575c39cab2@127.0.0.1:30303&quot;)admin.peers#授權挖礦帳號clique.propose(&quot;0x0fe2d8747d24156b342c9fa5c5e7138cf4047a8d&quot;, true) 挖礦權限(PoA)挖礦權限跟節點無關 跟節點上eth.coinbase有關(即miner.setEtherbase綁定的帳戶) #取得當下礦工帳號eth.coinbase#設定礦工帳號 (coinbase)miner.setEtherbase(web3.eth.accounts[0])#設定後最好重新stop/startminer.start()#授權其他帳號挖礦clique.propose(web3.eth.accounts[1], true) bootnode#產生一組key並存到bootnode.key中#該key可在啟動geth時以nodekeyhex帶入 之後節點就會有固定的enodebootnode -genkey bootnode.key#091bd6067cb4612df85d9c1ff85cc47f259ced4d4cd99816b14f35650f59c322#以該key產生enode (主要是@前的數字)bootnode -nodekeyhex 091bd6067....INFO [05-03|16:57:03] UDP listener up self=enode://288b972....@[::]:30301 副錄… (PoW模式) 挖礦很慢 建立第一個區塊都長達數分鐘 感覺在discover找其他節點 想要做block sync?換chainId與difficulty都沒改善 執行合約函數時gas不足 gas required exceeds allowance or always failing transaction兩種可能: gas limit真的下少了 合約函數寫錯導致注定失敗 例如require(0==1) 下載舊版本的docker image 以下載ethereum/client-go為例查版本號 docker pull ethereum/client-go:v1.8.6 puppeth做出的json多包了一層docker compose忽略修改後的dockerfile#停止docker-compose down#重做docker-compose build --no-cachedocker-compose up -d --force-recreate]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FDocker.html</url>
    <content type="text"><![CDATA[簡易示範 #Dcokerfile #以'./Dockerfile'建立imagedocker build -t coinpocket .#docker run -p 8081:8081 -d coinpocket#指定啟動container執行bash (跳過預設的命令)docker run -it coinpocket /bin/bash#進入執行中的container的bashdocker exec -it 047 /bin/bash]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2Fweb3.html</url>
    <content type="text"><![CDATA[sendTransaction與callmethod type指的是一個合約函數是不是constant,如果不是,最終一定要用sendTransaction,因為該函數需要寫資料進區塊鏈,寫入動作是規範在交易裡,必須消耗gas(手續費),也需要解鎖發起人帳號的權限(因為要付錢) 另外,寫資料需要區塊鏈的多數共識,操作的結果在web3中是異步事件. // Automatically determines the use of call or sendTransaction based on the method typemyContractInstance.myMethod(param1 [, param2, ...] [, transactionObject] [, defaultBlock] [, callback]); // Explicitly calling this methodmyContractInstance.myMethod.call(param1 [, param2, ...] [, transactionObject] [, defaultBlock] [, callback]); // Explicitly sending a transaction to this methodmyContractInstance.myMethod.sendTransaction(param1 [, param2, ...] [, transactionObject] [, callback]); // Get the call data, so you can call the contract through some other meansvar myCallData = myContractInstance.myMethod.getData(param1 [, param2, ...]);// myCallData = &apos;0x45ff3ff6000000000004545345345345..&apos;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FFinTech%2FCoinPocket%2F%E9%96%8B%E7%99%BC%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[區塊鏈技術變化太快 文件 API 最好參考官方的 不然會吃屎 dockerfile範例 nodejs多執行緒cluster/pm2 nodejs事件迴圈/同步異步/耗時任務 怪事remix執行tx只要設Value都會有gas不足的問題 (所以不好測payable?/聽說跟連接方式有關)ganache的gas limit似乎是指節點執行tx的最大油耗 若太小很容易執行失敗//best兩行assign對調將出現&quot;out of gas&quot; (用法上沒有邏輯 純粹好奇)uint[] best;function func()&#123; uint[3] memory a = [uint(1), 2, 3]; best = new uint[](2); best = a; report(best);&#125; vscode的intellisense沒反應? require來源不是node_module中的一定要加. require("server/test.js") //錯誤!!!require("./server/test.js") //正確 The path /etc/localtime is not shared from OS X and is not known to Docker Add -e TZ=ls -la /etc/localtime | cut -d/ -f8-9 to the docker run command line vscode的intellisense與JsDoc搭配ref /** * @param userInfo - Information about the user. * @param userInfo.name - The name of the user. * @param userInfo.email - The email of the user. */function test(userInfo) &#123;&#125;/** * @typedef &#123;object&#125; TestConfig * @property &#123;string&#125; name * @property &#123;number&#125; gold * @typedef &#123;object&#125; TestConfig2 * @property &#123;string&#125; name2 * @property &#123;number&#125; gold2 * @param &#123;TestConfig&#125; config - 註解1 * @param &#123;TestConfig2&#125; config2 - 註解2 */function test(config, config2) &#123;&#125;@param &#123;number|undefined&#125; ...@param &#123;Object.&lt;string, number&gt;&#125; dict ...@type &#123;string&#125; ... //for one var 自創加密貨幣 (TutorialToken)truffle範例 tutorialtoken-box openzeppelin完整步驟 架構 : 本地端網頁透過websocket連本地MetaMask再連到Ganache的測試環境(節點)上本地端網頁 : 由truffle產生 主要機制在於連接MetaMask 加載合約.jsontruffle : 網頁上線前 還可幫忙編譯合約與佈建openzeppelin : 合約lib 提供標準加密貨幣的規格讓使用者繼承 //下載套用tutorialtokentruffle unbox tutorialtoken//編譯合約與發佈truffle migrate --reset//執行本地端網頁伺服器npm run dev CoinPocket範例pragma solidity ^0.4.7;contract CoinPocket &#123; event txlog(string dtypes, string action, uint amount); uint constant DTYPELEN = 2; string[] dtypes = [&quot;TWD&quot;, &quot;USD&quot;]; enum DollarType&#123; TWD, USD, _END &#125; struct Account &#123; uint[DTYPELEN] dollar; &#125; constructor() public&#123; users[this].dollar[uint(DollarType.TWD)] = 5000; users[this].dollar[uint(DollarType.USD)] = 3000; &#125; mapping (address =&gt; Account) users; modifier checkType(uint dtype)&#123; require(dtype&gt;=0 &amp;&amp; dtype&lt;dtypes.length &amp;&amp; DTYPELEN == dtypes.length &amp;&amp; DTYPELEN == uint(DollarType._END)-1 , &quot;dtype error!&quot;); _; &#125; modifier enought(uint dtype, uint amount)&#123; require(users[msg.sender].dollar[dtype]&gt;=amount , &quot;insufficient balance!&quot;); require(users[this].dollar[dtype]&gt;=amount , &quot;insufficient balance of contract!!!&quot;); _; &#125; function deposit(uint dtype, uint amount) checkType(dtype) public&#123; users[msg.sender].dollar[dtype] += amount; users[this].dollar[dtype] += amount; emit txlog(dtypes[dtype], &quot;deposit&quot;, amount); &#125; function withdraw(uint dtype, uint amount) checkType(dtype) enought(dtype, amount) public&#123; users[msg.sender].dollar[dtype] -= amount; users[this].dollar[dtype] -= amount; emit txlog(dtypes[dtype], &quot;withdraw&quot;, amount); &#125; function detail() constant public returns(uint[DTYPELEN])&#123; return users[msg.sender].dollar; &#125; function detail_pool() constant public returns(uint[DTYPELEN])&#123; return users[this].dollar; &#125; function test1() pure public returns(string)&#123; return &quot;~~It&apos;s CoinPocket!!&quot;; &#125;&#125; truffle migrate失敗 has not been deployed to detected network (network/artifact mismatch) # 1.Remove the build folderrm -r build/truffle compiletruffle migrate# 2.Usetruffle migrate --reset --all 直接用web3建立合約const fs = require('fs');const solc = require('solc');const Web3 = require('web3');/** * prepare build folder */fs.existsSync('./build') || fs.mkdirSync('./build')fs.existsSync('./build/contracts') || fs.mkdirSync('./build/contracts')/* * connect to ethereum node */const ethereumUri = 'http://localhost:8545';let web3 = new Web3();web3.setProvider(new web3.providers.HttpProvider(ethereumUri));if (!web3.isConnected()) throw new Error('unable to connect to ethereum node at ' + ethereumUri);var address = web3.eth.coinbase/* * Compile Contract and Fetch ABI, bytecode */let source = fs.readFileSync("./contracts/CoinPocket.sol", 'utf8');console.log('compiling contract...');let compiledContract = solc.compile(source);console.log('done');for (let contractName in compiledContract.contracts) &#123; var bytecode = compiledContract.contracts[contractName].bytecode; var abi = JSON.parse(compiledContract.contracts[contractName].interface); //write to local fs let data = &#123;contractName, abi, bytecode&#125; fs.writeFileSync('./build/contracts/' + contractName + '.json' , JSON.stringify(data, undefined, 2) , &#123;encoding: 'utf-8'&#125;);&#125;/* * Doploy to blockchain network */let gasEstimate = web3.eth.estimateGas(&#123;data: '0x' + bytecode&#125;);console.log('gasEstimate = ' + gasEstimate);let MyContract = web3.eth.contract(abi);console.log('deploying contract...');let myContractReturned = MyContract.new([], &#123; from: address, data: '0x'+ bytecode, gas: gasEstimate + 50000&#125;, function (err, myContract) &#123; if (!err) &#123; // NOTE: The callback will fire twice! // Once the contract has the transactionHash property set and once its deployed on an address. // e.g. check tx hash on the first call (transaction send) if (!myContract.address) &#123; console.log(`myContract.transactionHash = $&#123;myContract.transactionHash&#125;`); // The hash of the transaction, which deploys the contract // check address on the second call (contract deployed) &#125; else &#123; console.log(`myContract.address = $&#123;myContract.address&#125;`); // the contract address global.contractAddress = myContract.address; &#125; // Note that the returned "myContractReturned" === "myContract", // so the returned "myContractReturned" object will also get the address set. &#125; else &#123; console.log(err); &#125;&#125;);(function wait () &#123; setTimeout(wait, 1000);&#125;)(); brew安裝舊版軟體以安裝舊版docker為例 Formula : 指可安裝軟體的名稱 #找到Formula的rb檔案的git連結brew cask info docker#連入該git連結 按history找到自己要的版本 按view瀏覽並複製下整份code#https://github.com/caskroom/homebrew-cask/blob/master/Casks/docker.rb#在本機裡自建一個.rb檔 把複製的code貼上(cask 'docker' do改為'docker_old')cat &gt; /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/docker_old.rb#指定rb路徑做安裝brew cask install /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/docker_old.rb #安裝mongodb#官網下載安裝#主程式移動到/usr/local/下sudo mv mongodb-osx-x86_64-3.6.4/ /usr/local/mongodb#建立db目錄sudo mkdir -p /data/db#編輯.bash_profilecode .bash_profile#添加內容export MONGO_PATH=/usr/local/mongodbexport PATH=$PATH:$MONGO_PATH/bin#啟動daemon程式source .bash_profilemongod#預設port:27017]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ethereum]]></title>
    <url>%2Fhome%2F%2FFinTech%2Fethereum.html</url>
    <content type="text"><![CDATA[節點軟體 節點的核心是geth MacOs安裝 安裝(以Ubuntu為例)#ppa源 : 非Ubuntu官方上架的軟體安裝來源(Personal Package Archive)#software-properties-common為add-apt-repository的依賴sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install ethereum 簡易安裝缺bootnode, evm, disasm, rlpdump, ethtest… apt-get install geth 編譯#安裝golang編譯器sudo apt-get install -y build-essential golangcd go-ethereummake geth 官方還有提供Docker Image在Hub上 合約結構 合約也有自己的一個account 把他當人看 (這個觀念很重要!!!!!!) transaction為一個動作(交易)的執行 例如轉帳/建合約/呼叫合約 就是一個transaction 任何帳號都能發起transaction呼叫合約函數 且不能確定會有幾個節點同時執行合約 但最終只會有一個勝出 solidity仍在演化中 語法或結構隨時都會進化 只要有寫入操作都會消耗gas 若是在不允許消耗gas的函數(宣告為constant或fallback函數)中做寫入操作將導致失敗難以察覺 solidity中文簡介 pragma solidity ^0.4.2;//引用其他合約import "Another.sol"contract Test &#123; //狀態變數(state) //int/uint/byte/bool/string/struct/address/mapping //基本上允許不初始化 即'零態' 但array會報錯 //var:賦值後才確定型別(棄用) address public owner; //相當於uint160 (20byte) //事件 (會將參數寫到transaction receipt作為收據紀錄) //客戶端可以訂閱(watch)這個event (當transaction被放到blockchain後) event Becalled(address indexed caller, bytes message); //枚舉 (值為uint) enum State &#123;Ready, Doing, Done&#125; //key value pair (初值為0)(不需初始化) mapping (address =&gt; userInfo) public users; //array (初值為0,可動態,有維度,刪除元素時會shift) uint[] best; //動態陣列類似於arraylist 用push新增 uint[5] top5; function func()&#123; uint[3] memory a = [uint(1), 2, 3]; //左右必須對稱; uint(1)為顯式轉型 best = a; best = new uint[](2); //用new初始化陣列; 宣告2個元素的陣列 &#125; string str = '123' // ascii 非 unicode bytes(str)[2] //string操作通常要轉為bytes for(int i=0; i&lt;2000; i++)&#123; &#125; //hex字串轉bytes bytes memory signedString =hex"f4128988cbe7df8...."; //結構 (如同原生型態 賦值於變數時會被拷貝) (只有internal函數能回傳struct) struct Member &#123; string name; uint age; bytes12 phone; address addr; &#125; //建構子 constructor() &#123; //不能用this 不能做自己的external call &#125; //呼叫函數時用於檢查狀態 類似處理assertion //一個函數可以有多個modifier 也可以覆寫父合約的modifier modifier beforeCall &#123; if(msg.sender != owner) throw; //原函數尚未執行 _; //&lt;-表示暫時返回原函數執行 //原函數執行完畢 &#125; //函數 (函數內任何變數其作用域為整個函數 沒有block概念) function testFunc() beforeCall &#123; Member memory s = Member(&#123; age : 10, name : "Jack", &#125;); Member memory s = Member("Test", 10,...); Becalled(msg.sender, msg.data); &#125; //storage修飾傳入的是一個field(status) (僅能internal或private) function modifyX(uint[] storage _x) internal &#123;...&#125; //fallback function 當找不到叫用的函數(例如有人轉帳到合約中)或寫錯函數名則會呼叫這個函數 function()&#123; throw; //避免合約被當成一般帳戶被入帳 而之後無法出帳 &#125;&#125; memory / storage 僅針對struct與array設計 memory : 記憶體變數 如同一般程式語言 不能宣告做為field storage : 永久儲存體變數 將寫入區塊 兩者轉換都是以copy的方式 (賦值 或 經由函數傳遞時) memory變數丟到另一個函數參數也是memory 兩個會是同一塊memory (其他程式語言處理struct與array也大致如此) contract SimpleAssign&#123; //field(status)一律為storage變數 struct S&#123; string a; uint b; &#125; uint x; function assign(S s) internal&#123; //參數變數(s)預設是memory(即一份copy) //struct區域變數(tmp)預設是storage [為何要預設為storage???] S tmp = s; //報錯 //1.必須強制將傳入參數設為storage (該函數必須為internal) //2.或將tmp設為memory S memory tmp2 = S(&quot;memory&quot;, 0); //在記憶體中使用struct &#125; //struct宣告該為memory或storage跟宣告的地方與使用的方式有關 //1.丟進函數前是什麼 2.進入函數時是什麼 3.進入函數後是什麼&#125; 合約產生合約import &quot;./MyCont.sol&quot;;...address caddr = new MyCont() //部署合約 先取得addressMyCont cont = MyCont(caddr) //才能建立實體叫用 fallback函數 當呼叫一個合約中沒有的函數 會執行fallback當執行address.send()時固定會執行fallbackfallback有2300gas的限制 故大致用於事件紀錄 事件 每次交易可以紀錄receipt(收據) 取回時為json格式每次交易可以觸發多次event 產生多個log參數預設存到data欄位 例如event(A,B) 造成 {data:’AB’} 無分隔符號如果參數前綴indexed可將參數存到topic欄位(有分隔符號) 預設第一個是event的識別字 剩下3個可以用事件在客戶端可被監聽(event callback) this 合約的執行環境 等同合約的addressthis不同 表示storage不同 讀寫出的東西就不同 Contract A&#123; function func2() internal &#123;&#125; function func1()&#123; #func2被以internal的方式呼叫 func2(); #func2被以external的方式呼叫 (若func2強制宣告為internal則會報錯) this.func2(); &#125;&#125; send()與transfer() 都用於傳送eth 有2300gas限制 send() 失敗回傳falsetransfer() 失敗直接throw(建議使用)#msg.sender傳送1wei給addraddr.send(1) assert與require與throw 都是assertion的處理throw偏向意外會被取走等同gasLimit的手續費 (正常是gasUsed)assert與throw一樣 (應注意而未注意)require為gasUsed (需求不符)(可傳錯誤訊息)revert() 同require 只是沒有輸入參數(可傳錯誤訊息) call()與delagatecall()示例除了用send()與transfer()做tx外 call也可以達成 A為caller B為someone caller執行someone.call(&quot;somefunc&quot;)&gt; 在somefunc中 : this為someone ; msg.sender為caller&gt; 兩合約各自安全&gt; 可以串addr.gas().value().call(...) 指定gas與value caller執行someone.callcode(&quot;somefunc&quot;)&gt; 在somefunc中 : this為caller 等同於caller將somefunc嵌入自己的函數中&gt; caller的變數有被覆寫的風險 `somefunc中沒有msg訪問權` (已納入棄用) caller執行someone.delagatecall(&quot;somefunc&quot;)&gt; 同callcode 差別在有msg訪問權 (msg持續是caller中的msg) #increaseAge為合約內的一個函數bytes4 methodId = bytes4(keccak256(&quot;increaseAge(string,uint256)&quot;));#addr為合約帳戶 固定返回bool表示成敗bool res = addr.call(methodId,&quot;jack&quot;, 1);addr.call(&quot;myfunc&quot;, &quot;str&quot;);#設定gas limit與傳輸的eth值addr.call.gas(1000000).value(1 ether)(&quot;myfunc&quot;, &quot;str&quot;);addr.delagatecall.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;) 函數可見性(visibility)參考 public 可被外界使用(預設)(是internal也是external)private 合約內部使用internal - 自己與其繼承合約external 僅供外部合約使用 (內部硬要呼叫要用this.)public用於field可讓編譯器建立訪問器(getter) (array一次僅能get一個元素)(mapping要看key/value的型別)(struct也是看型別)合約內回傳的資料型態較不受限 合約外(external call)通常是基本型沒問題 其他最好使用時測試 因為solidity變化太快 函數屬性標示 payable 只要函數涉及msg.value 就要加payable constant 宣告該函數不需寫資料到區塊鏈 不需身份識別與gas 原本storage變數也不會寫入!!!! 在remix控制台可以看到return值 非constant 即可能需要寫入資料的函數 必須透過event寫receipt 再讀receipt才能debug payable : constant : 宣告該函數不需寫資料到區塊鏈 不需身份識別與gas (或呼叫時加.call()也行) 物件 單位 : ether finney wei時間 : seconds weeks years now (base on block)msg : 與transaction相關的訊息 (sender:發起人 value:交易的ether)address : 一個帳號地址 (用=0x0來歸零) msg : 呼叫函數時以msg帶入呼叫者與一個ehter valuemsg.sender : 代表執行函數的人(在建構函數時就是部署合約的人)msg.vlaue : msg被傳入的etherthis.balance : 合約餘額address.balance : 帳號餘額address.send(amount) : msg.sender送錢到address (方向邏輯有點相反 特別注意)selfdestruct(addr) : 終結合約(結帳) 將合約balance轉到addr web3.js內部如何包裝交易訊息到節點上執行參考參考 //以呼叫此合約函數為例contractInstance.voteForCandidate('Rama', &#123;from: web3.eth.accounts[0]&#125;)//建立交易訊息var rawTxn = &#123; nonce: web3.toHex(txnCount), //txnCount可以是當下的交易總筆數 gasPrice: web3.toHex(100000000000), gasLimit: web3.toHex(140000), to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b', //合約帳號 value: web3.toHex(0), //交易金額 data: '0xc7ed0149'+'52616d61....' //合約函數的hash值的前4byte與參數&#125;;//合約函數的hash值web3.sha3('voteForCandidate(bytes32 candidate)')='0xc7ed014922ff9493a686391b70ca0e8bb7e80f91c98a5cd3d285778ab2e245b3'//合約參數被串接為每個32byte的字串0x52616d610000000000....//將privateKey從字串轉為bytesconst privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')//產生交易物件const txn = new EthereumTx(rawTxn)//簽名該交易txn.sign(privateKey)//序列化const serializedTxn = txn.serialize()//取得交易id (往後以此id查找交易訊息/狀態)transactionId = sha3(serializedTxn)//將serializedTxn傳到任何一個節點即可 (傳到json-rpc??) 模組安全性防禦建議 eth：交易與區塊 net：p2p網絡狀態 admin：管理節點 &lt;危險權限&gt; miner：挖礦 personal：帳戶管理 &lt;危險權限&gt; txpool：交易內存池 web3：包含以上 幣值單位轉換 私有鏈ref 步驟簡述 安裝節點軟體 geth 建立account (keystore) 建立創世區塊 custom_genesis.json 以創世區塊初始化節點 啟動節點 建立nodecd /mychainmkdir node1cd node1#以data目錄做為資料與keystore目錄#產生新帳號(HASH)表示這個node的account(address)(通常會前綴0X)#帳號需要搭配一組密碼geth --datadir ./data account new 建立genesis block的設定 初始化時Clique模式需將授權節點的相關資訊放在Block Header中透過puppeth(CLI)按步驟設定 #回到/mychain目錄puppeth#設定network name為mynet 最後會產生mynet.json#至少先需要設定一個節點(account)做為授權seal的節點 初始化節點 用同一個設定檔init各個節點 geth --datadir node1/data init mynet.json 啟動節點cd node1geth --datadir ./data --networkid 55661 --port 2000 console#networkid : 節點間要有共同的id才能互通(1:主網 2:測試)(預設會進到ether主網絡)#port : 即該節點export出的port 做為入口讓其他節點連結 (非rpc-api的port)(預設30303)#console : 表示啟動進入javascript console提示符號 可進行geth內部的控制#rpcapi 'module' : 開啟某module的rpcapi 允許外部連入(預設僅開eth,net,web3)#rpcaddr : localhost或0.0.0.0表示完全對外開放#rpccorsdomain : 指定rpc僅接受某domain#nodiscover : 取消p2p自動搜尋節點#netrestrict : 限制與之連線的節點在某個子網域#bootnodes : 指定啟動時直接連接某些節點#unlock : 解鎖 所有節點都可以miner.start() 但要先unlock 與其他節點連接 執行geth時帶bootnodes參數 進節點console執行admin.addPeer() 設定./data/static-nodes.json #節點格式 enode://&lt;id&gt;@&lt;ip&gt;:&lt;port&gt;#[::]為IPv6的寫法 可能表示localhost或全零enode://e92fd77c6b2df9daff7ac54473c40d1eef18f63eddbd6fadc2d5fd79a5d957e522348314d6bd63c6919e09bd6b2b5e5616d9b8169ab898946a21d0e06abe08ad@61.66.218.xxx:30303 Kademlia(Kad) : P2P技術 NodeID裡包含路由訊息 節點的分類僅是應用上的定義 實際上每個節點都是一個平等的Account Address eth : 一般的用戶端 例如使用電子錢包的人 miner : 礦工 bootstrap 用來形容一個固定節點 當有新節點加入時就找bootstrap console#取得node資訊admin.nodeInfo#加入節點 (表示可以去連別的節點)admin.addPeer#查看連接的節點admin.peers#開始挖礦 初次啟動會產生dag檔miner.start()#設定挖礦入帳的地址miner.setEtherbase(eth.accounts[0])eth.coinbase #對應到setEtherbase#第三方client通常會以miner(節點)的coinbase的地址做為from進行操作 所以需要時必須對該節點unlock#查詢餘額eth.getBalance("&lt;Address&gt;")eth.sendTransaction #回傳transaction的hash 合約回傳值要用event寫到收據中eth.getTransactioneth.pendingTransactionseth.getTransactionReceipteth.estimateGas #估算交易花費eth.getCode("&lt;Address&gt;") #智能合約編譯後會有一個CODE欄位 如果Account能得到code表示他能執行合約內容#建立合約 (之後還需要用new來deploy)eth.contract(abi);#編譯合約?eth.compile.solidity(source_text)#透過node可以做任何事 (某些要解鎖)personal.newAccount()personal.listAccounts#PoA機制中 授權某節點做為minerclique.propose personal.unlockAccount#將某帳號解鎖 privateKey+passphrese#即輸入密碼從keystore中提取private key 解鎖狀態默認是300秒#駭客只要亂槍打鳥 碰巧遇上解鎖的帳號 就不用密碼也可以下達sendTransactionpersonal.unlockAccount("&lt;Address&gt;")#經測試truffle做部署時 可經由remix的網頁(rpc)做解鎖 也可經由節點本地端(ipc) 也就是說只要節點把account解鎖了 就算不同的client進去也能視同該account已解鎖 eth.getBalanceBalance在區塊鏈中預設就是存在的 除字面上作為財產餘額外 Balance也做為買gas驅動節點運作的籌碼 DAG檔 跟挖礦PoW演算法相關的資料集 據說會越漲越大 到GB等級 IPC 用pipefile實現 讀寫這個檔猶如console打字與畫面輸出結果]]></content>
  </entry>
  <entry>
    <title><![CDATA[區塊鏈]]></title>
    <url>%2Fhome%2F%2FFinTech%2F%E5%8D%80%E5%A1%8A%E9%8F%88.html</url>
    <content type="text"><![CDATA[十分鐘數位加密貨幣課程 Ethereum Wallet 以太幣錢包 區塊鏈代幣平台WAVES區塊鏈原理 ICO(Initial Coin Offering) 以某計畫為基礎 向大眾發起虛擬貨幣的融資 (模仿IPO發股票改發幣)因為區塊鏈的興起 建立虛擬貨幣太容易 加密貨幣 指貨幣機制是經由密碼學等演算法維護 Nonce 一個數挖礦尋找出的一個隨機數可稱為nonce交易時也有一個參數稱nonce 做為總交易的流水號 挖礦難度 尋找一個Nonce能產生HASH值前面產生N個0 (0越多越難找) Hash值通常用SHA-256計算 包含 index+previous block hash+timestamp+data+nonce礦工要找到一個nonce滿足產生的Hash值前N個位數為0 礦池 集結礦工算力 礦場 電費低廉的地方架設礦機 創世區塊(Genesis block) 即第一個區塊 資料 N筆交易-&gt;1筆區塊全部的區塊形成一個帳本(Ledger) Peer節點 一個礦工就是一個節點 主鏈 最長鏈正確性比對大於50% network name 節點網絡名稱 不要跟ip網路搞混 chain/network ID 不明 預設為random 共識機制(勞動證明機制)無論何種共識機制都可能有一個以上的node同時產生block 同時被接到前一block下 出現分歧 挖礦 用來形容以某演算法產生新區塊 (算得慢的node等於做白工) PoW (Proof of work) 即挖礦認證機制/以工作搶快為主耗電ethereum稱為Ethash PoS (Proof of steak) 另一種挖礦認證機制為解決pow耗電不環保的問題 PoA (Proof of Authority) 指定授權某個節點能夠挖礦用seal關鍵字代替挖礦ethereum稱為Clique 分歧導致的問題 使node挖礦效率下降 若分歧持續等量延長 可能表示算法難度或亂數不夠複雜同時挖礦得到的兩個block雖長相不一樣 但內容結果是等效的等待某一分支長過另一分之變成主鏈 模式參考 公有鏈 bitcoin ethereum完全去中心化 透過獎勵機制記帳(PoW) 私有鏈 完全內部節點 但無法竄改資料既然是私有就應該能完全信任 不一定非用上區塊鏈做紀錄 也許分散式資料庫即可 聯盟鏈 適合於機構與機構間 (Proof of Authority)允許更快產生Block 許可鏈 私有鏈 聯盟鏈 都屬於許可鏈 加入的節點 要得到許可 混合鏈 … 電子錢包Mist 是Ethereum的Dapp瀏覽器 也能作為官方的Wallet Ethereum Wallet 同樣是官方Wallet 但就僅是Wallet (Dapp) MEW (MyEtherWallet) 網頁版 https://www.myetherwallet.com/ MetaMask 除了是一個簡單的錢包外，它可以使得Chrome瀏覽器變身成以太坊瀏覽器，讓使用者通過瀏覽器和智慧合約互動情境是:你有一個Dapp網頁供用戶登入錢包 該Dapp無法成為節點操作區塊鏈 所以有兩種方式幫助它 網頁後端有動態伺服器(託管密鑰)像是Truffle(node.js) 對映出api即可 透過MetaMask(託管密鑰)外掛在Chrome上進行登入 網頁js只需應對MetaMask給出的api ParityEthereum (以太坊)(念itSeeRin)用Docker搭建Ethereum網路 一個建立智能合約的平台 同時也是以太幣ETH對應的Project (想像Ethereum是一家公司 以太幣是他發行的股票)智能合約能幫助web或app加入區塊鏈應用 達到Dapp 做出類似區塊鏈的投票機 智能合約 取名有點混淆視聽 其實就是一段程式碼 部署到區塊鏈上 在peer產生實體物件 以該物件作為合約(例如金融帳戶) 可進行合約提供的method(例如轉帳)通常由第三方提供區塊鏈平台(例如Ethereum) 並提供上傳智能合約的機制 便於客製化合約的應用每個peer都能驗證其他peer產生的資料是否依照合約進行執行合約是需要付費給peer的一般合約程式碼需要公開 使參與者知道公平性與共識用Solidity編寫 (類似js)智能合約也視同為一筆Transaction 智能合約開發語言Solidity (類JavaScript)Serpent (類Python)Mutan (類Go)LLL (類Lisp) Account分兩類 Externally Owned Accounts(EOA) : 即人類交易帳號 (Ethereum Account) 主要紀錄的就是balance(餘額)Contract Account : 部署一個合約如同產生一個帳號 該帳號除了balance外 依合約還有了自定義的狀態 由於Account是Hash出來的 重複機率微乎其微 只要有公私鑰就如同有帳戶地址 故能跨不同ethereum網絡使用 但Contract Account不行(why?) EVM (Ethereum虛擬機) 在node上運行 用以執行智能合約的bytecode Transaction (Tx)(交易) 交易一詞由來於設計時以金融交易做為假想 用以表示執行的動作猶如交易機制交易一詞也表示金融交易時需要做同步鎖的機制 與區塊鏈多數認證結果 與失敗的回滾區塊鏈中所有會導致寫入區塊鏈的動作 都稱為交易交易通常帶有一個value值 表示要轉出的金額 Gas 汽油 是一個單位 指node上執行Transaction或智能合約所需的成本gasPrice則是每單位成本 wei/gas願付出多少gas執行可由用戶決定 但可能有out of gas的狀況 (狀態會被回滾) Gas Limit 限制執行合約交易消耗的gas 若達限制交易將失敗用於客戶端節點 : 表示願意付出的gas上限(預扣) 太低會導致沒有節點願意幫忙執行用於執行端節點 : 節點自己控制自己能夠處理事務 避免接到耗時操作用於fallback函數 : 固定有2300gas限制 避免難以結束交易區塊也有一個經由節點共識產生的gas limit用來限制區塊中交易的數量 (即何時開始打包區塊) DApp（decentralized applications） 去中心化應用泛指區塊鏈應用的app 如透過Ethereum平台建立智能合約應用在自己的app上 架構 底層的geth、用solidity寫智能合約、合約在線瀏覽器browser-solidity(remix)、合約錢包Mist/wallet、以太坊的前端開發框架TruffleRPC 遠程呼叫 基於socket 與node連接通常是透過rpc 所以都要有ip:port Geth (節點核心)(念Gets)Geth 由Go語言開發的CLI 用以安裝客戶端RPC API (客戶端應該就是指節點)需要node.js可安裝於多種OS上 Go-Ethereum Geth的project name簡稱Geth因為Geth最核心 事實上還包含其他工具 執行節點(Geth)提供的函數 透過Geth console (本地端適用 不能coding) 透過web3.js (均適用) (走WebSocket) (port:8545) 透過jsonrpc (遠端 無法執行web3.js時) (走TCP基於http?) (port:8545) 透過WebService-RPC (文件規範比較複雜) (port:8546) Truffle（松露） 是以太坊（Ethereum）最受歡迎的一個開發框架一個npm上的cli程式 用來開發自己的錢包(Dapp)包含web3與solc客戶端(web browser)預設有一個react-box的樣板客戶端沒有登入認證系統 需藉由MetaMask Web3.js 以太坊提供的js api, 執行於node.js上js =&gt; Geth RPC (本地端為一個節點 用RPC連本地端節點) Ganache (念甘納許) 前身叫TestRPC用於模擬區塊鏈 生成假的node 有UI畫面預設的port:8545 (示例多用7545)有助記符號(Mnemonic)輔助 (12個單字)(又叫seed phrase) 能替代private key與address remix 官方提供的IDE remix便於編寫智能和約 與呼叫合約方法 abi(Application Binary Interface) 一個.json文件 做為smart contract的介面描述 (裡面有個欄位紀錄bytecode)編譯.sol檔後產生 (npm install solc) Ether 乙太幣有幣值單位 類似K/M/G/T 但以類似人名來表示單位 節點運作概述 每個比特幣錢包都是一個節點,除此之外還有一些是全節點(full node). 全節點負責交易紀錄與驗證及擴散資料. 交易發生時,節點會將交易擴散到節點網路中進行紀錄,待區塊滿載(或??)則開始挖礦產生新區塊. 通常還是要有一些永久性的節點(seed node list) 尤其是初期 待複製出更多節點後 才慢慢式微 節點通常包含四大部分: Network : 找到其他節點 與傳輸接收 Blockchain : 即帳本 Mining : 產生新區塊 Wallet : 保管key與address(帳號) 分兩類 一類必須有完整帳本(full node) 在交易時能確認比對 另一類沒有稱為 SPV nodes 需依靠附近node提供資訊 用戶(Wallet)也是一個node 疑慮節點 一般超過兩個區塊 則成為主鏈 節點上原本就記錄有 持續長大的帳本參考 PSV node : 一個非全節點建立一個乙太幣主鏈(MainChain)的全節點 下載與驗證可能要超過半天 為什麼10分鐘才能產生一個區塊 區塊若同時產生 就會產生另一個分支的鏈 分支中僅有一個能成為最後的主鏈 也就是被刪去的分支上的區塊都是做白工為避免太輕易發生這樣的問題 所以規劃10分鐘產生一個新區塊節點網路需要時間來擴散資料進行比對10分鐘是基於一個數學運算的難度 例如算出前N位為0的hash值 平均算出時間約10分鐘 區塊的產生 規定每10分鐘僅能產生一個區塊規定每個區塊約1MBbitcoin每筆交易約300byte 每秒平均能交易7筆 (tps/transaction per second) 區塊確認 即資料確認寫入半數節點網絡 需要時間確認交易已寫入主鏈 通常以6個區塊做為界定 分支超過6個區塊的機率微乎其微通常提幣系統都會要求6個區塊做保護 也就是60分鐘以Bito來說每筆交易會有一個狀態區分(有入帳但未打勾) 自創貨幣中誰來挖礦? 透過ethereum的主網付Ether幣 或其測試網路真實環境裡自己透過geth 總要有一台伺服器傳達工作給礦工吧? 欲執行任何動作都需要加入節點網路中成為一個節點執行geth即可成為節點產生rpc介面 工作就可以從這裡散播 鏈跟鏈不會衝突嗎? 會 node間分辨彼此所處的鏈(網絡)是依照network id和genesis_hash 誰都可以建只要這兩個一模一樣即表示節點處於同一個鏈 而區塊鏈短的會被更新掉那如果做一個比Ether更長的鏈 放到公眾網路上是否就能覆蓋其他節點的區塊鏈??? 其他p2p的UDP打洞 AB兩節點若在NAT下沒有export對外的port號 則無法互相連接 AB先都連上S 連接的過程NAT會分配port讓AB對外做請求 此時AB都有特定的port了 但對象都是S S得知雙方ip:port 由S仿冒A:port向B:port騙過NAT 之後A就能連B了 FileCoin 一家公司 以區塊鏈技術為基礎儲存檔案(切割小份) IPFS : 欲取代http中對於檔案通訊協定 歷代p2p NodeServer : 所有節點必須透過NodeServer登記與取得其他節點位置 單點故障就斷鏈 Boradcast : 造成廣播風暴 DHT : 分散式HashTable 去中心化 NodeID裡包含路由訊息 歷代區塊鏈 比特幣 乙特幣 超級帳本 Fabric 冷錢包 即硬體錢包 將私鑰匯出到硬體(usb)裝置上 完全移除網路上的私鑰 BitoEx 幣託-比特幣錢包BitoEx 台灣廠商 用email申請一個帳號 透過web/phone介面查詢台灣可透過FamiPort繳費&gt;虛擬帳號&gt;廠商代號&gt;輸入手機號碼&gt;買多少台幣的BTC 現金結帳取得收據與手機簡訊 回BitoEx介面&gt;超商兌換可綁定信用卡/銀行帳號(可出帳)等於私鑰託管給BitoEx https://www.bitoex.com/ MaiCoinMaiCoin 同BitoEx 台灣廠商 Coinbase 同BitoEx 但更大更全球化可綁定信用卡/銀行帳號/paypal 或用wire transfer 圖靈完備 圖靈機(Turing machine)是早期的一種紀錄資料的機器 可以無限紀錄與擦除在程式語言上通常指擁有if/for/recursive功能 能達成任何演算法 公私鑰 RSA 公鑰加密私鑰(收) 或 私鑰加密公鑰(送)被公鑰加密的東西 通常是給自己看的 只有自己能用私鑰解被私鑰加密的東西 通常是用來給別人驗證自己身份的 任何人拿我公鑰解出特定的內容 表示內容肯定是我的 數字簽名 Docker AWS | Amazon Elastic Container Service]]></content>
  </entry>
  <entry>
    <title><![CDATA[電子支付]]></title>
    <url>%2Fhome%2F%2FFinTech%2F%E9%9B%BB%E5%AD%90%E6%94%AF%E4%BB%98.html</url>
    <content type="text"><![CDATA[FinTeck支付行為詳解 EMVco 國際晶片卡組織 初期由EuroPay + MasterCard + Visa共組發佈信用卡代碼化(Tokenization)標準 也是HCE的核心架構 發卡組織(International Association) 由銀行共同成立 如VISA/MasterCard/JCB/中國銀聯本身不發行信用卡 算是提供支付網路/收單/清算 由其會員銀行(發卡機構或發卡銀行)發卡賺取跨國交易手續費 發卡機構(發卡銀行)(Issuer) 指實際發行信用卡的單位 通常是銀行手續費約佔75% 特約商店 即加入諸如VISA/MasterCard支付網路的商家通常需支付2~3%的手續費給收單機構再分配給整個供應鏈 清算中心(跨行) Interbank Card Center(BKM) 負責在收單機構與發卡銀行(跨行)間整合、交換交易紀錄的組織如VISA/MasterCard/台灣的NCCC都能擔任此角色手續費約佔2.5% NCCC(National Credit Card Center of R.O.C.) 聯合信用卡處理中心是中華民國一家處理信用卡交易的非營利組織收單/清算 負責信用卡交易請款扣帳訊息的交換與傳送 收單機構(Acquirer) 刷卡機的提供者 通常是發卡銀行第三方支付通常要尋求收單機構配合 (第三方支付的角色在此)手續費約佔22% 聯名卡(co-branded credit card) 即信用卡 僅因與特定商家合作 刷卡能取得些許回饋 行動支付 線上 網路購物(線上) 行動支付 近端支付 超商NFC(線下) / 商店BarCode(線上) NFC（Near Field Communication） 近場傳輸 感應式讀卡機 (NFC Payment) Visa Wave 與 Master PayPass刷卡上限約超過3000需簽名 刷卡流程 消費者(Cardholder)欲付1,000 商家(Merchant)進行交易 傳給收單機構(Acquirer)並被抽25元 若跨行需再透過清算機構(BKM) 並支付25的2% 若跨國再透過國際發卡組織(VISA/MasterCard...) 並支付? 最後支付25的75%給發卡銀行(Issuer) 支付模式TSM(Trusted Service Manager) 信託服務管理平台 須向電信公司申請將SIM卡換成USIM卡 再向銀行臨櫃申請綁定信用卡 優點:無需網路 USIM如同信用卡 硬體晶片加密(Secure Element) 難以普及 淘汰 HCE(Host-based Card Emulation) 主機卡模擬 Apple/Sumsung/Google/t wallet+ 需預先取得真實卡號對應的token來進行交易 與POS機之間通常以NFC交互token 基本上由app主導支付機制 安全性由app控制(解鎖/密碼/指紋等) 可短暫離線 但通常有安全機制 例如1小時內有效 BarCode Line/街口/支付寶AliPay/歐付寶AllPay改O’Pay(台灣) 不需NFC 可離線支付 但通常有安全機制 例如10分鐘內有效 HCE流程 以Tokenization技術認證持卡人 而不用將真實卡號透露給商家或其他組織發卡銀行必須付手續費給Apple或Google 因其替代了信用卡進而促成交易 取得Token流程 (Visa Token) 安裝app 輸入信用卡號 送向Token Requestor(即Apple或Google等app提供者) 再轉向TokenServiceProvider(發卡組織 如MasterCard或Visa)產生Token 最後將卡號與Token送到發卡銀行 發卡銀行主動傳送Token給app, app必須解出該token已達到認證 並將之前輸入的卡號刪除 支付流程 傳送Token給商家 通常經由NFC/Bluetooth/BarCode/MST(磁條) 商家將Token傳給收單機構再傳給清算機構 清算機構將Token傳給TokenServiceProvider做真實卡號的解碼 再回傳Acquirer收單機構(發卡銀行)與NCCC(聯合信用卡處理中心/清算機構) 第三方支付 與行動支付的差別在於 第三方支付類似代理收單平台提供一手交錢一手交貨的保障 向會員或購物平台收取手續費通常需綁定信用卡 或儲值(或匯款) 建立一個money buffer 即電子錢包相對於Tokenization技術 信用卡的安全是比較有疑慮的 故在台灣發展受限 微信 付款情境1 : 在路邊購物 商家提供QRCode做為收費帳號的連結 買家掃描該QRCode進入付費頁面 決定付費金額 付費 (金額自己決定) 付款情境2 : 在便利商店 買家主動提供自己帳號的QRCode/BarCode做為付費帳號的連結 商家用掃條碼及完成付費 (金額商家POS機決定) 電子票證 儲值支付 雖同為第三方支付 但以電子票證發行管理條例來規範悠遊卡(EasyCard)一卡通(iPass)iCash(統一集團)happycash(遠東集團) ???掃碼式接觸式手機信用卡SIM卡需改為USIM卡 經由官方]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2Fios%2FUI.html</url>
    <content type="text"><![CDATA[Xcode 即Objective-C或Swift語言的編輯器(IDE) Interface Builder 即Xcode中用來編輯UI畫面的功能 簡稱ib .nib檔 即ib編輯後的存檔 以物件序列化存成檔案 .xib檔 同樣是ib的存檔 但以xml格式儲存 尚未序列化 到最後編譯時才再轉成nib檔 StoryBoard 取代IB 並能以圖形介面連結各個ui畫面的功能 用於做畫面navigation 教學朱克剛 auto layout 指設定constraint layout用此模式設定(限制)佈局的位置與大小取代以往的auto resizing模式 ViewController 如同Android的Activity IB前綴 即Interface Builder UI前綴 如同Android的View前綴 OutLet 指一個View映射到一個變數上 Action 指View Event與function的對應 例如click… Computed Property 類似於Java Property的getter 能取值時即時運算回傳 ViewControllerviewWillLayoutSubviews 螢幕轉向時會呼叫 IBSuperViewSafeArea 用於對齊UI 類似對齊線(區塊 同時具有垂直水平)取代Top Layout Guide 和 Bottom Layout Guide StackView 類似於一個group 並無實際的UI CollectionView]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FAndroid%2FLocation.html</url>
    <content type="text"><![CDATA[經緯度 Google地圖v2 Google Maps API 申請 畫路徑圖xml格式json格式 權限&lt;uses-permission android:name="android.permission.INTERNET" /&gt;//以GPS定位 GPS_PROVIDER&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;//以網路定位 NETWORK_PROVIDER&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; 座標 SDK Manager必須安裝Google Play Services implementation 'com.google.android.gms:play-services-maps:15.0.0'//for LocationServicesimplementation 'com.google.android.gms:play-services-location:15.0.0' mGoogleApiClient = new GoogleApiClient.Builder(this) .addConnectionCallbacks(this) .addOnConnectionFailedListener(this) .addApi(LocationServices.API) .build();//onResume 與 onStop間重新建立mGoogleApiClient.isConnected()mGoogleApiClient.connect();mGoogleApiClient.disconnect();//after connected 單次取得Location loc = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);//after connected 多次取得locationRequest = new LocationRequest(); locationRequest.setInterval(1000); locationRequest.setFastestInterval(1000); locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);LocationServices.FusedLocationApi.requestLocationUpdates( googleApiClient, locationRequest, this);@Overridepublic void onLocationChanged(Location location) &#123;&#125; 地圖map = ((SupportMapFragment) getSupportFragmentManager(). findFragmentById(R.id.map)).getMap(); latLng = new LatLng(loc.getLatitude(), loc.getLongitude());//建立標記map.addMarker(new MarkerOptions().position(latLng));marker.setPosition(latLng); Geocoder 地名轉location設定標記BitmapDescriptor icon = BitmapDescriptorFactory.fromResource(R.drawable.ic_launcher); MarkerOptions markerOptions = new MarkerOptions() .position(place) .title(title) .snippet(snippet) .icon(icon);map.addMarker(markerOptions);map.clear(); animateCamera畫圖導航]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FAndroid%2FBlueTooth.html</url>
    <content type="text"><![CDATA[BlueTooth啟動藍牙&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt; adapter = BluetoothAdapter.getDefaultAdapter();if (adapter != null)&#123; if (!adapter.isEnabled())&#123; Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, REQUEST_ENABLE_BT); &#125; Set&lt;BluetoothDevice&gt; devs = adapter.getBondedDevices();&#125;//adapter.disable(); 啟動藍牙可見性&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt; intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); //300秒startActivity(intent); 掃描周圍藍牙設備設備//adapter如同本地的bluetooth裝置adapter = BluetoothAdapter.getDefaultAdapter();//以intent要求掃描adapter.startDiscovery(); //must check permission adapter.cancelDiscovery();//以broadcast receiver進行設備的接收intent_filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);intent_filter = new IntentFilter(BluetoothDevice.ACTION_STATE_CHANGED);receiver = new CustomReceiver();registerReceiver(receiver, intent_filter);class CustomReceiver extends BroadcastReveiver&#123; public void onReceive(Context context, Intent intent)&#123; if (intent.getAction().equals(ACTION_STATE_CHANGED))&#123; state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, ERROR); //OFF //TURNING_OFF //STATE_ON //TURNING_ON &#125; if (intent.getAction().equals(ACTION_SCAN_MODE_CHANGED))&#123; mode = intent.getIntExtra(EXTRA_SCAN_MODE, ERROR); //CONNECTABLE_DISCONVERABLE //CONNECTABLE //NONE //CONNECTING //CONNECTED &#125; &#125;&#125;//藍芽需要的危險權限void checkPermissions()&#123;//ACCESS_FINE_LOCATION : GPS定位//ACCESS_COARSE_LOCATION : 粗估位置 if (Build.VERSION.SKD_INT &gt; Nuild.VERSION_CODES.LOLLIPOP)&#123; int check = this.checkSelfPermission("Manifest.permission.ACCESS_FINE_LOCATION"); check += this.checkSelfPermission("Manifest.permission.ACCESS_COARSE_LOCATION"); if (check != 0)&#123; requestPermissions(new String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION&#125;) &#125; &#125;&#125; 配對 Pair可取得對方的藍芽的name/class/address配對後的裝置(paired)之後就會記錄在系統不用再配對 if (intent.getAction().equals(ACTION_BOND_STATE_CHANGED))&#123; device = intent.getParicelableExtra(BluetoothDevice.EXTRA_DEVICE); state = device.getBondState(); //BONED //BONDING //NONE&#125;if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN_MR2)device.createBond();adapter.getBondedDevices()//用address即可取得特定的deviceadapter.getRemoteDevice(address) 資料交互ref透過類似socket的作法 主動建立連線 (client side)似乎會自動進行bond配對 socket = device.createRfcommSocketToServiceRecord( UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));socket.connect(); //阻塞 等待server回應 被動等待連線連入 (service side)serverSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord( Bluetoothprotocol.PROTOCOL_SCHEME_RFCOMM, UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));socket = mserverSocket.accept(); //阻塞 等待client連接 讀寫socket.getOutputStream(); //寫資料socket.getInputStream(); //讀資料socket.close(); //切斷連線 多樣性資料續用一個socket傳遞ref 自定義格式 (hearder+size+checksum+payload)用DataOutputStream(OutputStream os)以便處理 Beacon 類似一個廣播器 低功耗藍牙技術 多台beacon可作精準的室內定位一個類似RFID的應用 利用bluetooth連接 例如商店內置放一台beacon 用戶手機有安裝對應app 當用戶接近beacon就得以連線 app就會連接雲端 做GCM/FCM推播內容給app Bluetooth4.0 BLE技術 (Bluetooth Low Energy) BLE設備大致分為中心(Central)和週邊(Peripheral) 周邊設備不斷地發出廣播封包告知存在 中心設備則掃描接收廣播 NFC（Near Field Communication）ref 基於RFID而發展 高頻距離短(也就更安全)建立P2P通訊 也能與藍芽建立P2P能用於交互(門禁、公車、手機支付)NFC強調的是P2P間信息的交互 而RFID僅是主從間狀態的讀取 RFID與NFC之間的區別悠遊卡與RFID 高頻 : 電磁感應 距離短 數10公分 RFID（Radio Frequency Identification）videoref 主要用於訊息的讀取與判定IC卡運作的電流經由環境(讀卡機)提供其應用在於ID二字(悠遊卡/ETC(超高頻)/eTag/寵物晶片/防盜標籤/VISA WAVE) 可近可遠 低頻/高頻/超高頻(微波 距離長 十數公尺)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FAngular.html</url>
    <content type="text"><![CDATA[interface NgModule &#123; providers : Provider[] declarations : Array&lt;Type&lt;any&gt;|any[]&gt; imports : Array&lt;Type&lt;any&gt;|ModuleWithProviders|any[]&gt; exports : Array&lt;Type&lt;any&gt;|any[]&gt; entryComponents : Array&lt;Type&lt;any&gt;|any[]&gt; bootstrap : Array&lt;Type&lt;any&gt;|any[]&gt; schemas : Array&lt;SchemaMetadata|any[]&gt; id : string &#125; providers : 服務類型 其類型會被建立成一個singlton供各元件進行注入 entryComponents : 與route有關 也與編譯有關 當一元件做為入口元件但沒加到route中時就要在這裡宣告 編譯器才會編入 否則可能tree shake時就被移掉了 declarations : 主要用來宣告會用到的Component 以及連帶用到的Pipe與Directives imports : 元件或服務或其他用於該NgModule中的類型 所需要用到額外的類型或Module (ngmodule屬於angular的應用層面 其import是為了編譯出完整的app 而ts的import是屬程式語言的層面 兩個編譯屬不同層次) bootstrap : 首先被啟動的Component]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2Fios%2FThread.html</url>
    <content type="text"><![CDATA[線上讀書會 景隆 主講 swift GCD pThread : 如同c 在OC中使用NSThread[NSThread alloc][NSThread detachNewThreadSelector] //同前面 但直接執行[self performSelectorInBackground] //切到background執行[self performSelectorOnMainThread] //切到main thread執行 GCD (Grand Central Dispatch)包裝NSThread dispatch_async(global_queue, ^&#123;&#125;)dispatch_async(main_queue, ^&#123;&#125;)//^&#123;&#125;為OC的block 類似匿名函數//建立queuedispatch_queue_create("id", SERIAL/CONCURRENT) //早期寫法dispatch_async(dispatch_global_queue, &#123; ()-&gt;Void in //...&#125;)//後期DispatchQueue.global().async &#123; Thread.sleep(5) //以秒計&#125;DispatchQueue.global().sync &#123;&#125; //保護其內部為sync與atomicDispatchQueue.main.asyncAfter(deadline:DispatchTime.now()+2)&#123;&#125;let queue = DispatchQueue("myqueue") QoS (優先權) high : .userInitiated default : .default low : .utility background : .background DispatchGrounp可合併多個dispatch let group = DispatchGroup()let queue = DispatchQueue("download")queue.async(group) &#123; Thread.sleep(10)&#125;group.notify(queue: .main) &#123; print("done")&#125; NSOperation]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FSwift.html</url>
    <content type="text"><![CDATA[玩兒轉Swift（第一季） 玩兒轉Swift（第二季） 玩兒轉Swift（第三季） 玩兒轉Swift（第四季） ref android轉ios Android與Swift iOS開發：語言與框架對照 線上 swift 讀書會 委託模式（Delegate） java的interface宣告在ios中稱為protocol 而delegate用來形容一個protocol是一個用以委託的介面 例如實作UIApplicationDelegate這個protocol者 就能被UIApplication委任一些工作 其實就是interface的應用 只是觀點比較高 形容一種設計模式 啟動Runloop static mianUIApplication 通常使用預設(nil) 會建為單例 如同android中的contextAppDelegate 生命週期的委託處理 如同android中的applicationUIApplicationMain(argc, argv, UIApplicationClassName, AppDelegateClassName) 變數//中括號[]的可能性//1.宣告陣列var array2: [Int] = [1, 2, 3]//2.宣告Dictionary (即Map或稱key value pair)var pair = [String: Int]()pair["a"] = 1pair = ["a":1, "b":2]pair = [:] //清空 用_(underline)忽略宣告或值 nil是一個特殊的類 不能當作0或false let x=0 //宣告常數var x:Int? //宣告變數var x:Int &#123; return 0 &#125; //lazy loading//tuples (類似一個匿名的類)var x = (a:1, b:2)var x:(Int,Int) = (1,2)var (a,b) = x //解構var (a,b) = (1,2) //解構var (_,b) = (1,2) //忽略某部分//native arrayvar array1 = [1, 2, 3]var array2: [Int] = [1, 2, 3]var array3: Array&lt;Int&gt; = [1, 2, 3]var arr = [String]()var arr = [Int](repeating: 0, count: 10) //10個元素 初值為0let closure:(Int, Int)-&gt;Int = &#123;$0+$1&#125; //宣告閉包block$0 //可代表'匿名closure'的第一個參數 (即&#123;&#125;內沒有`in`關鍵字)//computed property 定義一個類別繼承自Int 自動拆箱 (結果同Java的getter)var x: Int&#123;&#125; typealias 類型別名typedef int MyInt; typealias MyInt = Int &amp; 安全溢出var x = Int.max &amp;+ 1 //overflow不會報錯 Rangelet r: Range = a...bin a...b //閉合 包含abin a..&lt;b //半閉合 包含a不包含bin arr[0..&lt;arr.count] 賦值運算沒有返回值//Objective-Cint a = b = 10 //10指派給b 再把b(左邊運算元)指派給a//swift不能這樣寫 閉包arr.map &#123; (num:Int) in return num&#125;arr.map &#123; num in num&#125;arr.map &#123; _ in 0&#125;arr.map &#123; $0&#125; 可選型(Optional)沒有可選型前 所以變數參考都可以指到null 有可選型後 預設是禁止變數指到null的 若一定要指到null則表示該變數是不穩定的 不是一定有值的 該變數就需要宣告為可選型 宣告變數時用!的時機 : 該變數無法立即被初始化 但之後(被讀之前)一定會初始化 使用變數時用!的時機 : 肯定該變數不會是空值 但若仍出現空值就該拋出異常 var str:Int? = "str" //可選型var str:Int! //隱性可選型 即該變數在使用前一定會賦值 通常用在建構時的變數var str2 = "what " + str! //強制對可選型解包if let str = str, strN = strN where strN="N"&#123; //可以解包&#125;else&#123;&#125; //無法解包//optional chainingstr?.uppercaseString //安全導航str!.uppercaseString //強制導航 (kotlin用!!.)var x = getStr() ?? "" //如同kotlin的Elvis Operator ?:var x = try? getNum() //使getNum()不報Exception 但x可能是nullvar x = try! getNum() //使getNum()不報Exception 且一定能得到回傳 String.Index 以Unicode算字數(即所見字數) str.countstr[idx]其中idx必須為String.Index類型 不能用整數當索引操作string通常搭配String.Index與Range let sIdx:String.Index = str.startIndexlet sIdx:String.Index = str.endIndex //(值相當於 是str.count)String.advencedBy(offset) // 移動String.Index.predecessor() // 前一個String.Index.successor() // 後一個str_ = str[sIdx..&gt;eIdx] NSString 物件型的String以byte算字數str.length NSString(format: "ttt %.2f". 1.0/3.0) as String 變數觀察者var x = 0 &#123; willSet(newX) &#123; &#125; didSet &#123; if x &gt; oldValue ... &#125;&#125; 型態基本資料型態 除一般來說primitive type外enum/struct/String/Array/Set/Dictionary都是基本資料型態大都以struct實作其賦值操作時是以值得複製進行 而非參考位置的複製 物件參考型態 一般的物件 或大部分NS開頭的物件 流程控制 一定要有花括號 if中必須為bool值 (不會自動轉bool)(1/0不會轉true/false) switch case間會自動break 或用fallthrougt才能接到下個case //條件式不用小括號if true &#123;&#125;if let x=getSome() as? String &#123;&#125;//類似if 但語意更清楚guard let x=getSome() &#123;&#125;var value = 1var value = (1,1)switch value &#123; case 1: case 2,3: case 5...10: case (0,1...10): case (_,1): case (let x,1): case let(x,y): case let(x,y) where x==y: fallthrough //後面的case不能再有let定義變數 default:&#125;//if case whereif case 1...10 = age where age&gt;5&#123;&#125;//for casefor case let i in 1...10 where i%2==0&#123;&#125;//指定退出的for迴圈tag : for _ in 0...10&#123; break tag&#125; 函數func sayHi(name:String, arr:[Int]) -&gt; Int&#123; println("Hi, \(name)")&#125;var fun = sayHi //函數可當變數//返回值可用tuplesfunc point(name:String) -&gt; (a:Int,b:Int)&#123; return (0,0)&#125;//外部參數 (供caller辨識參數定義)func who(student_name name:String, _ age:Int=20)&#123;&#125;who(student_name:"Jim") //若有定義外部參數則一定要寫//內外部共用參數名func who(#name:String)&#123;&#125;//inout 傳referencefunc test(let v1:Int, var v2:Int, v3:inout Int)&#123; //v1:預設用法 v2 = 1 v3 = 1 //改變caller變數&#125;var v1=0,v2=0,v3=0test(v1, v2, &amp;v3) //v3會被改變 swap技巧func swap(a:inout Int, b:inout Int)&#123; a = a + b b = a - b a = a - b&#125;func swap(a:inout Int, b:inout Int)&#123; a = a ^ b b = a ^ b a = a ^ b&#125;//xor : 不一樣時為1 可想像成取沒重疊的部分// 3 ^ 4 : 0011 ^ 0100 = 0111 = 7...a// 7 ^ 3 : 0111 ^ 0011 = 0100 = 4...b// 7 ^ 3 : 0111 ^ 0100 = 0011 = 3...a 類別class Fruit&#123; func desc()&#123; println("...") &#125;&#125;class Apple:Fruit&#123; var name:String //constructor override init(name:String)&#123; super.init() self.name = name &#125; //使能建構一個可能為nil的物件 init?(type:Int)&#123; if type==0 &#123; return nul &#125; &#125; override func desc()&#123; println("...") 10.times &#123; //Trailing Closure (尾端型態是block/lambda) print(".") &#125; &#125;&#125;//延伸類別的methodextension Int &#123; func times(block:()-&gt;())&#123; // Trailing Closure for _ in 1...self&#123; block() &#125; &#125;&#125; Designated initializers : 指子類自己的init() 可以有多個(即多載) (通常前綴override複寫父類) 也只有這裡能super.init() Convenience initializers : 指次要的init() 其內部一定要叫用Designated initializers enum / structstruct 可以有field 與 method 沒有繼承 沒有型別轉換 沒有init/deinit函數 enum Cmd : String&#123; case Add = "add" case Sub = "sub"&#125;cmd = .Add //自動搭配cmd.Addstruct Res&#123; var width = 0 var height = 0 mutating func test()&#123; //加mutating後此func才能更動結構成員 &#125;&#125;//struct的使用上如同原生型態 如a = 3b = a //a的值複製給b, a與b雖然相等但各自有各自的值 (struct也是如此狀況)b = 10// a=3 b=10]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2F%E6%97%A5%E8%AA%8C.html</url>
    <content type="text"><![CDATA[180412好用畫圖工具 FireAlpaca]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2FArts.html</url>
    <content type="text"><![CDATA[區塊鏈MapRunnerGitHub 以兩隻手機模擬 跑步機與行動裝置 間的互動情境 模擬跑步機 等待藍芽裝置連入連入後 開始定位 並透過google api下載行進路線 (終點預設為’台中火車站’)開始位置移動的模擬 並傳送給手持裝置 模擬手持裝置 搜尋與連接藍芽裝置連接後 開始接收移動位置 顯示於地圖 並寫入資料庫 Kotlin / Room / Retrofit 畫面翻轉狀態保留 以Sketch繪製與切版 自定義View(儀表板) 加減速指針動畫 TSNoteGitHub / Google Play 多國語言 有聲 翻譯 筆記 Kotlin / Dagger LangStarGitHub / Google Play / 線上web版本 語言單字學習 類似單字卡的分享平台 以Ionic開發的Hybrid App 後台用Firebase 包含social login 以標籤機制區分各國語言與內容 過往操作可離線使用 WOVOGitHub / Marketplace 一個VSCode的Extension 股票程式化分析軟體 能夠即時編譯腳本程式 用以繪圖或分析選股或執行程式交易接收DDE或券商提供之API做即時報價與委託交易 Java 僅能於window平台執行 免安裝下載 官網連結]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hybrid App Architecture]]></title>
    <url>%2Fhome%2F%2FSingle%2FHybridAppArchitecture.html</url>
    <content type="text"><![CDATA[Cordova其前身稱為PhoneGap 做為JavaScript Bridge 實現JS介接Native Libraryref WebView 使用WebView意味著看到的ui元件不是native元件構建而成 而是透過webview畫出 (應該也沒有寫NativeView的必要了) WebView有分原生的或Cordova的跨平台WebView Plugin大致寫法類似用xml(metadata)分別設定android與ios 並分別實作api對應的native程式(繼承CordovaPlugin) 最後實作一個js object對應該api 透過WebView叫用api (之後再自行封裝成類別形式)cordova.exec(success_callback, error_callback, feature_classname, action_str, args); React NativeReact Native 航向真全端，建構雙平台 App /Native UI Components / 菜鳥窩React Native 從零到高級 只有JS Engine 沒有WebView 意味著web的ui元件實現須對應到native的ui元件上 實作比較辛苦 但執行比較快]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2FSort.html</url>
    <content type="text"><![CDATA[ref 泡沫排序 倆倆比較 將大的往後推(交換) 每一輪結束最大的一定推到最後一個(排好一個) 所以下一輪就少推一個 優化: 若其中一輪完全沒有交換 表示已經完成排序 public static void bubbleSort(final int[] nums) &#123; for (int i = nums.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; final int next = j + 1; if (nums[j] &gt; nums[next]) &#123; final int buffer = nums[j]; nums[j] = nums[next]; nums[next] = buffer; &#125; &#125; &#125;&#125;static void test1() &#123; int[] arr = new int[]&#123;3, 17, 63, 27, 9, 15, 2, 6&#125;; System.out.println(Arrays.toString(arr)); bubbleSort(arr); System.out.println(Arrays.toString(arr));&#125; 交換排序 從第一個位置開始 與之後的每個位置比較 交換出最小的 一輪比完再進行下個位置 public static void exchangeSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; final int buffer = nums[j]; nums[j] = nums[i]; nums[i] = buffer; &#125; &#125; &#125;&#125; 選擇排序 (交換排序法的優化) 如同交換排序 只是記住最小值的索引位置 於當輪結束時交換 public static void selectionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; int k = i; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[k] &gt; nums[j]) &#123; k = j; &#125; &#125; if (k != i) &#123; final int buffer = nums[k]; nums[k] = nums[i]; nums[i] = buffer; &#125; &#125;&#125; 插入排序 記住第i個位置的值(tmp) (準備把tmp往左插入到正確位置)開始往左比 一路把大於tmp的值往右推 直到找小於tmp的位置 再執行下個循環 public static void insertionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length; ++i) &#123; final int tmp = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; tmp) &#123; nums[j + 1] = nums[j--]; &#125; nums[j + 1] = tmp; &#125;&#125; 快速排序 採分治法(Divide and Conquer) 找一個中間數(pivot)將 並使其歸於正確位置(左小又大) 左右邊再各自做一次同樣的循環 public static void quickSortRecursive(final int[] nums, final int start, final int end) &#123; final int x = nums[start]; // 將start位置的值設為pivot int l = start + 1; //所以start+1是最左的元素 int r = end - 1; //end因為是length 所以要減1 while (true) &#123; //從右邊往左 找到小於pivot的位置 while (r &gt; start &amp;&amp; nums[r] &gt;= x) &#123; --r; &#125; //從左邊往右 找到大於pivot的位置 while (l &lt;= r &amp;&amp; nums[l] &lt;= x) &#123; ++l; &#125; //若l&lt;r表示尚未巡完整個array 就已需要交換 if (l &lt; r) &#123; final int buffer = nums[l]; nums[l] = nums[r]; nums[r] = buffer; &#125; else &#123; //lr巡完表示pivot的位置就在其交會點 if (r &gt; start) &#123; final int buffer = nums[r]; nums[r] = nums[start]; nums[start] = buffer; &#125; break; &#125; &#125; final int ls = start, le = r; final int rs = r + 1, re = end; final int ll = le - ls, rl = re - rs; if (ll &gt; 1) &#123; quickSortRecursive(nums, ls, le); &#125; if (rl &gt; 1) &#123; quickSortRecursive(nums, rs, re); &#125;&#125;quickSortRecursive(array, 0, array.length); 合併排序```排序======```java 排序```排序======```java 排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Collection]]></title>
    <url>%2Fhome%2F%2FJava%2FCollection.html</url>
    <content type="text"><![CDATA[ref ref 類型 Collection 一無序物件群體的介面 Set 一無序物件群體 元素無法重複(會覆蓋) 沒有索引沒有get方法 因爲沒有key的概念 僅存放value(或稱element) 用iterator遍歷HashSet為常用的實現 或可排序的TreeSet List 一有序物件群體 元素可重複 有數字索引 能get(idx) Map 鍵值對 (Key-Value pair) (entrySet) 結論 要數字索引 : List (ArrayList) (CopyOnWriteArrayList) 有Key-Value關聯 : Map (HashMap/LinkedHashMap) (ConcurrentHashMap) 單存放置一群物件 : Set (HashSet) 要隨時排序 : TreeMap 基本上如此 但技術演變很快 類別也會出現變形 concurrent(指多thread能夠同時存取) 意味 thread-safe 遍歷HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();//keysetfor (Object k : map.keySet())&#123; System.out.print(k + " ");&#125;//entrysetfor (Map.Entry entry : map.entrySet()) &#123; System.out.print(entry.getKey() + " ");&#125;//iteratorIterator entries = map.entrySet().iterator();while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry)entries.next(); System.out.print(entry.getKey() + " ");&#125; 測試發現 : HashMap與Hashtable 遍歷時都是沒有規律的 實現類實現解說 HashMap (ConcurrentHashMap) 以hashcode為key (null也有其hashcode)速度快,遍歷時無序的(非照put時機或key值排列)非thread-safe, multi-thread資料可能異常,但有ConcurrentHashMap可以替代,或Collections.synchronizeMap(map)使其thread-safe需要預留較大的array空間(對應每個hashCode) 資料量不多時划不來以一個hash值為索引的array其每個元素對應到一個list 當list長度超過8則改為紅黑樹(自平衡二元樹) Hashtable thread-safe, 慢繼承Dictionary較早的技術 建議用HashMap取代 LinkedHashMap (小資料量的通常的選項) 繼承HashMap (應該是以雙向鏈取代固定size的array)遍歷時是依照put順序的較慢 但啟動較省空間 在資料不多時 不見得比較慢 EnumMap 以enum為鍵 意即使用時就已知最大容量 通常會較快 TreeMap 實做SortMap介面遍歷預設依照key值的升序排序 可以自訂Comparator WeakHashMap 弱參考 可做自動回收的快取 HashSet 以HashMap實現即以Object的hashCode為key 本身為值 故同樣的hashCode無法對應兩個值 即不會重複 map.put(key, new WeakReference(value)) Arraysint[] ints = new int[10];Integer[] ints2 = new Integer[10];List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); 固定長度 可放原生類型透過java.util.Arrays工具類延伸操作 ArrayList 元素為連續排列 但能動態調整大小(會預留空間) 從刪除或插入會造成比較大的開銷get/set能透過索引算出 快add/remove需要移動整個右邊元素 慢 LinkedList 以雙向鏈(node)實現Listget/set需透過node遍歷 慢add/remove直接調整左右節點即可 快 (節點不在最前最後時要先遍歷找到節點) Iterator (迭代器)用於遍歷Set與List元素 類似一個for loop (Map的遍歷透過其EntrySet) ListIterator : 可雙向 fail-fast : 操作集合會累加modCount以示集合出現更動 若迭代時出現更動會拋出異常java.util.ConcurrentModificationException 算是一種偵錯機制 fail-safe : 迭代時複製一分參考清單 該清單無人能更動 自然就能確保迭代期間是完整的 但期間若真有異動也無法即時反應 Stream (流)類似以loop方式每次推送一個元素到function中操作 透過各式操作符一層一層完成以往for loop的工作 parallelStream : 以並行(切割任務)方式處理流 同步Map map = Collections.synchronizedMap(new HashMap()); JDK集合實現List//Single-threadedArrayList – 基於數組的泛型LinkedList – 請勿使用Vector – 已棄用//ConcurrentCopyOnWriteArrayList – 極少更新，常用於遍歷 Maps//Single-threadedHashMap – 泛型映射EnumMap – 枚舉鍵Hashtable – 已棄用IdentityHashMap – 用== 對比的鍵LinkedHashMap – 保持插入次序TreeMap – 有序鍵WeakHashMap – 有益於緩存//ConcurrentConcurrentHashMap – 泛型並發映射ConcurrentSkipListMap – 有序並發映射 Sets//Single-threadedHashSet – 泛型集合EnumSet – 枚舉集合BitSet – bits/dense 整型集合LinkedHashSet – 保持插入次序TreeSet – 有序集合//ConcurrentConcurrentSkipListSet – 有序並發集合CopyOnWriteArraySet – 極少更新，常用於遍歷 Queues / deques (隊列/雙隊列)//Single-threadedArrayDeque – 基於數組的泛型Stack – 已棄用PriorityQueue – 有序檢索操作//ConcurrentArrayBlockingQueue – 有界阻塞隊列ConcurrentLinkedDeque / ConcurrentLinkedQueue – 無界鍊式隊列(CAS)DelayQueue – 由延遲元素構成的隊列LinkedBlockingDeque / LinkedBlockingQueue – 可選有界鍊式隊列(locks)LinkedTransferQueue – 可傳輸元素且不進行存儲PriorityBlockingQueue – 並發PriorityQueueSynchronousQueue – Queue 接口的交換器]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 增訂]]></title>
    <url>%2Fhome%2F%2FJava%2FJava8Explained.html</url>
    <content type="text"><![CDATA[Lambda 箭頭函數lambda是一個java8開始的新語法 類似於javascript的箭頭函數 因應functional programming而生 可以將箭頭函數想像成一個”只有一個method的object” 就會比較容易理解 看/用起來像function但其實是一個object 因為只有一個method所以method的name就不重要了 object即等同method 為什麼要這樣?因為java的method不能像變數一樣當作參數 要傳函數勢必只能整個object傳入 而箭頭函數就是為了解決這樣的困擾 Runnable runnbale = new Runnable() &#123; public void run() &#123; System.out.println("run me!"); &#125; public Runnable get()&#123; //將現有的method當作箭頭函數般回傳 return this::run; &#125;&#125;;//箭頭函數的形式Runnable runnbale = () -&gt; System.out.println("run me!"); Collection走訪functional programming的另一個重點就是function chain與Collection(list/map/array)的走訪. 搭配Collection的stream() //透過stream()衍生function chainlist.stream().filter(s -&gt; Integer.valueOf(s) &lt; 3).forEach(s -&gt; System.out.print(s));//parallelStream() : 平行處理的stream Lambda 以函數為參數//格式Function&lt;input, output&gt;Consumer&lt;input, void&gt;Predication&lt;input, boolean&gt;Supplier&lt;output&gt; static test(int x, Function&lt;int, string&gt; fun)&#123; f.apply(x);&#125;test(99, (int x) -&gt; &#123;return "99"&#125;); Interface擴展interface的method可前綴default與static的關鍵字 用以擴展interface的method Optionallink Optional是一個新的類別 用於封裝一個傳入或回傳值 並提供一些良好的方法 讓programer養成良好的習慣 Data/Time方面的新類別]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2Fhome%2F%2FJava%2FLock.html</url>
    <content type="text"><![CDATA[ref 同步與異步同步二字在生活上通常都解釋成同時進行/亦步亦趨 但程式上不是這樣觀念 異步 : 各自行動 互不等待 (記住異步的定義) 同步 : 行動須受牽制 等待 使一致 比喻 異步 : 像是短跑比賽 參賽者各跑各的 同步 : 像是跑接力賽 沒拿到接力棒就只能等待 (執行上依賴共享的資源) 用途 異步 : 增進執行效率 多執行緒 : 使用共享資源時還是要進入同步 單執行緒 : 任務寫在Event Callback/Hook 由Event Loop驅動 仿效異步 (如JavaScript) 同步 : 保護共享資源的必要手段 異步執行 指耗時任務交付後就可以先去做別的事情 等任務執行完再通知此任務稱為異步任務 不會馬上被執行架構為事件處理型(onEvent)的設計異步任務(Runnable)可以用thread或handler達成 同步執行 指事情必須依序處理 未完成前不能離開例如從網路取得一張圖片 顯示在螢幕上 若下載圖片要10秒鐘 程式就必須等待完成後才能繼續執行程式的基礎都是建立在同步執行上的 而多執行緒中的同步更強調的是只有一個執行緒在執行該段程式執行緒競爭要達到同步的代價就是等 等的實踐就是鎖 鎖的用途就是保護 對於鎖或與執行緒同步相關的實踐: synchronized lock blocking queue semaphore 需要等待的情境 等待共享資源 (用同步鎖解決) 等待異步任務(一個或多個)結果 (Thread.join或更高階的手段) 鎖 臨界區(critical section) : 即被鎖住的區塊 可重入性(reentrant) : 指thread可以重入相同的鎖中 即在funcA中又進入funcB 線程飢餓與公平(Starvation and Fairness) : 指線程搶不到開鎖機會的狀況 Busy Wait : 指while loop的等待方式 造成cpu持續忙碌而無法有效利用 synchronized 以某個物件(實例或類)做為鎖 多個thread中僅能一個thread取得鎖 也就是執行權 確保僅有一個thread進入critical section 確保從main memory讀入 離開時寫回 thread間取得鎖的結果是不公平的 有優先權的 而不是先到先贏 class Test&#123; //實例鎖 public synchronized void funcA()&#123; &#125; public synchronized void funcB()&#123; &#125; //類鎖 public static synchronized void func()&#123; &#125; static obj... public void func()&#123; //實例鎖 synchronized(this)&#123; &#125; //類鎖 synchronized(obj)&#123; &#125; &#125;&#125; 線程間能被安全共用的實例public class MyData&#123; protected Object data = false; public synchronized Object get()&#123; return data; &#125; public synchronized void set(Object data)&#123; this.data = data; &#125;&#125; 信號機制 每個Object都能做為MonitorObject wait : 使當下thread進入等待 並監視MonitorObject的信號 notify : 喚醒監視MonitorObject的thread (由系統決定喚起的thread) notifyAll : 喚醒全部監視的thread 重新競爭鎖 Missed Signals : 指notify前沒有相應的wait先被執行 而可能造成之後的wait無人喚醒 算是設計錯誤 以信號機制實現鎖public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; //isLocked為false時 進入wait循環 thread被鎖住 等待另一個thread開鎖 //若同一個thread未unlock又來lock第二次 同樣會被鎖死 造成沒有thread能解鎖 while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false; notify(); //相當於觸發信號 &#125;&#125;public class Counter&#123; private Lock lock = new Lock(); private int count = 0; public int inc()&#123; lock.lock(); int newCount = ++count; lock.unlock(); //若臨界區會拋出異常 需使用catch finally return newCount; &#125;&#125; wait如同sleep 但從wait中醒來並不是一定要有notify 它僅是告知已經可以從wait中喚醒 這種不是經由notify喚醒的情形稱作虛假喚醒(spurious wakeup) 故wait與notify之外仍需要isLocked做為是否unlock的判斷 這種while建構的鎖稱為自旋鎖 實現可重入性要考慮: 記住是由哪個thread上鎖 且上鎖幾次 解鎖必須counter歸零 Slipped Conditions 即指while(isLocked)與isLocked=true非一氣呵成(原子操作) 執行的間隙造成鎖的狀態改變 FairLock 透過List將記住請求鎖的順序 Semaphore 計數信號 實作上首先要確保操作的原子性當資源量為1時 可當鎖用 SEM_VALUE_MAX 資源量 P take/wait 減1操作 取得資源 V release/signal 加1操作 歸還資源 BlockingQueue 阻塞隊列 當take時沒有元素 或put時沒有空間時阻塞線程]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMM (Java Memory Model)]]></title>
    <url>%2Fhome%2F%2FJava%2FJMM.html</url>
    <content type="text"><![CDATA[*ref ref ref JMM (Java Memory Model) JVM執行區分 主內存(共享內存) 與 本地內存 Main : 主記憶體 (heap) Local : 各個thread獨立使用 (cache/副本) thread執行時會將需要的內容從main複製到local 之後操作各自的local memory, thread彼此間是無法得知其他thread操作的結果 除非重新同步main的資料 local從main讀寫資料應該是視為synchronized或有cpu確保同步 String str = new String("hello");//str為一參考 會放在stack//new String會放到heap//hello是字面值會放到靜態儲存區(應該也是heap) 可見性(visibility) 指A修改變數x時 確保B能夠隨時得到最新的值 (即cache失效)Java透過volatile將變數宣告為易變的/易揮發的 以提示其需要可見性的維護 (但並沒有原子性保護) x = 0;AB兩thread同時執行+3與+5,預期得到8volatile x = 0;A(x=x+3) : 0+3=3 將3指定給xB(x=x+5) : 0+5=5 此時x變為3,但運算已結束 將5指定給x 最後卻得到5,這是因為x=x+5的動作並不屬於原子操作,x+5與x=?是分別執行的,中間可以穿插,所以volatile不一定能確保變數一定是thread-safe的故volatile一般都用在狀態或旗標變數上 原子操作 (atomic)原子是最小無法分割之物 用來形容操作是不能分割的 以完成i++為例 分別需要取值/運算/賦值 假若期間無法插入任何與i相關的操作 就可以確保i的正確性 範例volatile int x = 0;volatile int y = 0;AtomicInteger a = new AtomicInteger(0);for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; x = x + 1; a.addAndGet(1); synchronized (Thread.class)&#123; y = y + 1; &#125; &#125; System.out.println("ans x : " + x); //405949 &lt;- 錯的 System.out.println("ans y : " + y); //500000 System.out.println("ans a : " + a); //500000 &#125; &#125;).start();&#125; CAS compareAndSet(expected, new) atomic檢查主入內存與expected是否相同,若相同表示可以賦值為new 否則回傳false 猜測應該是用在鎖的應用上 類似CountDownLatch 但不會阻塞 atomicI = new AtomicInteger(0);private void safeCount() &#123; for (;;) &#123; runCount++; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) break; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2F%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[*post 定義//Lev 1class Food&#123;&#125;//Lev 2class Fruit extends Food&#123; int weight;&#125;//Lev 3class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125; T //(或其他字母)T為一泛型可用以表示某一特定類別class List&lt;T&gt;&#123; T e&#125;List類別中有一特定類別為E區間:子類 &lt;- extends T super -&gt; 父類 -&gt; Object 泛型Class設計- T指是某一確切的類別 例如T為Fruit 並且可以多型轉換接受Apple或Banana- List&lt;T&gt;同上 但無法多型轉換 因為List&lt;Fruit&gt;並不能轉為List&lt;Apple&gt;- List&lt;? extends T&gt;是一個不確切的型別 兼容其子類 List&lt;Fruit&gt;與List&lt;Apple&gt;- super與extends雷同 兼容其父類 只是需求比較少見 - 例如要傳入一個比較器 希望設計這個比較器時能被通用 - 會寫成class Comparator&lt;Furit&gt;&#123;&#125;而不是替每種fruit分開寫 - 接收比較器的介面就需讓父類能傳入 如不管T是Fruit或Apple或Banana都能用 class MyList&lt;T&gt;&#123; //在MyList中根本不會知道E將會是什麼 ArrayList&lt;T&gt; list = new ArrayList(); //Fruit的子類都能傳入 void add(E e)&#123; &#125; //只能傳入ArrayList&lt;Fruit&gt; void addFromList1(ArrayList&lt;T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之子類 void addFromList2(ArrayList&lt;? extends T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之父類 void sort(Comparator&lt;? super T&gt; c) &#123; &#125;&#125; E被指定為?的副作用因為編譯時還不知道E是什麼,所以不能確定其子類或父類 Food food = null;Fruit fruit = null;Apple apple = null;Object obj = null; //? extendsArrayList&lt;? extends Fruit&gt; fruitlist_ex = null;fruitlist_ex.add(food); // X : 任何型別都不能傳入fruitlist_ex.add(fruit); // Xfruitlist_ex.add(apple); // X/*原因 :假若fruitlist_ex = new ArrayList&lt;Apple&gt;();此時fruitlist_ex.add(new Banana())若被允許表示T同時代表了具體的Apple(建構時)與Banana(函數呼叫時),這將使後續的操作難以預料故無論輸入什麼類都一律拒絕,以保封裝後的安全*/food = fruitlist_ex.get(0); // 回傳上限型別(Fruit),很合理,後續自己轉成子類 //? superArrayList&lt;? super Fruit&gt; fruitlist_su = null;fruitlist_su.add(fruit); // 可以傳入合理型別fruitlist_su.add(apple);/*原因 : 因為下限就是Fruit,不能fruitlist_su = new ArrayList&lt;Apple&gt;();所以T無論如何至少都是Fruit容器,放fruit/apple/banana都能符合T*/food = fruitlist_su.get(0); // X : 無法傳出合理型別obj = fruitlist_su.get(0); // 只能回傳Object型別/*原因 : 上線型別是Object故唯有傳Object能涵蓋所有可能型別*/ 即使你很確定轉型不會造成操作失敗,但編譯器仍會阻止你,因為至少在編譯器這一關需確保泛型所有可能性的安全,以提供語法上邏輯的正確. 簡記 extends 與其子類 僅能用於 輸出參數 out getter super 與其父類 僅能用於 輸入參數 in setter]]></content>
  </entry>
  <entry>
    <title><![CDATA[Singleton]]></title>
    <url>%2Fhome%2F%2FJava%2FSingleton.html</url>
    <content type="text"><![CDATA[video 建立的兩個需求: thread safe lazy Plainclass MySingale&#123; private MySingale()&#123;&#125; public static MySingale instance = new MySingale();&#125; //kotlinobject MySingale&#123;&#125; Lazy (not thread safe)class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; val instance by lazy(LazyThreadSafetyMode.NONE)&#123; MySingale() &#125; &#125;&#125; Lazy (thread safe)(synchronized) 加synchronized class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static synchronized MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; private var instance: MySingale? = null @Synchronized fun getInstance(): MySingale&#123; if (instance == null) instance = MySingale() return instance &#125; &#125;&#125; Lazy (thread safe) (volatile) 加volatile : 確保不同thread中能立即察覺變數的更動 class MySingale&#123; private MySingale()&#123;&#125; private static volatile MySingale instance; public static MySingale getInstance()&#123; if (instance == null)&#123; //避免持續進入synchronized synchronized (MySingale.class)&#123; if (instance == null)&#123; instance = new MySingale(); &#125; &#125; &#125; return instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; val instance by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; MySingale() &#125; &#125;&#125; 透過Holder (靜態內部類) 透過static Holder達到lazy new操作在java中原本也就是thread safe class MySingale&#123; private MySingale()&#123;&#125; private static class Holder&#123; static MySingale instance = new MySingale(); &#125; public static MySingale getInstance()&#123; return Holder.instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; fun getInstance() = Holder.instance &#125; companion Holder&#123; val instance = MySingale() &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2Fhome%2F%2FJava%2FJava.html</url>
    <content type="text"><![CDATA[面試題 資料型態 short / char : 2byte (unicode) int / float : 4byte long / double : 8byte (64bit) field修飾字 同package 子類 其他package public ✅ ✅ ✅ protected ✅ ✅ × default ✅ × × private × × × 引用 強引用(Strong) 強行使物件無法被回收 軟引用(Soft) 不置於立即回收 做cache時很適合 弱應用(Weak) 同軟引用 但更容易會被回收 虛引用(Phantom) 該回收就回收 可用於檢查物件的回收與否 person = new Person("john", 10);ref = new SoftReference&lt;Person&gt;(person);Person p = ref.get(); String透過純字面建立的string會在靜態緩衝裡建立快取 所以同樣的字串會對應到同樣的位置 但透過new String則一定是一個全新的指向s1 = "123";s2 = "12" + "3";s3 = "12" + new String("3");s4 = new String("123");// 其中只有s1==s2 StringBuffer / StringBuilder StringBuffer : thread-safe 較慢 StringBuilder : not thread-safe 較快 builder類通常宣告於method內做local變數 沒有共用的問題 也就不需要thread-safe interface / abstract interface 一個interface可繼承(extends)另一個interface 一個class可實作(implements)多個interface 可有member field 但強制成為static final method上加註default或static建立具體method (java8開始) abstract 無異於一個具體類(concrete class) 但無法實例化 且有抽象方法 一個class僅能繼承一個abstract class IOC / DI 控制反轉(Inversion of Control) 等同依賴注入(Dependency Injection)即指建立一物件時 其依賴並非由建立者或被建立者來建立提供 而由一專屬框架負責 InputStream / OutputStream 流操作分兩類 byte/character byte : 以InputStream / OutputStream結尾 Input/Output : 讀/寫 Stream : byte stream character : 以Reader / Writter結尾 以InputStreamReader為例 前綴InputStream表示輸入為byte 後綴Reader表示輸出character Proxy 代理 即中間人 透過中間人與物件互動 中間人即可提供一些額外的功能 RealSubject 被代理的物件(委託對象) ProxySubject 代理對象 Subject RealSubject與ProxySubject共同的介面 假設有一個request方法 靜態代理 : 就僅是將RealSubject包到ProxySubject裡new ProxySubject(real); 動態代理 : 透過反射 class ProxyHandler implements InvocationHandler&#123; private Subject subject; public ProxyHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //插入代理的行為 Object result = method.invoke(subject, args); return result; &#125;&#125;//建立一個該subject的handler 處理對應的invokehandler = new ProxyHandler(real);//建立ProxySubject 給予其該有的介面與handler 會動態產生一個classproxy = (Subject)Proxy.newProxyInstance( RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler);proxy.request(); Annotationref類似metadata 提供訊息用以描述內容 例如某個method是override的 用途 編譯檢查 如 @Override,@SuppressWarnings,@Deprecated 執行期間以反射取得某物件的Annotation 以提供相應的處理 編譯時搭配額外編譯工具提供自動產生代碼 如Dagger/JavaDoc @Retention(RetentionPolicy.RUNTIME) //使其能在runtime時保留 供反射使用@Target(METHOD.TYPE) //能被用在method上public @interface MyAnnotation &#123; String value() default "test"; //宣告需要一個字串變數&#125;public class TheClass &#123; @MyAnnotation("unit test") public void doSomething() &#123; &#125;&#125;//透過反射取得其AnnotationMethod method = TheClass.class.getMethod("doSomething"); Annotation[] annotations = method.getDeclaredAnnotations();Annotation annotation = method.getAnnotation(MyAnnotation.class); 捕捉 UncaughtException從Thread捕捉所有未能被try catch中捕捉的意外 替即將掛掉的程式安插一些處理方式 class ExceptionHandler implements Thread.UncaughtExceptionHandler&#123; @Override public void uncaughtException(Thread t, Throwable e) &#123;...&#125;&#125;Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler()); 內部類class AllInnerClass&#123; //內部類 (嵌套類) class InnerClass&#123; &#125; //靜態內部類 static class StaticInnerClass&#123; static Object obj = new Object(); //靜態成員的初始化 1.懶初始化 2.保證thread-safe &#125; public Object getTaske()&#123; //局部類 class LocalClass extends Object&#123; &#125; return new LocalClass(); &#125; //匿名內部類 Runnable anonymousInnerClassObject = new Runnable()&#123; @Override public void run() &#123;&#125; &#125;; //Lambda Runnable runnbale = () -&gt; System.out.println("running~");&#125; HTTPHttpURLConnection 較低階 HttpClient 較高階 以HttpGet或HttpPost做為請求對像 HttpClient client = new DefaultHttpClient(); HttpGet request = new HttpGet("http://tw.yahoo.com"); HttpResponse response = client.execute(request); HttpEntity entity = response.getEntity(); InputStream input = entity.getContent();]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2Fhome%2F%2FSingle%2FKotlin.html</url>
    <content type="text"><![CDATA[官方文件 簡介 介於Java與Scala之間 困擾 因為setter與getter緣故 難以區別’賦值’與’叫用’ 看不出in func的移轉 ()裡是什麼? 前綴是class : 建構成員參數宣告 前綴是fun : 函數參數宣告 {} 裡是什麼? 前綴是class : class宣告 前綴是fun : fun宣告 匿名函數 lambda 描述 不用分號結尾 一個檔案可多個類別 預設類別名稱 FilenameKt 沒有Primitive類型 全是Object (所以Java要存取都須透過getter/setter) 沒有static關鍵字 @JvmStatic @JvmField 方便對映回java對應 關鍵字 internal : 不允許外部訪問 (修飾class對java無效;但修飾fun會造成java無法access) Annotation @JvmOverloads //使fun多載(默認參數) @Synchronized @Volatile @JvmSuppressWildcards 避免Any轉成Java的? package 不宣告即為預設的package 檔案路徑不須對應package import 可以引入function 變數 前面一定要val或var val : 不可變(final) var : 可變 lateinit : 告訴編譯器稍晚會init不要報錯 但若沒有init執行時仍會丟異常 var 變數名稱: 型態 ＝ 初始值var x : Int = 1var x = 1 //自動推定var age_:Int? = nullx as String //轉型 (不需要再傳給變數)x.trim() Int String Unit : 相當於void Any : 類似Object 但不能是null IntArray / intArrayOf(1,2,3) vararg : 相當於Java接收參數String args…, 用*vararg能將其轉回陣列與java互用 Null 變數預設不能為null 型別後加?才能為null 安全調用 obj?.getNum()?:-1 空斷言!! 當null時報出exception (表示上:在變數後加!提示該變數是nullable) var x: Any //允許,但後續仍會被要求initvar x: Any? = nullfun getLength(s:String?):Int = s.length //編譯器不會過fun getLength(s:String?):Int = s?.length?:0fun getLength(s:String?):String = s!! function open : 可複寫 寫在最外層會變成 FilenameKt的靜態method open fun myfunc(x: Int, s: String) : Int&#123;&#125;//單行回傳fun getAge() = age 匿名函數 不允許冠return 最後一行的變數或結果自動當作回傳 fun myfunc(type: Int, func: () -&gt; Int)&#123; println(func())&#125;myfunc(1,&#123;7&#125;) //熟悉的寫法myfunc(1)&#123;8&#125; //較難理解的寫法myfunc(func = &#123;9&#125;, type = 1) //指定參數位置fun myfunc(func: () -&gt; Int)&#123; println(func())&#125;myfunc&#123;10&#125; //很難理解的寫法 SAM conversion//前面沒有fun關鍵字 後面接&#123;&#125;就是傳入匿名參數 懶加載 by lazy被用到時才初始化 val xy:Int by lazy &#123; val x=1 val y=5 x+y //最後一行即為匿名函數的回傳&#125; 具名函數 有回傳須指定型態 且要冠return fun func1():Int &#123;return 1&#125; //指名為func1fun func2() &#123;2&#125; //指名為func2fun func3() = &#123;3&#125; // &#123;3&#125;為匿名函數(lambda) 指定給func3作為回傳fun func5() = 5println("func1 ? " + func1()) //1println("func2 ? " + func2()) //kotlin.Unitprintln("func3 ? " + func3()) //Function0&lt;java.lang.Integer&gt;println("func3' ? " + func3()()) //3println("func4 ? " + &#123;4&#125;()) //4println("func5 ? " + func5) //5 //程式進入點func main(args:Array&lt;String&gt;)&#123;&#125; string templateval x = 1println("x = $x");println("x+1 = $&#123;x+1&#125;"); if-elseval max = if (x &gt; y) x else y when if 也可以回傳值 後面接的是lambda val x = 1var y:Intwhen (x) &#123; 1, 2 -&gt; y = 1 in 20..30 -&gt; y = 1 else -&gt; y = -1&#125;//SmartCast 可回傳var v = when (obj) &#123; is String -&gt; Integer.parseInt(obj) is Number -&gt; obj.toInt() + 5 else -&gt; -1&#125; forfor (i: Int in 1..5 step 2) &#123; print(y)&#125;//135for (i: Int in 5 downTo 1) print(i)//54321 lambda it : 預設第一個引數 val ia: IntArray = intArrayOf(120, 30, 15, 27, 66)ia.filter &#123; it &gt; 50 &#125; // 留下大於50的元素 .sortedBy &#123; it &#125; // 依照大小排序 .map &#123; it / 10 &#125; // 元素值除以10 .forEach &#123; print("$it-") &#125; // 顯示元素值 // 顯示： 6-12- class open : 可被繼承 close : inner : 預設的inner class是static的(與java相反), 要成為member class需加inner open class Person(var name: String) &#123; // 首要建構子的參數列 (有寫就一定要call)//參數列宣告有加var或val才能被外面存取//首要(primary)建構子 (有寫就一定要call) init&#123; &#125;//geter / setter var age:Int get() = age // java用.getAge() kotlin仍用.age set(value) &#123;age=value&#125; //這樣寫會recursive,要用field取代age set(value) &#123;field=value&#125;// 其它建構式，使用this(name)呼叫主要建構式 constructor(name: String, , age: Int) : this(name) &#123; this.age = age &#125; fun sayHi() &#123; println("Hi, $name!") &#125;&#125;//繼承open class NewPerson(name: String) : Person(name)&#123; override fun sayHi() &#123; println("Hey, $name!") &#125;&#125;val person = Person("Jim")println(person.age)person.sayHi() object 單例(Singleton) 立即實體化 沒有建構子 靜態實例 類似java的static 但access寫法不一樣 僅能透過ClassName存取 不能透過實例存取 中間多有一個單例的名稱 無法訪問其outter class的成員 (因為是單例/靜態/不屬於物件) 可以實作介面 但不能繼承 因為沒有建構子 可以宣告在任何地方 companion只能定義在class中 且僅能有一個 類似於static interface MyInterface &#123; fun doit() &#125;object single : MyInterface&#123; override fun doit() &#123; &#125;&#125;class MyClass&#123;//static companion object&#123; //變數預設名稱為Companion var x=1 fun myStaticFunc() &#123; &#125; //java叫用MyClass.Companion.sfunc() &#125;//單例 (class外部無法access) object mySingle&#123; var x=1 fun myFunc() &#123; &#125; &#125;&#125;//外界access方式 (不能透過類別實例存取)MyClass.myStaticFuncMyClass.mySingle.x MyClass.Companion.myStaticFuncMyClass.mySingle.x 類別擴展 用途類似包裝utils工具 MyUtils.ext(person) 但更便利 Java無法使用 有block範圍限制 不同block可有各自的擴展 (預編譯要先過) 可以靜態擴展 (可擴展第三方類別) 可以動態擴展 (但離開block後就不能用了) 可以透過import 在不同的檔案類別中共用 fun Person.ext()&#123; println("are you $name ?")&#125;import com.example.myextends.extimport com.example.myextends.*//泛型fun &lt;T&gt; T.basicToString(i: Int) &#123;&#125;basicToString&lt;String&gt;(1) infix : 語法糖 便於閱讀 infix fun String?.append(s:String?) = this+svar x = "xxx" append "dddd" 泛型video*postpost ? 相當於 * (這樣說不正確) extends 相當於 out get安全 set禁止 生產者 super 相當於 in set安全 get禁止 消費者 inline : 相當於將函數程式碼坎入到caller處 比較適用於lambda型式的函數 refied : 與重新定義泛型有關 //聲明處型變interface Source&lt;out T, in E&gt; &#123; // &lt;&lt;---在這裡 fun funOut(): T //out表示僅能定義在輸出 fun funIn(t:E) //in表示僅能定義在輸入&#125;//使用處型變interface Source&lt;T&gt; &#123; fun funIn(t: Source&lt;out T&gt;) // &lt;&lt;---在這裡&#125;//泛型約束&lt;T extends String&gt; ==&gt; &lt;T : String&gt;//kotlin允許多個約束 (用where關鍵字)open class Food&#123;&#125;open class Fruit : Food()&#123;&#125;class Apple : Fruit()&#123;&#125; 不型變 指List與List是無關聯的 協變 指List是List的子類”型” (不是子類) 逆變 指List是List的子類”型” 突破java限制: //javainterface Source&lt;T&gt; &#123; public T nextT();&#125;public void demo(Source&lt;String&gt; strs)&#123; Source&lt;Object&gt; objs = strs; // 在Java中是不允许的 // 正确方式为 // Source&lt;? extends Object&gt; objs = strs;&#125; //kotlinabstract class Source&lt;out T&gt; &#123; // 使用out的话，T只能作为返回值 abstract fun nextT(): T // 不能作为传入参数，下面会报错 // abstract fun add(value: T)&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs&#125; functioninterface Function &lt;in T, out U&gt;Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt; enum 與 sealed sealed用法類似enum 但能以class或object識別 enum class Lang(val text: String)&#123; ENGLISH("Hello"), CHINESE("你好");&#125; sealed class Cmd(val text: String)&#123; class Play(val url): Cmd object Stop: Cmd&#125; 委派 Delegate field存取委派 內部用get/set實現 Delegates實作要繼承ReadWriteProperty 像是做lazy或監聽 var state:Int by Delegates.observable(0, &#123;prop, old, new -&gt; &#123; println("$old =&gt; $new")&#125;) 尾遞歸優化 避免StackOverflowError (其實就是轉為loop處理) 遞歸函數在最後呼叫稱為尾遞歸 函數前綴 tailrec Operator overloadinga == b // a.equals(b)a..b // a.rangeTo(b)a in b // a.contains(b)a[i] // a.get(i)a[i] = 9 // a.set(i, 9) 其他class MyClass&#123;&#125;Class::class.java //取得class實例 等同於Java的MyClass.class]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth]]></title>
    <url>%2Fhome%2F%2FSingle%2FOAuth.html</url>
    <content type="text"><![CDATA[youtube 意義user =&gt; client app(consumer) &lt;=&gt; server(service provider) app取得provider的service user不必向app透露帳號密碼 過程 client請求request token client將主導權導向server server向用戶詢問是否授權(導向server提供的畫面) server將主導權導向client client請求access token Signature 簽名 server透過signature驗證用戶身份 Signature = Signature Base String (AES with) secret key Signature Base String大概是由url的特徵產生 secret key僅有加密者與server知曉,故透過Signature就能讓server辨試身份 Request Token 與provider對話權的令牌 初步驗證app的權限後取得 client提供app key與signature向server請求request token Access Token 存取用戶資料授權的令牌 驗證用戶身份與同意授權項目後取得]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDagger.html</url>
    <content type="text"><![CDATA[gradle設定dependencies &#123; kapt &apos;com.google.dagger:dagger-compiler:2.5&apos; compile &apos;com.google.dagger:dagger:2.5&apos;&#125; android/kotlin注意事項@Inject/@Named 註解欄位時要加field:fragment要繼承DaggerFragment (否則從FragmemtManger取回時不會注入)activity要繼承DaggerAppCompatActivity 示例欲在MainActivity中自動注入Car實例 class Car&#123;&#125;class MainActivity()&#123; lateinit var car: Car init&#123; car = Car() //希望透過別的方式將Car注入到MainActivity的car &#125;&#125; 對象名詞定義 dependency : 依賴物 如Car client : 接收依賴者 如MainActivity 先設想一個注入器要有哪些提示才能完善 依據什麼對應D和C? 用類型,但要切確,例如不能把Object注入到String field 怎麼知道哪個field需要被注入? 用@Inject標記field 哪些類是可以拿來注入的? 用@Inject標記constructor 建構依賴時可能需要建構參數或靈活性? 用@Provides做method回傳建構好的實體 所以依賴可用@Inject標記constructor”或”直接做@Provides method回傳依賴物 同一個類但對應多個不同的子類或不同建構參數? 用@Qualifier給各自一個別名 field想宣告成界面類型要怎麼做? 用@Binds做綁定該類與其介面 注入的東西生命週期為何? 用@Scope定義 可以需要一個或多個生產依賴的工廠 稱作Module 至少要有個注射器建構這些工程吧 Component就是注射器 而Module依附在注射器裡 注射器下還有子注射器區別不同的環境 叫做SubComponent 那不就要寫很多code? 幾乎只要用interface或abstract進行描述 dagger會自動產生實做好的類別(Component/Module) 尚未驗證 依賴的可視性應該取決於注射器與子注射器的繼承關係 子能見父 但子與子間互不可見 “父可能也不能見子” (父子指的是注射器產生出的實體) 子的注射物無法override父的注射物 仍要用key 是否單例取決於scope 同名scope在不同注射器上應如同不scope 同注射器同scope間僅能有一個實體 沒指名scope表示沒此注射都用不同實體 一個依賴只能有一個scope @Singleton是一個Application層的scope 相當於global/root/最頂層 開始於一個該scope的頂層物件 該物件在產生其他依賴 這一群的依賴中 同一個Lazy只會回傳一個實體 與singleton無關 只是快取 step1 @Inject 宣告注入物 : 在注入物的Constructor標註@Inject (一種可以不在Module中宣告的方式) 使用注入物 : 在其使用處(注入處)標註@Inject (可用Lazy取得緩衝物件) @Singletonclass Car @Inject constructor() &#123;&#125;class MainActivity()&#123; lateinit var car: Car @Inject set&#125; 發現在android的dagger2, Constructor不一定需要@Inject step2 @Module Module如同依賴物的生產工廠 當有需要依賴時dagger會自己叫用這裡的fun Module可為’class一般類’或’abstract class抽象類’或’object實例’ 其中只有抽象類能用@Binds(因為code是自動產生的,僅需提供介面) 用抽象函數提供依賴 其輸入參數最終要能得到實例 (靠@Inject或@Provides) @Binds 用抽象函數提供轉型 @Binds abstract OutCls trans(InCls obj) @Provides 直接提供注入函數 回傳實例 @Moduleclass CarModule&#123; @Singleton //標示provide一個singleton實例 @Provides //標示該fun為一provide函數 fun provideCar() = Car()&#125; 一個物件要被提供給注射器 @I : 直接在該物件的constructor宣告@Inject (會自動產生依賴函數於注射器) @P : 用@Provides寫函數回傳提供 (寫在Module裡,就可以省略1) @B : 轉型需求 僅是一個輔助 1或2再加上@Binds abstract fun… step3 @Component Component稱為注入器更貼切 只需定義其介面 dagger2的builder會實作該介面 並建出前綴為Dagger的class 並用該class建立注射器實體 @Singleton //如果Module中有Singleton這裡也要有(原因可能跟@Scope綁定作用域相似)@Component(modules = arrayOf(CarModule::class)) //定義注入器能注入的Moduleinterface MainActivityComponent &#123; fun injectCar(main: MainActivity)&#125;//dagger2會自動建出DaggerMainActivityComponent並且實作injectCar() step4 實際注入 dagger2負責建立依賴 但依賴注入的時間點仍須自己處理 //方式1 自有注射器 (或繼承DaggerAppCompatActivity 他能替我們注入activity的依賴)class MainActivity&#123; lateinit var car: Car @Inject set init&#123; DaggerMainActivityComponent //dagger自己產生的class .builder() .carModule(CarModule()) //將Module提供給注入器 .build() //建立注入器實體 .injectCar(this) //替this注入依賴 (沒有lazy) &#125;&#125; //方式2 建立Android Framwork App共用的注射器 App要註冊到manifestclass App : Application() &#123; //android.app.Application val injector: AppComponent by lazy &#123; DaggerMainActivityComponent .builder() .carModule(CarModule()) .build() &#125;&#125; more1 @Qualifier 或@Named(“type”) 用來替@Inject注入處綁定@Provide fun, 解決Car能由多個provide fun產出的情形 首先要自訂Annotation @Qualifier@Documented@Retention(RUNTIME)public @interface ProvideID &#123; String value() default "";&#125;@QualifierA@Provides fun provideCarA():Car&#123;...&#125;@QualifierB@Provides fun provideCarB():Car&#123;...&#125; //kotlin中明確指出annotation作用的位置為field:@Inject@field:Named("local")lateinit var ....或@field:[Inject Named("local")]lateinit var .... 將該Annotation註釋到@Provide與@Inject的注入處即可 more2 @Scoperef 用來綁定@Provide與@Component注入器間的生命週期 讓provide產生的實例沿用直至注入器結束 一個component中僅能有一個scope 同一個component中不允許兩個同類型的’注射物類型’ (以類型的字面定義區分 無論繼承關係) 同一個scope中不會建立兩個同類型的’注射物實體’ (即局部單例) 用@I或@P方式建立依賴物(當兩個都有建立時,依賴是優先從@P方式取得) 若是依賴在注射器中是從@P方式取得 則@I的scope宣告會被忽略 故scope應該建立於provider函數上 (很容易理解 因為provider函數的回傳是我們自己實例化的 scope限制的是該函數 而不是函數的回傳) @B因為是自動產生provider函數 所以會參考@I的scope宣告 more2 @Singelton 即@Scope做出來的一個Annotaion 字面上的意思是Singelton 實際上每個scope中的每個類型都僅能有一個實體對映 若要對映多個 1.用@Qualifier區分 2.用@Binds轉成不同型別(非@Binds真正的目的) more3 @Reusable 類似@Singelton但不再需要與注入器綁定 multi-thread時可能會出現多個實例 more4 @BindsInstance 與@Component注射器的builder相關 貌似能從builder()後接上需要提供的依賴物 more5 注射器間的依賴 一個注射器的依賴來源可以是Module 也可以是另一個注射器 @Component(dependencies = MainActivityComponent.class) //依賴另一個注射器interface Activity2Component &#123; fun injectCar(aty: Activity2)&#125;Activity2Component aty2Component = Dagger Activity2Component.builder() .mainActivityComponent(mainAtyComponent) //build時需提供注射器的依賴 .build(); more6 注入器間的繼承 @SubComponent Annotation使用上如同@Component 同一個Component下的SubComponent可以有各自的scope 概念就跟類別繼承一樣]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRxJava.html</url>
    <content type="text"><![CDATA[stream的類型 cold : 如同隨選視訊 流是固定的 訂閱才送 每次送都是完整的 不論是否送過給別人 hot : 如同直播 流是不斷送出的 無法減速的 每次訂閱都只能從當下開始 沒有終點的 物件解釋//基於Obserable建立一個可訂閱對象Obserable.create( new OnSubscribe&lt;String&gt;()&#123; @Override public void subscribe(Emitter&lt;String&gt; e)&#123; //發送事件 e.onNext("new event!"); e.onComplete(); &#125; &#125;) .subscribe( //訂閱並設定接收的對象 參數列:onNext, onComplete, onError new Consumer&lt;String&gt;() &#123; @Override public void accept( String s) &#123; System.out.println(s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;); ref Obserable : 可觀察對象 除此還有多種不同類型的可觀察對象可以create OnSubscribe : 可訂閱對象 負責發送產生事件 Emitter : 相當程度代表一個訂戶(多少有連結關係) Observer : 觀察者 即訂戶 接收事件 Consumer : 一個通用的介面 帶有一個accept方法 該方法被叫用的意義與時機由外界定義 BiConsumer : 同Consumer 但accept能傳如兩個參數 upstream / downstream : 即兩個observable的相對應關係 donw=up.map(…) 大致流程(一種意象上的形容 幫助記憶) 最末端的observer開始o.subscribe(observer) 一路向上訂閱 操作符也如同一個observer+observable (向上進行訂閱 向下提供可觀察對象) 一直訂閱到最頂端的observable (到頂端前,中間的操作符也可能發射值) observer相當於會被丟到OnSubscribe.subscribe()直接被呼叫onNext/onError/onCompleted 一個observable被重複訂閱也是相同的流程 但不見得會發射一樣的值 要視observable設計與規劃而定 例如cold與hot的差別 ObservablesRxJava搭配Room observable flowable : 有backpresure策略 可控制流速 single : 只發1次(onSuccess)或0次(onError)事件 沒有其他選項 completable : 沒有事件 只有成功與否 只有onComplete與onError 常用.andThen(…)操作符再轉出其他obserable maybe : single+completable 一次性使用 : single / maybe 僅關注成敗 : completaion emmiter interface onNext(T t) 多事件型會用這個關鍵字 onSuccess(T t) 單事件型 相對應的是onError(Throwable t) observer interfaceobserver與emmiter的介面有點像是mapping 呼叫emmiter的onNext近似於observer的onNext被呼叫 onError後 onComplete應該就不會被呼叫了 Subjectref subject同時擁有observable與observer的能力. 做為observer可以直接透過subject實體餵入事件onNext(“event”) 做為observable能讓外部訂閱 算是一種整合應用 做為observer很單純 但做為observable則有很多變化 PublishSubject 沒有任何特殊機制 BehaviorSubject 訂閱時會發射預設值或最後一值 像是一個狀態變數一樣 任何時候都有值 AsyncSubject 只在onCompleted才發射值(最後一個) ReplaySubject 任何時間訂閱都從頭再發射一次 操作符 操作符回傳的都是Observable 但向操作符提供的function僅是完善操作符的一小部分 func的in/out與操作符的out是不相干的 操作符的應用 應考慮流的屬性(hot/cold) 操作符 - 結合concat一個流結束 才切到下一個流 marge多個流同時穿插 當一個流onError就全部結束 操作符 - 建立create 自訂OnSubscribe 自己提供值來發射 from 用Iterable的內容值發射 just 從參數列給值來發射 defer 產生新的observable (每次訂閱就會重新產生) Interval 值從0開始 每固定時間發射一次 timer 在一段時間之後發射0 之後就completed range 分別發射一個區間的值 repeat 將收到的值重複發射N次 操作符 - Transforming 將值變形buffer(count) 累積count個值 轉成array發射 buffer(count, skip) 累積skip個值 只取count個 轉成array發射 window(count/time) 同buffer 但包裝成Observable 可用時間做buffer map 將值個別map成新的值 ex:1 =&gt; “1” flatMap 將值個別map成以Observable產生的值 ex:1 =&gt; Observable.just(“1”) flatMapIterable 將值個別map成以Iterable產生的值 ex:1 =&gt; listOf(“1”) map說明 以上三個map操作符輸出的都是Observable\ 僅只是用不同的方式建立內容 scan 類似map的用法 但多一個acc的累加參數 (如若有設初始值,在subscribe時會先送初始值,無論上游是否有值) groupBy 依值建立GroupedObservable 返回Observable\&lt;GroupedObservable\&lt;K,T&gt;&gt; cast 轉型 操作符 - Filteringdebounce 抗反彈 收到值後需N時間後無新值才會發射 否則用新值且N重算 throttleWithTimeout (同throttleLast?) 同debounce 但N不會重算 throttleFirst 同debounce 但N不會重算 且取的是最先發生的值 sample 固定時間內取最新的一筆 時間的起點與訂閱時間有關 與資料發生時間無關 distinct 僅發射不同的 從未出現過的值 distinctUntilChanged 僅發射與前一個值不同的值 elementAt 僅發射第N個值(接收到的第N個) filter 僅發射函數返回為true的值 last / first 僅發射函數返回為true的第一或最後一個值 發射完即completed take 僅發射固定筆數 發射完即completed skip 忽略前面N筆 blocking… 將上游阻塞 待下游… 用途尚未確認 操作符 - CombiningObservable.combineLatest(O1,O2,combiner) 當O1或O2有值時透過combiner函數決定發射的值 (傳入O1,O2的最新值) (多形用法還多) join(O2,T1,T2,combiner) 將現有Observable(O1)與O2結合 T1/T2分別表示O1/O2有效的時間 兩者都在有效時間內時會呼叫combiner進行發射 joinGroup … Observable.merge 混合兩個Observable mergeWith 同merge 但沒試出結果 startWith 開頭時插入值 switch 當一個O發射多個O時 切換到最新發射的O Observable.zip(O1,O2,O3,zipper) … 將O1,O2,O3的值依序合併成新值 操作符 - 異常處理onErrorReturn 捕捉onError異常 並補一個值 之後onCompleted onErrorResume 同onErrorReturn 並補一個Observable繼續運作 OnExceptionResumeNext 針對Exception處理 retry / retryWhen onError時重試 retryWhen要注意forever loop問題 操作符 - Utilitydelay 延遲值的發射 delaySubscription 延遲訂閱的時間 doOnEach/doOnNext/doOnSubscribe/doOnUnsubscribe/doOnError/doOnCompleted/doOnTerminate/finallyDo 監聽事件 直接回傳上游Observable materialize 將事件與值封裝為Notification類型 dematerialize 將Notification解回事件與值 [ subscribeOn / observeOn ] 將個訂閱過程拆分”訂閱時期”與”觀察(遞值)時期” 訂閱時是由下往上(code的順序) 觀察時期是由上往下 subscribeOn 在訂閱時期指定thread (訂閱時期比較短 相應的函數通常只執行一次) observeOn 在觀察(遞值)時期指定thread (觀察(遞值)時期比較長 相應的函數通常反覆執行) timeInterval 發射值與前一個值之間的時間差 timeStamp 發射值發生時的時間戳 timeout 逾時未出現值則發出onError 或發出endWith+onCompleted using 有點像是建立一個與該Observable伴隨生命的物件 操作符 - Conditional and Booleanall(func) 根據func的回傳 如果至onCompleted都沒有false 就發射一個true 然後onCompleted amb(O1,O2…) 讓O1,O2…競賽 以最先有值或事件的O做為發射的來源 contains(func) onCompleted前func回true則發射true 否則發射false 然後onCompleted isEmpty (true or flase) + onCompleted defaultIfEmpty empty時發射default+onCompleted sequenceEqual(O1,O2) 用來判斷O1,O2的發射值與順序是否一模一樣 skipUntil(O2) 直到O1出現O2的pattern前都skip skipWhile(func) 直到func回傳false前的值都skip takeUntil / takeWhile … 如上類似 操作符 - 合計Aggregatecontact 合併兩個O 但第一個onCompleted才能切第二個 count 在O結束時 發射值的數量然後onCompleted reduce 壘算 直到O結束才發射 然後onCompleted (類似scan 只是scan是每次壘算都發射) collect(init,collector) 將值收集到ArrayList之類的物件 在O結束時才發射 然後onCompleted 操作符 - Connectablepublish 將O轉成需要connect才發射的型態(Connectable) 主要用意在控制多個observer時的發射時機 connect 當connect時該Connectable即已經開始訂閱上游 refCount 將Connectable轉回普通的O replay 轉為一個Connectable 並保留數個值或一段時間的值做新訂閱者的startWith (字面很像重播 但實際比較像buffer的效果) 操作符 - 自訂操作符ref compose (自定義/加工observable) Transformer 加工上游observable 再返回另一個observable 可以當成一個聚合的操作符 執行一個compose裡面藏了很多操作符 lift (自定義observer) 能插入一個Operator/Subscriber]]></content>
      <tags>
        <tag>Android</tag>
        <tag>ReactiveX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast]]></title>
    <url>%2Fhome%2F%2FAndroid%2FBroadcast.html</url>
    <content type="text"><![CDATA[Broadcast 發送或接收系統事件廣播 如低電量/簡訊生命週期在onReceive()結束後終止以靜態方式(manifest)註冊接收器 可以不用開app 也能接收事件 registerReceiver(new BroadcastReceiver()&#123;&#125;, new IntentFilter("action..."));unregisterReceiver(mybc);Intent intent = new Intent(this, MyBC.class)Intent intent = new Intent("action...")intent.putExtra("data", "mydata");sendBroiadcast(intent);class MyReceiver extends BroadcastReceiver&#123; onReceive(content, intent);&#125; 或以常駐的方式(不論app是否啟動或kill都能被執行) &lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.EDIT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Dev Log]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDevLog.html</url>
    <content type="text"><![CDATA[TextView行高在編輯文字時會改變addTextChangedListener(object:TextWatcher&#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; //每次文字更動時都在設定一次行高 setLineSpacing(0f, 1f) setLineSpacing(20f, 1f) &#125;&#125;)]]></content>
      <tags>
        <tag>Android</tag>
        <tag>開發紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRecyclerView.html</url>
    <content type="text"><![CDATA[加入RecyclerView//0. 取得viewvar view = findViewById&lt;RecyclerView&gt;(R.id.recyclerView)//1. 設定layoutval layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)view.layoutManager = layoutManager//2. 設定adapterview.adapter = MyAdapter(data)//3. 設定分隔線view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); class MyAdapter : RecyclerView.Adapter() &#123; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; //建立ItemView並存於ViewHolder回傳 &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; //將欲顯示的內容抽換到holder中的view &#125; override fun getItemCount(): Int &#123; &#125; //自訂ItemView的Holder class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2Fhome%2F%2FAndroid%2FFragment.html</url>
    <content type="text"><![CDATA[加入Fragment fragment要被砍入的位置 R.id.contentFrame fragment自身的佈局 R.layout.main_frag var fragment = supportFragmentManager.findFragmentById(R.id.contentFrame)?:MainFragment().also &#123; supportFragmentManager.beginTransaction().apply &#123; add(R.id.contentFrame, it) commit() &#125;&#125; class MainFragment : Fragment()&#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; var view = inflater?.inflate(R.layout.main_frag, container, false) return view &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2Fhome%2F%2FAndroid%2FGradle.html</url>
    <content type="text"><![CDATA[Groovy 語言特性介紹 加快編譯//gradle.propertiesorg.gradle.jvmargs=-Xmx512morg.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.configureondemand=true 異常”Gradle project sync failed”在android sample中加入kotlin一直不成功 但new project中卻沒問題 把code移入new project中確認也沒問題 可見是環境造成 rm -rf .gradle/ .idea/ build gradle 最後是把src root folder從Application改名(Refacotr)為app才正常 buildTypes 控制編譯流程 debug / release productFlavors 分歧編譯目錄 mock / prod 不同選擇即用不同目錄下的檔案編譯 flavorDimensions : 對flavor再進行一次分類 例如platform,vertype 組合出多個目錄 BuildConfig設定會透過BuildConfig類帶入java中 applicationId作用在google play store上 用以辨識app, 不同的release要有不同的applicationId, 否則會被視為同一個app 可寫在defaultConfig或個別的buildType/productFlavors中 也可用applicationIdSuffix]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE_ENV]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIDE-ENV.html</url>
    <content type="text"><![CDATA[API版本 SDK TOOL路徑cd ~/Library/Android/sdk/tools/bin/ export JAVA_HOME=`/usr/libexec/java_home -v 1.8`export SDK_HOME=/Users/jimliu/Library/Android/sdkexport ANDROID_HOME=/Users/jimliu/Library/Android/sdkexport GRADLE_HOME=/Applications/Android\ Studio.app/Contents/gradle/gradle-3.2/export PATH=$JAVA_HOME/bin:$&#123;SDK_HOME&#125;/tools/bin:$&#123;SDK_HOME&#125;/platform-tools:$GRADLE_HOME/bin:$PATH cat &gt; ~/.bash_profile貼上之後ctrl+c 添加Library Adding a Library Project Adding a Jar library 快速鍵//自動完成不分大小寫editor&gt;general&gt;code completion的case sensitive completion要調為none//自加cmd IKJL : 上下左右cmd+sft J/L : to line start/endcmd+sft I/K : extend/shrink selectioncmd p : parameter infocmd ;或z : Basic/ in Code Completion 函數自動完成 (api doc)cmd , : insert live template 插入樣板//mousecmd click : Declaration/ in Main menu Naviagte 查原始碼 (或xml)//視窗檔案切換ctrl tab//游標opt 左右 : 左右移 擴大/縮小選取sft opt : 上/下移動行sft enter : end + entercmd enter : enter + 上 (游標位置不動產生一空行)//快速產生程式碼 souf fori logi cmd j : 插入樣板cmd opt t : if / try / while//開啟燈泡內的選項opt enter//查詢物件的method/field 或任何可能的字串ctrl space : 查詢method/field (選定後按tab!!!!) 或 提示字串自動完成//建立methodcmd n : 各式選單ctrl o : select override/implement//單純查詢ctrl j : 查詢文件定義cmd p : 顯示參數定義 ****cmd b : 查原始碼 (或xml)cmd u : 跳到父類cmd opt L : 自動格式化cmd F9 : 編譯執行//搜尋內容或檔案sft sftsft F6 : 變數改名cmd + d : 複製貼上一整行 或貼上已選取的內容cmd sft a : 開啟系統功能搜索]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resource]]></title>
    <url>%2Fhome%2F%2FAndroid%2FResource.html</url>
    <content type="text"><![CDATA[資源引用出現的樣式[@|?][namespace:]type/name//type : string，dimen，drawable，layout，color，anim，animator，mipmap，raw，id，style，attr，array//@ : 引用切確資源@android:string/title //Android本身的資源@string/title //省略namespace即引用自建資源//? : 引用自主題屬性 (如果主題沒定義該屬性會報InflateException)android:background="?attr/colorPrimary"//+ : 通常是替自己建立資源設定ID時使用android:id="@+id/myViewId"//@null : 應該是一個特別的id 讓某些屬性能夠不執行android:button="@null"android:background="@null" assets與raw assets不會產生id於R資源 可有目錄結構 透過AssetManager讀取 raw屬於R資源 透過R.id讀取 AssetManager am = getAssets(); InputStream is = am.open("filename"); InputStream is = getResources().openRawResource(R.id.fileNameID);VideoView.setVideoUri(Uri.parse("android.resource://" + getpackageName() + "/" + R.raw.movie)); 多國語言只需透過IDE編輯即可 (勾選不需要翻譯的字串) Drawable 可被畫出在View上的 例如圖檔來源 from BitmapDrawable 也可從xml定義 color shape : 形狀 方圓線等 stroke 描邊 solid 填充 corners 邊角 padding selector : 狀態 每個item搭配一個狀態對應一個drawable state_pressed / state_focused / state_selected / state_checkable state_checked/ state_enabled / state_activated / state_hovered state_window_focused layer-list : 圖層 越先執行的在越底層 用很多層疊出一個drawable]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storage]]></title>
    <url>%2Fhome%2F%2FAndroid%2FStorage.html</url>
    <content type="text"><![CDATA[Storage internal與external是以app間分享的角度,external表示可被分享 無論internal或external 在app移除都會跟著移除 除非用是PublicDirectory internal /data/data/ 被連結到(/data/user/...) 一定存在 別的app不能訪問 用Context.filesDir取得 primary external /Android/data/PACKAGE_NAME 被連結到(/storage/emulated/...) 可能是內部記憶體卡的分割或外部記憶裝置(Adoptable Storage) 用Context.getExternalFilesDir取得 secondary external 外部記憶裝置 不一定存在 //Context.filesDir (/data/data的連結) /data/user/0/PACKAGENAME/files//Context.getExternalFilesDir /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures//Context.getExternalFilesDirs (Primary/Secondary) /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures /storage/12E9-1105/Android/data/PACKAGENAME/files/Pictures //Environment.getExternalStorageDirectory /storage/emulated/0 //Environment.getExternalStoragePublicDirectory /storage/emulated/0/Pictures //Environment.getDataDirectory /data//Environment.getDownloadCacheDirectory /cache//Environment.getRootDirectory /system//Environment.getExternalStorageState mounted]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layout]]></title>
    <url>%2Fhome%2F%2FAndroid%2FLayout.html</url>
    <content type="text"><![CDATA[Layout view跟layout定義上的差別: view是通常形容元件 layout則是容器(容器內的排版)layout是view的子類 RelativeLayout定位於 某元件 或 所處容器 的相對位置 FrameLayout定位於左上角 (view會重疊) LinearLayout水平或垂直 接續排列 權重分佈 TableLayout格狀排列 ConstraintLayout約束排列 約束元間之間的相對關係 (取代RelativeLayout) StaggeredGridLayout格狀(磚塊)排列 LayoutParams.FILL_PARENT //依父容器大小 填滿父容器LayoutParams.WRAP_CONTENT //依內容大小 適當顯示 SwipeRefreshLayout有下拉Refresh功能 findViewById&lt;SwipeRefreshLayout&gt;(R.id.refresh_layout)?.apply &#123; isRefreshing = true //設定為正在refresh setColorSchemeColors( ContextCompat.getColor(activity, R.color.colorPrimary), ContextCompat.getColor(activity, R.color.colorAccent), ContextCompat.getColor(activity, R.color.colorPrimaryDark) ) setOnRefreshListener&#123; println("do refresh...") postDelayed(&#123; println("done refresh...") isRefreshing = false //設定為沒在refresh &#125;, 3000) &#125;&#125; 屬性一個view中前綴layout的屬性是給其容器看的 例如layout_gravity與gravity 以個是告訴容器把自己放在哪 另一個是自己中把內容物放在哪 指定layout managermanager = new LinearLayoutManager(this);RecyclerView mList = (RecyclerView) findViewById(R.id.list_view);mList.setLayoutManager(manager);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArchitectureComponent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FArchitectureComponent.html</url>
    <content type="text"><![CDATA[video video LifecycleOwner : lifecycle的擁有者 像activity或fragment都是LifecycleOwner 可透過getLifecycle()取得Life LifecycleObserver : 一個介面 實作這個介面 就能透過Life.addObserver加入監聽lifecycle事件的行列 ViewModel :]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMisc.html</url>
    <content type="text"><![CDATA[Launcher 即手機home鍵看到的畫面 以及其延伸的機制 本身同樣為activity HomeScreen WorkSpace 上半部的大範圍 HotSeat 底下的熱連結 AppList (GridView) 應用 Shortcut 將app中某些功能結合user需求產生快捷 LiveFolder 類似將一個content provider封裝 AppWidget WallPaper]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Widget]]></title>
    <url>%2Fhome%2F%2FAndroid%2FWidget.html</url>
    <content type="text"><![CDATA[Widget 一個自訂的service(app)顯示且整合於WorkSpace中 整合困難的部分在於launcher與widget執行於兩個不同的process中 AppWidget 即自訂的app AppWidgetHost 一個AppWidget的宿主 負責與AppWidget交互 AppWidgetHostView AppWidgetManager AppWidgetProvider 提供view的更新 是一個BroadReceiver (即使是空的也無所謂) AppWidgetProviderInfo 提供資料的更新(mata-data) 寫code只需要AppWidgetProvider與Manifest+provider_info+layout的設定即可 RemoteViews 一個能夠對映view的投射物件(兩者都從相同的layout建立) 透過RomoteViews操作view 再將此RomoteViews丟到遠端 遠端即可知道如何更新實際的view 達到跨process的view操作]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAnimation.html</url>
    <content type="text"><![CDATA[*post animation property (透過修改view實例自動產生動畫) view animation (tween) (Alpha Rotate Scale Translate Set) drawable animation (frame by frame) 單位: 數字 : px 50% : 自己寬度的50% 50p : 容器寬度的50% //Tweenanim.setDurationanim.repeatMode // 重頭再開始 / 倒退再開始anim.fillAfter // 停在結束anim_set.add(anim)view.startAnimation(...)anim = animationUtils.loadAnimation(R.id....) // from xmlaty.overridePendingTransition() //過場動畫 //viewFlipperfilper.setInAnimation(...)filper.setOutAnimation(...) android:activityOpenEnterAnimation&lt;ViewAnimator android:inAnimation="@android:anim/slide_in_left"&gt; &lt;TextView/&gt; &lt;TextView/&gt;&lt;/ViewAnimator&gt; youtube Animation Tweened (補間動畫) alpha 淡入淡出 rotate scale translate 移動 Frame-by-Frame Property Animation (屬性動畫) Tweened與ValueAnimator的差別 Tweened僅是繪製上的調整 也就是說移動一個button 事實上只是畫到別的地方而其屬性仍保留在原處 而ValueAnimator則不斷的調整view的屬性 TweenedAlphaAnimation animate = new AlphaAnimation(1, 0);animate.setStartOffset(1000);animate.setDuration(1000);animate.setFillAfter(true); //動畫後停留在最後animate.setFillBefore(false); //動畫後回到起點animate.setRepeatCount(1);AnimationSet aset = new AnimationSet(true); //共用interpolatoraset.addAnimation(animate);imageview.startAnimation(aset); //rotate需定義旋轉的中心點,中心點可相對於自己或containarRotateAnimation animate = new RotateAnimation(0, 360 Animation.RELATIVE_TO_PARENT, 1f, Animation.RELATIVE_TO_PARENT, 0f); //scale需定義縮放的軸心,軸心可相對於自己或containarScaleAnimation animate = new ScaleAnimation(1, 0.1f, 1, 0.1f Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); //向中心點縮小 ####用xml建動畫流程建res/anim目錄,寫alpha.xml,android studio會自動產生對應的code在gen/R.java &lt;set ...&gt; &lt;alpha ... /&gt;&lt;/set&gt; Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha); Interpolator用途示範插值器 補插動畫效果 Frame-by-Frame&lt;animation-list ...&gt; &lt;item android:drawable="..." android:duration="500" /&gt;&lt;/animation-list&gt; imageview.setBackgroundResource(R.drawable.animff);AnimationDrawable ad = (AnimationDrawable)imageview.getBackground();ad = AnimationUtils.loadAnimation(this, R.anim.alpha); LayoutAnimationController控制layout group中動畫的順序 ####從java建立Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha);LayoutAnimationController lac = new LayoutAnimationController(animate);lac.setDelay(0.5f);lac.setOrder(LayoutAnimationController.ORDER_NORMAL);listview.setLayoutAnimation(lac); ####從xml導入&lt;LayoutAnimation delay="0.5" animationOrder="normal" animation="@anim/alpha"/&gt; &lt;ListView layoutAnimation ="@..."/&gt; AnimationListeneranimation.setAnimationListener(new AnimationListener()&#123; onAnimationStart() onAnimationEnd() onAnimationRepeat()&#125; ValueAnimator ValueAnimator : 類似以值的變化形容動畫 類似補差值 ObjectAnimator : 將ValueAnimator套用到Object上 ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); animator.setDuration(5000); animator.start(); //組合多個動畫ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); //在xml定義anim_file.xmlAnimator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file); animator.setTarget(view); animator.start(); Activity overridePendingTransition方法需要在startAtivity方法或者是finish方法調用之後立即執行 overridePendingTransition(R.anim.zoomin, R.anim.zoomout)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2Fhome%2F%2FJava%2FThread.html</url>
    <content type="text"><![CDATA[相關知識 program : binary code,一段機械碼或可被執行的檔案 process : 執行一個program後形成一個process,其中包含一塊記憶體空間(code/heap). process間是不共用的,互相通信需特殊的機制 thread : 實際執行程式碼的單元 包含stack與cache儲存變數與參考 task : 任務,軟體概念,如同Runnable介面 yield : 類似sleep 但不能指定時間 目的在於讓出cpu時間給同優先級的執行緒 (針對非timeslicing作業系統) Concurrency(並發) vs Parallelism(並行) 與thread數量無絕對關連 與資源共用有關資源可以指時間或執行緒或資料物件例如javascript中共享執行緒的異步執行(協程)(Promise)就屬於併發的應用 並發 : 一個資源 輪流供應多個人使用 (共用需要使用鎖)(有能力處理一起發生的事件,但未必一起執行) 並行 : 每個人有各自的資源 雖同時進行 但互不相干 Thread 其應用通常與Lock息息相關 Daemon Thread 守護線程 又稱background thread 其生命週期中斷於程式的其他thread全部結束 例如GC線程setDaemon(true) corutine 協程 由編譯技術實現 被視為輕量級thread 應該是依附在thread 用於異步執行 透過async/await讓工作不立即執行 且能夠被等待 相當於排程的概念 更有效率的使用thread 例如 : 在main thread中連續執行ABC三函數 一般情況下執行的順序是ABC 若B能進入異步 順序會變為AC…B (B不確定何時執行) 若B能進入異步 且C能等待B執行完 順序又變回ABC 假若B在異步執行時是透過其他thread 那C等待B時main thread還能繼續其他工作 async&#123; value = await getData();&#125; Thread Poolref ExecutorService 即thread pool的實現 Executor介面類 即execute() 供ExecutorService實現 Executors工具類 便於產生ExecutorService 內部有一個BlockingQueue存放任務 每個thread如同一個looper等待取得task Thread的切換一個流程中某些動作必須跳到異步執行 待執行完再切回原本的thread 這些切換thread的動作將使一個流程無法順暢的寫完 舉例: user按下執行按鈕 (ui) 下載url的內容 (network) 存成本地檔案 (i/o) 取得執行狀況 將內容顯示於ui (ui) message handler 適合簡單的切換 多個連續流程仍難以處理 範例 切換越多次巢狀越明顯 public class AppExecutors &#123; //seeu 建立Thread切換機制 private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors() &#123; diskIO = Executors.newSingleThreadExecutor(); networkIO = Executors.newFixedThreadPool(THREAD_COUNT); mainThread = new MainThreadExecutor()); &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; private static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; ForkJoinPool專處理可併行的任務 將任務(ForkJoinTask)切割執行於pool中 運用於Collection.ParallelStreams中 //ForkJoinTask大致寫法@Overrideprotected Integer compute() &#123; if(!needSplit)&#123; return sum(); &#125;else&#123; int middle = (start + end) / 2; CountTask task1 = new SumTask(start, middle); CountTask task2 = new SumTask(middle+1, end); //執行分割任務 task1.fork(); task2.fork(); return task1.join() + task2.join(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Room]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRoom.html</url>
    <content type="text"><![CDATA[TypeConverter 建立物件與database primitive type的轉換 data class Word( @SerializedName("naText") var naText: String, @SerializedName("taText") var taText: String)//透過TypeConverter建立object與json字串的轉換class WordConverter &#123; @TypeConverter fun word2Json(words: ArrayList&lt;Word&gt;): String &#123; val json = Gson().toJson(words) return json &#125; @TypeConverter fun json2Word(json: String): ArrayList&lt;Word&gt; &#123; val turnsType = object : TypeToken&lt;ArrayList&lt;Word&gt;&gt;() &#123;&#125;.type val list = Gson().fromJson&lt;ArrayList&lt;Word&gt;&gt;(json, turnsType) return list &#125;&#125;@Entity(foreignKeys = [ForeignKey(entity = BookInfo::class, parentColumns = ["id"], childColumns = ["bookId"], onDelete = CASCADE)])@TypeConverters(WordConverter::class) //加入需要的TypeConverterdata class BookContent(@PrimaryKey(autoGenerate = true) var id: Long, var bookId: Long, var words: ArrayList&lt;Word&gt; = ArrayList&lt;Word&gt;()) ForeignKey (外鍵) 使該table(child)與外界的table(parent)連動 例如一起被刪除 Embedded 在table中坎入其他table或pojo class 避免宣告裡必須攤平所有欄位失去結構 可作為查詢時暫用的表 實際的解析上有點像是將Embedded表的欄位名(變數名)平面化 所以各個表中的欄位名還不能重複 若重複還要加prefix將整個表的欄位名加前綴 select語句針對prefix的部分必須一一列出(太麻煩了) SELECT *, tbl_b.id as prefix_id FROM tbl_a INNER JOIN tbl_b ON tbl_a.id=tbl_b.id WHERE ... Relation 可以建立一個連動的查詢 整合到一個table中 (用起來方便但要多建一個class) @Entitydata class BookSet( @Embedded var info: BookInfo?=null,//BookContent.bookId對映BookInfo.id//查詢的結果必須是List或Set @Relation(parentColumn = "id", entityColumn = "bookId") var content: List&lt;BookContent&gt;?=null) Migration 升級]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB-MySQL]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDB-MySQL.html</url>
    <content type="text"><![CDATA[SQLiteOpenHelperref public class DBHelper extends SQLiteOpenHelper &#123; public DBHelper(Context context) &#123; super(context, "mydb.db", null, 0); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("CREATE TABLE IF NOT EXISTS user(\ _id INTEGER PRIMARY KEY AUTOINCREMENT, \ name TEXT)" ); &#125;&#125;dbHelper = new DatabaseHelper(context);SQLiteDatabase db = dbHelper.getWritableDatabase();SQLiteDatabase db = dbHelper.getReadableDatabase();db.close();//insertContentValues values = new ContentValues();values.put("id", 1);values.put("name", "jim");db.insert("user", null, values);db.execSQL("insert into user (id,name) values (1,'carson')") //updatevalues.put("name", "jim2");db.update("user", values, "_id=?", new String[] &#123; "1" &#125;);db.execSQL("update [user] set name = 'jim2' where _id=1");//deletedb.delete("user", "_id=?", new String[]&#123;"1"&#125;);db.execSQL("delete from user where _id=1");//seleteCursor c = db.rawQuery("select * from user where id=?",new Stirng[]&#123;"1"&#125;);c = db.rawQuery("SELECT _id, name FROM user");c = db.query("user", new String[] &#123; "_id", "name" &#125;, "_id=?", new String[] &#123; "1" &#125;, null, null, null); Cursor//遍歷1while (c.moveToNext()) &#123; int idx = c.getColumnIndex("_id"); //取得欄位idx int id = c.getInt(idx); //取得資料&#125; //遍歷2c.moveToFirst(); while(!c.isAfterLast())&#123; //dosomething c.moveToNext(); &#125;//記得關閉c.close(); 將db檔預先置入apk 將寫好的db放到res/raw下 在開啟db前將資源寫入android檔案系統 InputStream myInput = context.getResources().openRawResource(R.raw.database);File file = context.getDatabasePath("mydb.db");if (!file.exists()) &#123; try &#123; OutputStream myOutput = new FileOutputStream(file); byte[] buffer = new byte[1024]; int length; while ((length = myInput.read(buffer))&gt;0)&#123; myOutput.write(buffer, 0, length); &#125; myOutput.close(); myInput.close(); mIsDBOK = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Task]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTask.html</url>
    <content type="text"><![CDATA[Activity.runOnUiThread activity內建的一方法 便於異步切回main thread AsyncTaskref aad : Execute a background task inside of a Service thread pool+handler應用的再封裝 易於與main(UI) thread切換 需在main thread建立與執行 (最終記得cancel) 如同Thread一次性使用 結束後無法重新啟動 class MyTask extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123;//&lt;傳入型態, 進度值型態, 結果型態&gt; @Override public Bitmap doInBackground(String ...args)&#123; //進入異步 不要做view操作 publishProgress(...); activity.runOnUiThread &#125; onPreExecute() //回main thread onProgressUpdate(Integer... values) //回main thread onPostExecute(Bitmap bitmap) //回main thread&#125;new MyTask().execute("str"); CountDownLatch// 1.設定好要count down的數量final CountDownLatch countDownLatch = new CountDownLatch(1);// 2.在異步thread結束後countDown使其歸零countDownLatch.countDown();// 3.一直等到countDownLatch為0才返回countDownLatch.await(); Timer &amp; TimerTaskTimer timer = new Timer()timer.schedule(new TimerTask() &#123; @Override public void run() &#123; //... &#125;&#125;, 1000, 1000);timer.cancel() Looper + Handler Looper消息接收器 建立時連帶建立一個MessageQueue Handler消息處理/發送器 用途在於將msg或task隊列執行 Looper與Handler內部都是利用current thread做為key 所以建立與呼叫時所處的thread很重要 //自訂的class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; //以當下thread建立looper (內部會存於map中) Looper.prepare(); //以當下thread建立Handler 並取得當下thread的looper中的MessageQueue //於是looper與handler都有共通的msgQueue //之後外部可用handler建立傳遞msg進入msgQueue //loop即能收到msg並透過msg的callback回叫handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; &#125; &#125;; //以當下thread執行loop (當下thread會進入等待msg的loop而block住) Looper.loop(); &#125;&#125; MessageQueue 內部是透過native code實現主要機制 HandlerThread 同上方範例 但沒有handler public void download2(String url) &#123; HandlerThread ht = new HandlerThread("MyHandlerThread"); ht.start();//必須先啟動thread (執行prepare後looper才會建立) //直接指定Handler的looper Handler handler = new Handler(ht.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //H:MyHandlerThread System.out.println("H:"+Thread.currentThread().getName()); if (msg.obj=="quit") getLooper().quit(); &#125; &#125;; handler.post(new Runnable()&#123; public void run()&#123; //R:MyHandlerThread System.out.println("R:"+Thread.currentThread().getName()); &#125; &#125;); handler.obtainMessage(0, "url").sendToTarget(); handler.obtainMessage(0, "quit").sendToTarget();&#125; main thread預設已執行prepare 所以在main thread下Handler能直接使用]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[壓力循環測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMonkeyTest.html</url>
    <content type="text"><![CDATA[Android測試 adb (android debug bridge)Android SDK本地端執行程式 crash / anr(activity not responding) //列出deviceadb devices//進入手機shell (如果Permission denied可執行su)adb shell//到安裝路徑cd /data/data/com.jimliuxyz.vocabook.mock///安裝apkadb install package.apk//取得 device logadb logcat monkeyAndroid OS上的測試程式 monkey 自動壓力測試(隨機操作)//執行測試 (隨機點擊操作)adb shell monkey 100//執行100個操作 每1000ms執行一次 以50為操作seedadb shell monkey -p tw.com.langstar.t1 -v -s 50 --throttle 1000 100-v : detial info-s : seed操作種子 固定的種子能複製出同樣的操作行為--pct-touch : touch操作的百分比--ignore-crashes : crash後自動重啟再測試---//手機內存放anr的log目錄data/anr monkey 自訂測試腳本//Android SDK內建的UI元件檢視器 能查詢執行中的app/Users/jimliu/Library/Android/sdk/tools/bin/uiautomatorviewer//上傳檔案adb push myscript /data/local/tmp//執行測試 (隨機點擊操作)adb shell monkey -f /data/local/tmp/myscript 100 // 點擊DispatchPointer(downtime,eventide,press:0/release:1,x,y,pressure,size,metastate,xpresision,ypresision,device,edgeflags)DispatchPointer(10,10,0,100,100,1,1,-1,1,1,0,0)DispatchString(mystr)//manifest的activity須加exported="true"屬性LaunchActivity(package, package + ActivityName)UserWait(1000) //msDispatchPress(66) //keycode monkeyrunnerAndroid SDK本地端程式/Users/jimliu/Library/Android/sdk/tools/bin/monkeyrunner從本地端執行python控制測試流程 可抓圖 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#MonkeyRunner.alert("msg", "title", "okText")device = MonkeyRunner.waitForConnection(3, "emulator-5554")device.startActivity("package/package.activityname")MonkeyRunner.sleep(2)device.touch(100, 100, "DOWN_AND_UP")device.type("string")device.press("KEYCODE_ENTER", "DOWN_AND_UP")image = device.takeSnapshot()image.writeToFile("./test.png", "png") monkeyrunner demo.py]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShellCmd]]></title>
    <url>%2Fhome%2FLinux%2FSingle%2FShellCmd.html</url>
    <content type="text"><![CDATA[refref # 搜尋執行檔路徑 (依環境path)which gitwhereis git# 依檔名尋找檔案find / -name gitfind grep awk# 資料夾中搜尋文件內容grep -r '導航' ~/GoogleDrive/grep -r --include="*.java" "service" .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[頁面導航]]></title>
    <url>%2Fhome%2F%2FAndroid%2FNav.html</url>
    <content type="text"><![CDATA[task back stack行為設定參考官方中文說明Android 深入ActivityAndroid基礎知識 launchMode intent flag minifest activity Deep Link(App Links) 超連結啟動apprefref aad:Implement non-standard task stack navigation (deep links) &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;!--從adb啟動--&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!--從browser啟動--&gt; &lt;data android:scheme="app" android:host="jimliuxyz.com"&gt;&lt;/data&gt;&lt;/intent-filter&gt; adb shell am start -W -a android.intent.action.VIEW -d "app://jimliuxyz.com" com.jimliuxyz.tsnoteam : activity maneger-W : wait for launch to complete[-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;]package不一定要 如果要用override fun onNewIntent()處理 activity要為singleTop之類 TaskStackBuilderrefref 用於憑空建立parent activity於TaskStack中當MsgActivity是從其他app(intent或deep link)啟動時 並沒有自己的back stack 所以按下back按鈕時 無法回到MainActivity 此時就需要NavUtils工具 Minifest 指定android:parentActivityName為欲返回的MainActivity &lt;activity android:name="com.example.myfirstapp.MsgActivity" android:label="display_message" android:parentActivityName="com.example.myfirstapp.MainActivity" &gt; &lt;!-- Parent activity meta-data to support 4.0 and lower --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.myfirstapp.MainActivity" /&gt;&lt;/activity&gt; //通常都經由ActionBar左上角的箭頭驅動返回事件(android.R.id.home)getActionBar().setDisplayHomeAsUpEnabled(true); //測試不okIntent upIntent = NavUtils.getParentActivityIntent(this);if (NavUtils.shouldUpRecreateTask(this, upIntent)) &#123; //非處於自己app的back stack中時 TaskStackBuilder.create(this) .addNextIntentWithParentStack(upIntent) .startActivities();&#125; else NavUtils.navigateUpTo(this, upIntent); 透過PendingIntent預先設定好(測試ok)notify-user Intent intent = new Intent(this, MsgActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addNextIntentWithParentStack(intent); //依manifest設定的android:parentActivityNamepi = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); launchMode manifest可設定activity的android:launchMode standard : 不斷新建堆疊a - a&apos; - a&apos;&apos; singleTop : 同standard,但當該activity已處於stack top時不會再新建a - a - a - b - a&apos; - a&apos; singleTask : 不會重開,該activity出現時勢必將task中其他task全部拋掉a - a - b - c - d - a [back]離開app singleInstance : 不會新建,該activity的task僅允許自己使用a - a - a [back]離開a回到b b - [back]離開b回到home 簡述 standard - 不斷重開堆疊 : 預設 (可能有多個aty重複) singleTop - 頂端不新建 : 合理避免重複 (可能有多個aty重複) singleTask - 頂端排他 task pop all : Home singleInstance - 獨佔 : 供別的app使用 single指的是activity不新建 但會執行onNewIntent() taskAffinity allowTaskReparentingaffinity類似一個groupId的概念 activity預設的affinity為package name當一個activity以FLAG_ACTIVITY_NEW_TASK啟動時會以affinity去找該被加到哪個task中 FLAG_ACTIVITY透過intent開啟的activity該依循何策略進入task或操作stack FLAG_ACTIVITY_NEW_TASK(同singleTask) : aty會在自己的task中 new aty : 為aty新增tasknew aty : push進aty原屬的taskold aty : 顯示task但aty不會到top (怪怪的) FLAG_ACTIVITY_CLEAR_TOP : pop出原本在其上者 b是FLAG_ACTIVITY_CLEAR_TOPa - b - c - d - b (此時cd會被pop出,剩下ab) FLAG_ACTIVITY_BROUGHT_TO_FRONT : activity會to front FLAG_ACTIVITY_MULTIPLE_TASK : 能以另一個task啟動(act實體個別存在不同的task) FLAG_ACTIVITY_SINGLE_TOP(同singleTop) FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET與FLAG_ACTIVITY_RESET_TASK_IF_NEEDED : 1.設定清除點 2.pop掉清除點與之後的 還有很多…]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIntent.html</url>
    <content type="text"><![CDATA[概述 一個意圖/命令的容器putExtra僅能傳遞native type,或序列化物件(Serializable或Parcelable) 顯示 : 指定元件的類別 隱式 : 僅提供ACTION/CATEGORY/URI 不指定元件的類別 intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(file), "image/*");startActivity(intent);intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://..."));startActivity(intent); Intent導航與返航####導航 //啟動startActivity(intent)startActivityForResult(intent, req_id) //透過activity或fragment呼叫//被啟動override fun onCreate(savedInstanceState: Bundle?) //首次啟動override fun onNewIntent(intent: Intent?) //已啟動 但有新intent ####返航 setResult() //均透過activityoverride fun onActivityResult(int requestCode, int resultCode, Intent data) fragment有startActivityForResult與onActivityResult,但沒有setResult PendingIntent 封裝執行intent的機制 類似於將startActive/startService與intent封裝起來 丟給系統 透過系統機制讓user觸發intent此外尚有些flag策略 通常就是和Notification合用 Notification 位於手機上方的通知欄 可作為service的ui使其能顯示狀態與被使用者操作 //NotificationManagernm = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);//Intentintent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);//PendingIntentpi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);//NotificationCompat.Builderbuilder = new NotificationCompat.Builder(this, "practice_channel") .setSmallIcon(android.R.drawable.ic_dialog_info) .setContentTitle(getString(R.string.time_to_practice)) .setContentText(getString(R.string.it_is_time_to_practice)) .setAutoCancel(true) .setContentIntent(pi);//產生與取消nm.notify(NOTIFICATION_ID, builder.build());nm.cancel(NOTIFICATION_ID);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android CheatSheet]]></title>
    <url>%2Fhome%2F%2FAndroid%2FCheatSheet.html</url>
    <content type="text"><![CDATA[//下載圖片img = Drawable.createFromStream(new URL(url).openStream(), "");//顯示短暫訊息Toast.makeText(this, "...", Toast.LENGTH_SHORT).show();getResources().getStringArray(R....);getResources().getXml(R....); //XmlResourcesParsergetAssets().open("...")getSystemService(Service...)//URIMediaStore.Images.Media.INTERNAL_CONTENT_URI 查看activity back stackadb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' | sed -En -e '/com.jimliuxyz/p']]></content>
      <tags>
        <tag>Android</tag>
        <tag>Cheat Sheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[協助工具]]></title>
    <url>%2Fhome%2F%2FAndroid%2FHelpingTools.html</url>
    <content type="text"><![CDATA[uiautomatorviewer 檢視View階層 (方面找ID) cd ~/Library/Android/sdk/tools/bin/ uiautomatorviewer draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStackadb shell dumpsysadb shell dumpsys Android-Debug-Databaseref, 本地端連結 dependencies &#123; debugImplementation 'com.amitshekhar.android:debug-db:1.0.0'&#125; # Working with emulatorcd /Users/jimliu/Library/Android/sdk/platform-tools./adb forward tcp:8080 tcp:8080 LeakCanaryLeakCanary 檢測記憶體洩漏 (針對activity生命週期) dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'&#125; public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) return; LeakCanary.install(this); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功能測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTesting.html</url>
    <content type="text"><![CDATA[JUnit 僅於本地JVM上測試 又稱單元測試(函數功能測試) 不依靠android環境 以滑鼠右鍵選單”Go To&gt;Test”快速建立test class Annotation @Test 註解一函數為 測試使用 @Test(expected = Exception.class) 使符合預期時拋出異常 @Test(timeout=100) 指定測試需在100ms內完成 @Before 註解一函數為 每個測試函數執行要先執行的函數 @After 邏輯同上 @BeforeClass @AfterClass 邏輯同上 但僅為整個class執行一次 @Mock 宣告一個假物件 @Captor 宣告一個叫用參數捕捉器(以取得叫用參數) @Spy 監視一個真物件 @Rule 修飾TestRule Matchers 比對器 類似過濾行為 能以廣義的形容區別物件 eqis 是某個objectisA 是某個classnotanyInthasItem Assert 斷言結果 判斷值是否符合預期 若不符合斷言即為測試失敗 //斷言結果需為trueassertTrue("test failure", mockins.func() == 1);//斷言instance.func()執行回傳為1assertThat("test failure", mockins.func(), is(1)); //用Matcher判斷assertThat(mockins.getList(), not(hasItem(not_expected));//assertEquals mockito 製作假物件ref 通過製作假物件與指定其反應回傳 來驗證該假物件是否被呼叫?以何參數呼叫? 通常被測物需為真物件(因為要測試他的邏輯) 其依賴物為假物件(不著重邏輯是否正確或回傳什麼 僅著重是否被真物件正確叫用) //1. 產生mock物件@Mock MyClass mockIns; //不需要newMockitoAnnotations.initMocks(this); //但之後要做init使class內的@Mock生效//1. 產生mock物件LinkedList mockList = mock(LinkedList.class);LinkedList mockList = mock(LinkedList.class, Mockito.RETURNS_SMART_NULLS); //指定預設的回傳//2. 指定mock物件的反應 (此動作稱為Stubbing)when(mockList.get(0)).thenReturn("it's a mock string");when(mockList.get(1)).thenThrow(new RuntimeException());when(mockList.get(anyInt())).thenReturn("element");when(mockList.size()).thenReturn(1, 2, 3); //每次回傳都不同//doReturn, doThrow, doAnswer, doNothing, doCallRealMethoddoThrow(new RuntimeException()).when(mockList).clear();reset(mockList); //清除所有Stubbing//3. 經過某些動作操作後...即可進入驗證mockedList.add("once");//驗證1. 驗證mock物件的方法是否被呼叫(times, atLeast, atMost, atLeastOnce, never, timeout)verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); verify(mockedList).set(anyInt(), eq("element")); //用Matchers便於廣義的驗證//驗證2. 連帶驗證呼叫順序InOrder inOrder = inOrder(mockedList);inOrder.verify(mockedList).add("first");inOrder.verify(mockedList).add("second");//驗證3. 捕捉呼叫參數ArgumentCaptor&lt;String&gt; args = ArgumentCaptor.forClass(String.class);mockedList.add("John");verify(mockedList).add(args.capture()); //驗證add的叫用 同時捕捉叫用的參數assertEquals("John", args.getValue()); spy監視真物件List list = new LinkedList();List spy = spy(list);//之後spy即類似mockito的操作 TestRule 能在測試函數前後插入動作 例如偵測測試函數的執行時間 加入TestRule時需用@Rule註解才能與JUnit掛鉤 public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; //base : 一個能夠驅使測試函數被執行的物件 //description : 一個相關於測試函數環境的描述 return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; //即測試前 base.evaluate(); //即測試後 &#125; &#125;; &#125;&#125;@RuleMyRule rule = new MyRule() EspressoAndroid testing samples 依賴於JUnit的一個測試框架 UI測試 依靠android環境執行 針對view元件進行驗證 基本三步驟 取得view或data的互動 onView / onData 執行動作 perform 檢查驗證 check 大致動作//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); onView ViewInteraction onView(Matcher viewMatcher) 透過matcher取得view的控制 //Matcher&lt;View&gt;allOf 合併多個matcherwithIdwithTextisDisplayed//其父view的id為R.id.recyclerViewisDescendantOfA(withId(R.id.recyclerView))//其父view為ListView.classisDescendantOfA(isAssignableFrom(ListView.class))hasDescendanthasSibling perform ViewInteraction perform(final ViewAction… viewActions) 執行動作 //ViewActionclick()LongClick()clearText()replaceText("")typeText("")closeSoftKeyboard()//專為RecyclerView設計(actionOnItem)onView(allOf(withId(R.id.recyclerView))) .perform(actionOnItem(hasDescendant(withText("title")), click())); check ViewInteraction check(final ViewAssertion viewAssert) 斷言 //ViewAssertionmatches(isDisplayed()) //使用view matcher來斷言doesNotExist()isChecked() 其他pressBack() //按下返回鍵TestUtils.rotateXXX() //控制手機旋轉TestUtils.getCurrentActivity() TestUtils 一個工具類 提供靜態方法控制手機裝置 rotate / getCurrentActivity 自訂Matcher//一個回傳Matcher的functionprivate Matcher&lt;View&gt; withItemText(final String itemText) &#123; return new TypeSafeMatcher&lt;View&gt;() &#123; @Override public boolean matchesSafely(View item) &#123; return allOf( //其父view為ListView.class isDescendantOfA(isAssignableFrom(ListView.class)), //且text為itemText withText(itemText) ).matches(item); &#125; @Override public void describeTo(Description description) &#123; description.appendText("is isDescendantOfA LV with text " + itemText); &#125; &#125;; &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2Fhome%2F%2FAndroid%2FContentProvider.html</url>
    <content type="text"><![CDATA[Loader Fetch local data from disk using a Loader on a background thread Propagate data changes through a Loader to the UI refvideo 簡單理解為一個監聽器介面機制 很主要目的在實現LiveData(即時資料顯現)(ContentObserver) Activity重建時LoaderManager中已建立的Loader不需重建 能透過id續用 AsyncTaskLoader (abstract extends Loader) 分離IO與UI使用的執行緒 因為ContentProvider執行的thread是caller提供的 透過AsyncTaskLoader能讓caller處於非main thread 避免影響ui CursorLoader (extends AsyncTaskLoader) 建立cursor並透過cursor監聽uri是否被通知為變更 若是則Loader會叫用callback 使用loader//實作介面this implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;override fun onCreateLoader(id: Int, args: Bundle?): Loader&lt;Cursor&gt; &#123; //要求建立cursor (語句與用contentResolver.query建立時相同) return CursorLoader(this, URIContract.MyEntry.URI, arrayOf("_id", "value", "time"), null, null, null)&#125;override fun onLoadFinished(loader: Loader&lt;Cursor&gt;?, data: Cursor?) &#123; //loader建立完成 (cursor設定監聽的uri) data?.setNotificationUri(contentResolver, URIContract.MyEntry.URI) adapter!!.swapCursor(data)&#125;override fun onLoaderReset(loader: Loader&lt;Cursor&gt;?) &#123; //loader需被結束(釋放資源) adapter!!.swapCursor(null)&#125;//建立CursorAdapteradapter = SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, null, arrayOf("value"), intArrayOf(android.R.id.text1), 0)var lv = findViewById&lt;ListView&gt;(R.id.lv)lv.adapter = adapter//啟動loader (啟動後的實體manager自己會管理)loaderManager.initLoader(0, null, this) 自訂Loaderpublic class StringLoader extends AsyncTaskLoader&lt;String&gt; &#123; private String mCache; public StringLoader(Context context) &#123; super(context); &#125; @Override protected void onStartLoading() &#123; if (mCache != null) &#123; //跳過loadInBackground super.deliverResult(mCache); &#125; else &#123; //驅動loadInBackground與deliverResult達到資料更新 forceLoad(); &#125; &#125; @Override public void deliverResult(String data)&#123; mCache = data super.deliverResult() &#125; @Override public String loadInBackground() &#123; return "data"; &#125; @Override public void onReset()&#123; //結束該loader 釋放資源 super.onReset() &#125;&#125; ContentProviderrefref 行為 提供資料存取的獨立個體 應該是被動的存在 有權限的約束 Activity靠ContentResovler與ContentProvider聯繫 以uri指定資源的路徑 回傳Cursor給外部使用 MINE type 即 類型/子類型 (應用類型/文件類型) 例如 text/html ContentProvider的應用類型固定為cursor 文件類型可以自訂 "vnd.android.cursor.dir/multi" //multiple record"vnd.android.cursor.item/single" //single record uri ContentUris URI解析工具 //建立uriUri uri = Uri.parse("content://com.jxyz.provider/user") //添加iduri = ContentUris.withAppendedId(uri, 5); //取出idlong personid = ContentUris.parseId(uri); UriMatcher URI比對工具 matcher = new UriMatcher(NO_MATCH); //不匹配時回傳NO_MATCHmatcher.addURI("com.jxyz.provider", "user", USER); //匹配回傳URI_USERmatcher.addURI("...", "user/#", USER_ID); //# : intmatcher.addURI("...", "user/info/*", USER_NAME); //* : stringswitch(matcher.match(uri))&#123; case URI_USER: ...&#125; ContentObserver 監視uri對應內容的變化 //監聽uri變動contentResolver.registerContentObserver(uri, true, mContentObserver)//通知uri變動contentResolver.notifyChange(uri, null);//要求cursor監聽uri (使CursorLoader能自動更新)cursor.setNotificationUri(context.contentResolver, uri) 權限//宣告本app自訂的權限&lt;permission android:name="com.jxyz.provider.READ" android:protectionLevel="normal"/&gt;//provider就可用該權限指定需要受約束的元件&lt;providerandroid:name=".MyProvider"android:authorities="com.jxyz.provider"android:readPermission="com.jxyz.provider.READ"android:exported="true"&gt;&lt;/provider&gt;//其他app若要有該權限 則需如下宣告讓user同意該使用權限&lt;uses-permission android:name="com.jxyz.provider.READ"/&gt; public class MyProvider extends ContentProvider &#123; private Context mContext; DBHelper mDbHelper = null; SQLiteDatabase db = null; //Application.instance.packageName() + ".provider" public static final String AUTOHORITY = "com.jxyz.provider"; public static final int USER_CODE = 1; public static final int USERID_CODE = 1; private static final UriMatcher mMatcher; static&#123; mMatcher = new UriMatcher(UriMatcher.NO_MATCH); mMatcher.addURI(AUTOHORITY,"user", USER_CODE); mMatcher.addURI(AUTOHORITY,"user/#", USERID_CODE); &#125; @Override public boolean onCreate() &#123; mContext = getContext(); mDbHelper = new DBHelper(mContext); db = mDbHelper.getWritableDatabase(); //init mock db.execSQL("delete from user"); db.execSQL("insert into user values(1,'Carson');"); db.execSQL("insert into user values(2,'Kobe');"); return true; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; db.insert("user", null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; int code = mMatcher.match(uri); if (code == USERID_CODE)&#123; long userid = ContentUris.parseId(uri); &#125; //後續資料如需傳遞到ListView中 需有_id欄位 return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null); &#125; @Override public String getType(Uri uri) &#123; switch(mMatcher.match(uri))&#123; case USER_CODE: return "vnd.android.cursor.dir/multi"; case USERID_CODE: return "vnd.android.cursor.item/single"; &#125; return null; //封閉的app也可以直接回null &#125;&#125; 訪問ContentProviderContentResolver resolver = getContentResolver();//insertContentValues values = new ContentValues(); values.put("_id", 5); values.put("name", "allen");resolver.insert(uri, values);//queryCursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null);//updaterui = Uri.parse(uri + "/" + "7");int result = resolver.update(uri, values, null, null);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2Fhome%2F%2FAndroid%2FActivity.html</url>
    <content type="text"><![CDATA[Activity重建與復用ref 畫面旋轉 或 變更語系 造成Activity重建 連帶影響狀態或物件需要重建 Bundle與Map類似 但key必須是string 用來存放資料 1. Minifest.xml中抑制重建 在minifest加入android:configChanges提示為自行處理 使Activity不進行重建 //android:configChanges="locale|layoutDirection"@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig);&#125; 2. onRetainCustomNonConfigurationInstance 與 getLastCustomNonConfigurationInstance 複寫onRetain將稍後要還原內容交給系統 被重建後再取回 @Overridepublic Object onRetainCustomNonConfigurationInstance() &#123; return netWorkTask;&#125; 3. Retain Fragment (官方建議使用) 設定setRetainInstance(true)即可讓Fragment復用不重建(app狀態須寫在Fragment中) (之後需注意activity/context的更動) //以下code看似在復用MyFragment,但事實上MyFragment仍會在背景被建立//除非fragment設定setRetainInstance(true)if(getSupportFragmentManager().findFragmentByTag(ID) == null) &#123; getSupportFragmentManager().beginTransaction().add(new MyFragment(), ID).commit();&#125; View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 並非所有Android提供的View都實現了狀態儲存 目前測試也僅有EditText 幾種離開Activity的差異 狀況隨android會有所不同…隨機應變 關閉螢幕 與 切到別的app 一定會onSaveInstanceState 在stop中狀態中等待被恢復 暫時不會走onDestory() 恢復時會restart-&gt;start-&gt;resume 不會到restore(因為系統/UI狀態沒變) 螢幕翻轉 一定會onSaveInstanceState activity走向onDestory() 之後隨即再重建Activity 可在create與restore取得舊有狀態 透過back按鍵離開 或 呼叫finish() 離開時不會跑onSaveInstanceState 故既有的狀態復原路徑是無效的 activity走向onDestory() 但app仍保留在stack中 故app中的static或無法被回收的物件仍然進行中 (也能在之後復用) 直接在task中滑掉 或按x關掉 app完全關閉 所有app資源執行緒都將被關閉回收 連activity的onDestory()都不會被呼叫 app迅雷不及掩耳的被刪除 程式中無從得知正要被kill的事件 以保持app是隨時可以被kill的狀態 善用onStop()與適時建立Service 總結 不走onDestory表示稍後就可能被點選恢復 螢幕翻轉或語系改變之類因牽涉整體UI固有重建的需求 App半關 : 即所有Activity都被結束(不跑save state) 僅留static或thread運作 App全關 : 整個App全部強制結束]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view 與 Style]]></title>
    <url>%2Fhome%2F%2FAndroid%2FViewNStyle.html</url>
    <content type="text"><![CDATA[/Users/jimliu/Library/Android/sdk/platforms/android-26/data/res/values/styles.xml 容器類型的view ListView : 列表顯示 RecyclerView : 列表顯示 更為靈活 取代ListView ScrollView : 可滑動的顯示 gridview / gallery / cardview LayoutInflater layout的實體化工具 將layout resource轉成view的實例 Adapter 設計模式中稱作”適配器” 簡單的說就是轉換器 以view容器的應用來說 就是將’資料數據’轉換填充到’ListView裡的各個item view’上 //以simple_list_item_1做為item viewadp = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1);//替adp添加兩筆資料adp.add("first");adp.add("second");//將adp指定給listview使用lv = findViewById(R.id.listView);lv.setAdapter(adp); BaseAdapter@Overridepublic View getView(int pos, View convertView, ViewGroup parent)&#123; //getView用於取得item view //convertView : 先前已建立的view,用於優化效能&#125;notifyDataSetChanged(); //向view通知data有變動 view才會refresh ViewHolder 主要用意在復用item view時避免重複findViewByIdv.setTag(holder);holder = (Holder) v.getTag();//RecyclerView.Adapter不用這樣寫 SurfaceView 有自己的ui thread 用於較佔時間繪圖應用 (VideoView/ImageView) View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 自定義View / ViewGroupref 先分清元件與佈局的角色 大致 需要複寫onMeasure (父要求子做元件尺寸測量measureChildren) (子則量測自己) 量測完執行setMeasuredDimension ViewGroup需複寫 onLayout (排定子的繪出位置) 逐個叫用child.layout View需複寫 onDraw (繪製本身) MeasureSpec定義 為一整數 前3bit做為mode 之後作為size(寬或高) 做為父要求子做尺寸量測時的參考 (由父提供spec 子做量測) UNSPECIFIED : 沒有任何約束 EXACTLY : 約束明確的size AT_MOST : 約束上限的size LayoutParams 一個ViewGroup要遍歷所有子View的LayoutParams才知道每個子View要求被如何佈局 (所以是ViewGroup定義的 但由子View描述給其ViewGroup參照的) child.getLayoutParams Theme與Style aad:Construct a layout using XML or Java code aad:Create a custom view class and add it to a layout aad:Implement a custom application theme aad:Apply a custom style to a group of common widgets 兩者僅有使用廣度上的差別 theme針對app或activity, style針對元件, 基本上都是style 單位 dp : 1dp=160ppi的px長度 (像素隨密度改變)sp : 類似dp 用於文字pt : 點 用於文字px : 像素ppi, dpi : 像素密度 pixel per inch 每英寸像素數mm : 毫米in : 英吋 attr宣告 寫在values/attrs.xml 作為元件的屬性 (元件屬性是從xml建立的 java code僅是依資源ID取值賦予元件) attr及所有資源都會自動產生於R類中的id &lt;attr name ="mycolor" format= "color" /&gt; 屬性名稱一多容易重複混淆 用declare-styleable可將其分類 java code也會比較好讀取 //將多個attr並於declare-styleable有利組織化與讀取 在R類中會是一個resId的陣列&lt;declare-styleable name="MyStyle"&gt; &lt;attr name ="mycolor" format= "color" /&gt;&lt;declare-styleable&gt; attr的賦值//在元件標籤中賦值 (前半部需指定命名空間)&lt;TextView app: mycolor="#00ff00" android:style="@style/MyStyle"&gt;&lt;/TextView&gt; //在style/theme中賦值&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="mycolor"&gt;#0037ff&lt;/item&gt; &lt;item name="android:textViewStyle"&gt;@style/textviewstyle&lt;/item&gt;&lt;/style&gt; 元件取得attr的來源 一個元件的一個attr可能有多個來源 (大致的優先順序) 於元件標籤中或標籤中指定的style有描述 從application或activity指定的theme中有描述 theme中指定的style有描述 (即指android:textViewStyle)(format=”reference”) 元件hardcode裡有預設的style 元件取得attr obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) AttributeSet 即元件標籤中的描述 attrs 欲取得的attr defStyleAttr 預設的style的attr (在theme中經由該attr參考到確切的style)(即指android:textViewStyle) 透過這樣的機制就可在theme中複寫掉元件的整個style defStyleRes 預設的style 若沒有可丟0 public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0); TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.MyStyle, defStyleAttr, defStyleRes); int color = a.getColor(R.styleable.MyStyle_mycolor, Color.BLACK); a. recycle();&#125; 可見性的設定View.visableView.invisable : 看不見 但仍佔位置View.gone : 消失 不佔位置 模糊視窗(blur)getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND); ViewStub一個空的view 用來延遲載入另一個view時當作佔位用 SpannableString v.setText()通常傳入字串 更複雜可以傳入(html, img_getter, tag_handler) 另一種是傳入SpannableString 用途都是達到圖文混排 其他onTouch 和 onTouchEvent onTouch優先於onTouchEvent 若onTouch回傳true則事件就不會再往下傳播onTouch是作用於view處於enable狀態下]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Accessibility]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAccessibility.html</url>
    <content type="text"><![CDATA[Accessibility 無障礙能力官方EventAccessibilityServiceAccessibilityEventAccessibilityService aad:Apply content descriptions to views for accessibility aad:Add accessibility hooks to a custom view 自訂View時需要sendAccessibilityEvent 否則只要注意contentDescription focusable nextFocus]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android環境概念]]></title>
    <url>%2Fhome%2F%2FAndroid%2Fbasic.html</url>
    <content type="text"><![CDATA[編譯流程 Dalvik : Android的JVM dex : 類似jar appt：Android Asset Packaging Tool MinifestMinifest-activity參數 Contextref context可理解為app的執行環境 (包含狀態與工具) ContextWrapper會包含一個Context實例(mBase)達到複製Context Application與Activity與Service雖都能當context用(但非對應同一個mBase) 要注意Activity與Service是有被回收的可能 避免將其當context傳遞 但某些關聯性的動作只能使用activity(像是show dialog) //若context的傳遞會被對方持有時 盡可能使用Application的contextcontext.getApplicationContext() Application 繼承Context 可以理解為另外一個層級的執行環境透過Manifest指定自訂的Application類 &lt;!--Manifest--&gt;&lt;application android:name=".CustomApplication"&gt; SharedPreferencekey/value pair的儲存器 用於儲存app的設定值 MODE_MULTI_PROCESSMODE_PRIVATEsp = PreferenceManager.getDefaultSharedPreferences(context);sp = getSharedPreferences("mysp", Context. MODE_PRIVATE);sp.getBoolean("key", false);sp.edit().putBoolean("key", false);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fhome%2F%2Fgit%2FGit.html</url>
    <content type="text"><![CDATA[working space : 工作區 即源碼開發的目錄 commit history(repo) : 即提交歷史紀錄區 stage(index) : 緩存區 介於工作區與歷史區之間 add進了stage之後commit才會進repo 而不是讓工作區所有檔案都進repo patch : 即commit產生的紀錄點 master : git最初預設的分支 origin : 慣用的預設的遠端別名 用來表示某一個遠端的路徑 HEAD : 指向當下所處的base patch (可以用@符號) HEAD^ : 指HEAD的前一個patch 等同HEAD~或HEAD~1 HEAD@{2} : 歷史紀錄(reflog)的指向簡寫 detached HEAD : 脫離的HEAD(斷頭) 即HEAD未處於分支的末端(git checkout HEAD^) 之後若再建新的patch將難以合併回分支 ORIG_HEAD : 當merge或rebase時會留下的一個記錄點 用於合併出錯時的返回點 參考文章git reflog 查詢# 列出設定git config -lgit config --global -l# 查訊patchgit show HEADgit log --oneline # 當下repo版本的歷史git reflog # 所有操作歷史 (不會進遠端)# 比對git diff # 比對工作區not staged的檔案git diff --cached # 比對工作區與repogit statusgit branch 程式碼還原ref還原前須注意當下工作區與緩存區是否有工作尚未commit 可以先commit或stash做暫存patch checkout 切換patch(branch) 直接影響working space/stage/repo 在任何動前 最好都先知道自己在哪個branch下作業 或直接用checkout確保一定在某個branch下可針對個別檔案還原 resetref 重置回某patch版本可針對個別檔案還原 commit流程 : 修改檔案 -&gt; add進stage -&gt; commit進reporeset流程 : (hard)還原檔案 &lt;- (mixed)stage重置回未add &lt;- (soft)repo重置回某版本 將HEAD移到某patch(即變更repo的版本) 且之後的patch將於數十天後被GC刪除 reset的所有操作都被記錄在reflog中 最算reset沒有起任何作用 最好只在私有的本地分支進行 不要影響到遠端及其他開發者的base 模式 soft : 保留當下的stage與working space mixed(預設) : 保留當下的working space 但stage退回(如同未add) hard : 完全重置 revert 將某個patch逆向重做後當成一個新的patch 如同撤銷某個patch 雖會多一個patch但不會影響既有的history 暫存patch當工作到一半若要切換到其他patch或branch 但又不想commit當下的修改時 可以此法暫存之後再取回 stash 將工作區與緩存區暫存起來 再硬重置回HEADpop動作如同cherry-pick也會有conflict 所以要先回到正確的patch再popgit stash # 暫存git stash save "mywork" # 給定暫存訊息 git stash listgit stash pop stash@&#123;1&#125; # pop出來後就移出list了 合併ref首先要切到要進行合併的分支 cherry-pick 將其他分支中想要的patch複製成新的patch加到當下分支 rebase 將該分支的起點(交叉點)換到新的patch或branch (以cherry-pick實現)達人推薦的合併方式 merge –no-ff 將兩個分支合併產生一個merge patch被併的分支仍能保留末端節點 Fast-Forward指合併的兩個分支原本就重疊在一起 此時合併不需產生merge patch (就看不出分支的起點了) # rebase或merge出錯時 可以此返回合併前狀態git reset --hard ORIG_HEAD 解衝突ref # 完成解衝突git cherry-pick --continue# 取消pickgit cherry-pick --abort 同步遠端分支要push前或每日工作前先pull確保本地端base與遠端相同 一方面及時察覺新版本的變動 二方面確保push時順利 fetch 下載 pull 下載並merge pull –rebase 下載並以rebase合併]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知識樹]]></title>
    <url>%2Fhome%2F%2FAndroid%2F00.index.html</url>
    <content type="text"><![CDATA[開發紀錄 Cheat Sheet 入門知識IDE編譯流程GradleAndroidManifest.xml 供Android系統得知此app包含的組件內容與設定 class Context 可視為app執行環境(上下文) 許多操作都是需要有執行環境才能完成Application/Activity/Service都有各自的Context 但生命週期不同 class Application 做為app的single instance 相當於app的母生命週期 SharedPreferenceProcess 一段已載入記憶體執行的程式碼 例如一個執行中的app就是一個process Thread 實質執行程式碼的單元app中起始的thread稱為main thread又稱為ui thread 其最主要的工作為在每個16ms繪製一次畫面 若沒辦法如期執行就會造成畫面lag ResourceIntent每個app都是獨立的process 無法直接互動 Intent則做為之間互動的意圖/訊息內容. 透過intent描述欲執行的動作 交由android系統執行. 通常執行動作都是啟動某個app或service. PendingIntent PendingIntent會持有一個intent 交給android系統保留 如同委託系統代為於特定時機執行 (此時intent的執行與否已與建立該intent的app無關了) IntentFilter 對於能被intent啟動的對象來說(例如Service) 需要過濾不相干的意圖 (即需預先描述相關的意圖於Filter中) Notification 位於手機上方的通知欄 四大組件即Activity/Service/ContentProvider/Broadcast 這些組件的共通點就是能被別的app透過intent啟動或間接存取 四大組件生命週期互不相同 但都是經由系統實例化誕生 或依系統機制結束 我們僅能發送intent告知意圖 Activity可視為一個頁面的持有者 Activity重建與復用 Activity常有機會被系統重建 例如螢幕翻轉或語系更動 重建後可能造成狀態的喪失 Activity導航Deep Link 使app能透過超連結方式被開啟 TaskStack 相關於頁面的堆疊 即上一頁的功能 launchMode 指定TaskStack堆疊的策略 FLAG_ACTIVITY 用Intent開啟Activity的堆疊策略 Service可視為一個服務 服務能提供給自己或別的app 或常態的在背景默默執行Service衍生出了許多不同的類別 用以達到特定的需求 IntentService Service執行於main thread 但IntentService會切到worker thread佇列執行 JobService 與 JobScheduler 能依系統狀態約定任務的執行 例如有網路時才執行 使更有效率的驅動任務 節約電力 ContentProvider可視為一個資料提供者 提供資料給自己或別的app 透過特定的uri即可存取特定的ContentProvider 例如’電話簿聯絡人’等資訊就是透過ContentProvider運作 Cursor 可以理解為資料指針 其持有一群資料 透過指定cursor的位置即可取得某一筆資料 CursorLoaderBroadcast發送或接收廣播 例如系統電力不足時會發送廣播給有註冊的接收器 Fragment可視為一個頁面中的一小部分的持有者 用意在將整個頁面拆散 其生命週期基本上是依附Activity上 或由FragmentManager管理 Database MySQLAndroid內建的Database Thread / Task為了順利與容易的協調各式工作 各種衍生的類別孕育而生 Handler 一個透過當下執行緒建立的message handler 其目的在使工作能透過該執行緒佇列的被執行 可以作為執行時切換執行緒的手段 或當佇列安插異步工作於執行緒 Looper 一個透過當下執行緒建立的訊息接收器 其內部包含一個message queue 是促成Handler運作的背後推手 AsyncTask 建立一個異步工作 執行於worker thread 且提供機制與main thread互動 AlarmManager 安排定時任務(如鬧鐘般) 用PendingIntent設定 時間到開啟Activity或Service能夠喚醒Android系統 RecyclerViewView &amp; StyleLayoutWidget app widget 手機HomeScreen上的小工具 TestingJUnit Espresso Monkey 壓力循環測試 3rd Party LibraryDagger 依賴注入工具 何謂依賴? A物件需要B物件才能運作 B即為A的依賴物 將依賴物帶進A的實現方式即稱為依賴注入將各個物件實體的建立或獲取寫成函數方法 Dagger會建立其之間的依賴關係 並將依賴注入到物件中 RxJava ReactiveX 響應式編程 將數據流轉化為事件觸發 例如[1,2,3]會分別產生3個事件流之間可經由運算符號(即鏈式函數)加工產生新的流 Gson Json文件的解析 工具uiautomatorviewer 檢視View階層 (方面找ID) draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStack adb shell dumpsys Android-Debug-Database mysql網頁伺服器介面 LeakCanary 記憶體洩漏偵測 其他LruCache 快取 當空間吃緊時能首先移除掉近期最少使用的(Least recent used)三級快取(緩存)策略 即 記憶體中快取-&gt;本地端資料-&gt;網路資料 依其優先順序取得資料 以得到最快速度 Accessibility 輔助殘疾人士 使其便於操作app Animation 動畫 序列化Serializable / ParcelableSerializable 對於javaBean類只要implements Serializable 不用額外實現方法即可對primitive type序列化 特殊物件則須額外實現用反射實現 所以速度慢 Parcelable 要有一個名為CREATOR的靜態變數實現Creator 用以從序列還原物件要實現writeToParcel與createFromParcel (寫讀順序要對應)因為hard coding所以速度快 StorageRoom MySql的另一種操作方式 ArchitectureComponent LifeCycle與Observable的整合 使其產生LiveData 套用MVVM架構 debug過程 操作內建的debug工具 懸浮視窗ref 即將view依LayoutParams加到WindowManager做為remote view處理 inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);removeView = (RelativeLayout)inflater.inflate(R.layout.remove, null);windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);windowManager.addView(removeView, layoutParam); 雜項]]></content>
      <tags>
        <tag>Android</tag>
        <tag>知識樹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安裝紀錄]]></title>
    <url>%2Fhome%2F%E7%B4%80%E9%8C%84%2FSingle%2FHexo%E5%AE%89%E8%A3%9D%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[Hexo 、NexT 站內連結若用相對連結在首頁跟文章內顯示的連結路徑不同 UTF-8編碼中若參雜其他編碼會讓search.xml錯誤而無法搜索 md檔案若有尖括號未置入code tag 可能造成解析錯誤 目標本地端透過Hexo建立網站骨架 並將markdown文章轉為html 上傳到github做為blog網站 安裝node.js node.js為一本地端的js執行平台 用途廣泛 npm (安裝node.js時會一並安裝) 一個套件管理系統 能透過命令列安裝套件 安裝git 版本控管工具 做為本地端工具與github連結 github 一個線上的版本控管工具 其附加功能使其能成為http伺服器其Repo需命名為”ACCOUNT_NAME.github.io” #安裝hexo命令列工具npm install -g hexo-cli#在該目錄建立blog目錄hexo init blog#安裝node.js環境cd blognpm install#發佈到github的工具npm install hexo-deployer-git --save#使網頁能即時自動更新的工具(會造成一些問題 1.網頁空白 2.搜尋失效)(查問題時最好移除)npm install hexo-browsersync --save#下載慣用的blog主題佈局(NexT)git clone https://github.com/iissnan/hexo-theme-next themes/next#站內搜尋工具 (:category開頭會無法連結)npm install hexo-generator-searchdb --save 常規操作#新增文章hexo new "My New Post"#啟動本地端serverhexo server#產生文件hexo g --watch#上傳到githubhexo d 語法測試12345 1 2 測試 測試 測試 AB aaa bbb]]></content>
      <categories>
        <category>紀錄</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2Fhome%2F%2FAndroid%2FService.html</url>
    <content type="text"><![CDATA[Service app透過startService啟動service 執行於UI Thread 不會自動被系統結束 只能自己透過stopSelf結束 onStartCommand的回傳決定Service被系統殺掉後的行為 START_STICKY : Service被殺掉, 系統會重啟, 但是Intent會是null。 START_NOT_STICKY : Service被系統殺掉, 不會重啟。 START_REDELIVER_INTENT : Service被系統殺掉, 重啟且Intent會重傳。 Remote Service 同為Service僅是啟動/取得方式不同 主要用於跨process的應用 即透過bindService(intent, conn, BIND_AUTO_CREATE)取得binder實例操控service 以bindService啟動service會造成Service綁定於App的生命週期 用AIDL建立共通介面 內建已經做好了一個共通的binder 可以透過(Message(msg)).getBinder()建立 基本上是用handler處理message的方式傳遞訊息 (就不用建AIDL了) android:process屬性 : 可讓Service執行於自有的process上(remote service) 通常會設為:remote(這似乎屬於一個自訂的命名) Binder 在android中做process間通訊用 (底層機制應該是linux的share memory) AIDLref Android Interface Definition Language一種程式語言 用於定義介面 用於IPC(Process間通信) 與java的interface寫法類似 //IRemoteService.aidlpackage com.example.service;interface IRemoteService&#123; int getData(String key)&#125; 存成MyDataBinder.aidl,會被自動轉譯產生一個java檔,產生IRemoteService.Stub類別,作為server與client間共通的介面 server端實做IRemoteService.Stub的method即IBinder 並在onBind時回傳 client端也必須有該.aidl檔才能編譯 並透過IRemoteService.Stub.asInterface將IBinder轉為代理物件供使用 Remote Service範例實做介面//RemoteService.javapublic class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getData()&#123; return "hello"; &#125; &#125;;&#125; start service &amp; bind//Activity.java&#123; Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125;IRemoteService mIRemoteService;ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; public void onServiceDisconnected(ComponentName className) &#123; mIRemoteService = null; &#125;&#125;; IntentService Service的子類 需在manifest中宣告 Service+Handler+Looper的封裝 即類似一個task queue 當所有任務執行完時銷毀 有任務再重新建立 public class IntentServiceDemo extends IntentService&#123; public IntentServiceDemo(String name)&#123; //name for HandlerThread super(name); &#125; @Override protected void onHandleIntent(Intent intent)&#123; //進入異步 &#125;&#125;Intent intent = new Intent(this, IntentServiceDemo.class);startService(intent); JobService / JobSchedulerrefandroid-JobScheduler aad:Schedule a background task using JobScheduler Service的子類 排程不緊急或與設備狀態有關的任務(受系統牽制) 以優化系統電力消耗 在(&gt;=Build.VERSION_CODES.N)中限制了interval最小為15m flex最小為5m 比較適合惰性的任務 (時間不會準確) JobScheduler : 整個app僅有一個JobScheduler實體用來排程任務(丟入JobInfo) ComponentName : 一個pkg+cls用以描述元件 Component泛指四大組件 常用於Intent JobInfo : 指定任務執行模式 依時間/網路/Idel/充電 (透過Builder模式構建) 儲存extras當param給JobService執行 JobService : 當onStartJob時得到任務 回傳false表示任務已執行結束 回傳true表示任務進入異步執行 完成後須自行呼叫jobFinished 意象: JobService如同Service般執行 經由JobInfo建立不同任務的參數 由JobScheduler指派執行時機 呼叫JobService.onStartJob執行 執行於ui thread,耗時任務仍需另使用AsyncTask &lt;service android:name=".service.MyJobService" android:permission="android.permission.BIND_JOB_SERVICE" android:exported="true"/&gt; JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); onStopJob僅在系統強制要停止任務時呼叫 AlarmManagerref aad:Schedule a time-sensitive task using alarms 安排定時任務(time-sensitive task) 時間到用PendingIntent開啟服務或Activity 比起Java SE的Timer, AlarmManager能夠喚醒休眠的Android系統(透過PendingIntent) 被限制了interval最小為60s (時間不會準確) val intent = Intent(this, AlarmReceiver::class.java)val pi = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);val am = getSystemService(Context.ALARM_SERVICE) as AlarmManageram.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi)am.setRepeating(RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, pi);am.setRepeating(ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 1000 , 5 * 1000 , pi);class AlarmReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; &#125;&#125; &lt;receiver android:name=".AlarmReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; type(組合) RTC : 以系統時間判斷 (也就是說系統時間更改將立即反應到鬧鐘上) ELAPSED_REALTIME : 以系統流逝的時間差判斷 WAKEUP : 能於睡眠中喚醒 POWER_OFF_WAKEUP : 能於關機中喚醒]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FSingle%2Fmedia%2Fstyle.html</url>
    <content type="text"><![CDATA[@font-face { font-family: octicons-anchor; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff'); } body { background-color: white; } .markdown-body { min-width: 200px; max-width: 760px; margin: 0 auto; padding: 20px; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #333; overflow: hidden; font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif; font-size: 14px; line-height: 1.6; word-wrap: break-word; } .markdown-body a { background: transparent;;word-wrap: break-word; word-break: break-all; } .markdown-body a:active, .markdown-body a:hover { outline: 0; } .markdown-body strong { font-weight: bold; } .markdown-body h1 { font-size: 2em; margin: 0.67em 0; } .markdown-body img { border: 0; } .markdown-body hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; } .markdown-body pre { overflow: auto; } .markdown-body code, .markdown-body kbd, .markdown-body pre { font-family: monospace, monospace; font-size: 1em; } .markdown-body input { color: inherit; font: inherit; margin: 0; } .markdown-body html input[disabled] { cursor: default; } .markdown-body input { line-height: normal; } .markdown-body input[type="checkbox"] { -moz-box-sizing: border-box; box-sizing: border-box; padding: 0; } .markdown-body table { border-collapse: collapse; border-spacing: 0; } .markdown-body td, .markdown-body th { padding: 0; } .markdown-body * { -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body input { font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; } .markdown-body a { color: #4183c4; text-decoration: none; } .markdown-body a:hover, .markdown-body a:focus, .markdown-body a:active { text-decoration: underline; } .markdown-body hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } .markdown-body hr:before { display: table; content: ""; } .markdown-body hr:after { display: table; clear: both; content: ""; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 15px; margin-bottom: 15px; line-height: 1.1; } .markdown-body h1 { font-size: 30px; } .markdown-body h2 { font-size: 21px; } .markdown-body h3 { font-size: 16px; } .markdown-body h4 { font-size: 14px; } .markdown-body h5 { font-size: 12px; } .markdown-body h6 { font-size: 11px; } .markdown-body blockquote { margin: 0; } .markdown-body ul, .markdown-body ol { padding: 0; margin-top: 0; margin-bottom: 0; } .markdown-body ol ol, .markdown-body ul ol { list-style-type: lower-roman; } .markdown-body ul ul ol, .markdown-body ul ol ol, .markdown-body ol ul ol, .markdown-body ol ol ol { list-style-type: lower-alpha; } .markdown-body dd { margin-left: 0; } .markdown-body code { font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace; } .markdown-body pre { margin-top: 0; margin-bottom: 0; font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace; } .markdown-body kbd { background-color: #e7e7e7; background-image: -webkit-linear-gradient(#fefefe, #e7e7e7); background-image: linear-gradient(#fefefe, #e7e7e7); background-repeat: repeat-x; border-radius: 2px; border: 1px solid #cfcfcf; color: #000; padding: 3px 5px; line-height: 10px; font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace; display: inline-block; } .markdown-body>*:first-child { margin-top: 0 !important; } .markdown-body>*:last-child { margin-bottom: 0 !important; } .markdown-body .anchor { position: absolute; top: 0; bottom: 0; left: 0; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; } .markdown-body .anchor:focus { outline: none; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } .markdown-body h1 .octicon-link, .markdown-body h2 .octicon-link, .markdown-body h3 .octicon-link, .markdown-body h4 .octicon-link, .markdown-body h5 .octicon-link, .markdown-body h6 .octicon-link { display: none; color: #000; vertical-align: middle; } .markdown-body h1:hover .anchor, .markdown-body h2:hover .anchor, .markdown-body h3:hover .anchor, .markdown-body h4:hover .anchor, .markdown-body h5:hover .anchor, .markdown-body h6:hover .anchor { height: 1em; padding-left: 8px; margin-left: -30px; line-height: 1; text-decoration: none; } .markdown-body h1:hover .anchor .octicon-link, .markdown-body h2:hover .anchor .octicon-link, .markdown-body h3:hover .anchor .octicon-link, .markdown-body h4:hover .anchor .octicon-link, .markdown-body h5:hover .anchor .octicon-link, .markdown-body h6:hover .anchor .octicon-link { display: inline-block; } .markdown-body h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } .markdown-body h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } .markdown-body h3 { font-size: 1.5em; line-height: 1.43; } .markdown-body h4 { font-size: 1.25em; } .markdown-body h5 { font-size: 1em; } .markdown-body h6 { font-size: 1em; color: #777; } .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre { margin-top: 0; margin-bottom: 16px; } .markdown-body hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul { margin-top: 0; margin-bottom: 0; } .markdown-body li>p { margin-top: 16px; } .markdown-body dl { padding: 0; } .markdown-body dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } .markdown-body dl dd { padding: 0 16px; margin-bottom: 16px; } .markdown-body blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } .markdown-body blockquote>:first-child { margin-top: 0; } .markdown-body blockquote>:last-child { margin-bottom: 0; } .markdown-body table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } .markdown-body table th { font-weight: bold; } .markdown-body table th, .markdown-body table td { padding: 6px 13px; border: 1px solid #ddd; } .markdown-body table tr { background-color: #fff; border-top: 1px solid #ccc; } .markdown-body table tr:nth-child(2n) { background-color: #f8f8f8; } .markdown-body img { max-width: 100%; -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } .markdown-body code:before, .markdown-body code:after { letter-spacing: -0.2em; content: "\00a0"; } .markdown-body pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .markdown-body .highlight { margin-bottom: 16px; } .markdown-body .highlight pre, .markdown-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } .markdown-body .highlight pre { margin-bottom: 0; word-break: normal; } .markdown-body pre { word-wrap: normal; } .markdown-body pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .markdown-body pre code:before, .markdown-body pre code:after { content: normal; } .markdown-body .highlight { background: #fff; } .markdown-body .highlight .mf, .markdown-body .highlight .mh, .markdown-body .highlight .mi, .markdown-body .highlight .mo, .markdown-body .highlight .il, .markdown-body .highlight .m { color: #945277; } .markdown-body .highlight .s, .markdown-body .highlight .sb, .markdown-body .highlight .sc, .markdown-body .highlight .sd, .markdown-body .highlight .s2, .markdown-body .highlight .se, .markdown-body .highlight .sh, .markdown-body .highlight .si, .markdown-body .highlight .sx, .markdown-body .highlight .s1 { color: #df5000; } .markdown-body .highlight .kc, .markdown-body .highlight .kd, .markdown-body .highlight .kn, .markdown-body .highlight .kp, .markdown-body .highlight .kr, .markdown-body .highlight .kt, .markdown-body .highlight .k, .markdown-body .highlight .o { font-weight: bold; } .markdown-body .highlight .kt { color: #458; } .markdown-body .highlight .c, .markdown-body .highlight .cm, .markdown-body .highlight .c1 { color: #998; font-style: italic; } .markdown-body .highlight .cp, .markdown-body .highlight .cs { color: #999; font-weight: bold; } .markdown-body .highlight .cs { font-style: italic; } .markdown-body .highlight .n { color: #333; } .markdown-body .highlight .na, .markdown-body .highlight .nv, .markdown-body .highlight .vc, .markdown-body .highlight .vg, .markdown-body .highlight .vi { color: #008080; } .markdown-body .highlight .nb { color: #0086B3; } .markdown-body .highlight .nc { color: #458; font-weight: bold; } .markdown-body .highlight .no { color: #094e99; } .markdown-body .highlight .ni { color: #800080; } .markdown-body .highlight .ne { color: #990000; font-weight: bold; } .markdown-body .highlight .nf { color: #945277; font-weight: bold; } .markdown-body .highlight .nn { color: #555; } .markdown-body .highlight .nt { color: #000080; } .markdown-body .highlight .err { color: #a61717; background-color: #e3d2d2; } .markdown-body .highlight .gd { color: #000; background-color: #fdd; } .markdown-body .highlight .gd .x { color: #000; background-color: #faa; } .markdown-body .highlight .ge { font-style: italic; } .markdown-body .highlight .gr { color: #aa0000; } .markdown-body .highlight .gh { color: #999; } .markdown-body .highlight .gi { color: #000; background-color: #dfd; } .markdown-body .highlight .gi .x { color: #000; background-color: #afa; } .markdown-body .highlight .go { color: #888; } .markdown-body .highlight .gp { color: #555; } .markdown-body .highlight .gs { font-weight: bold; } .markdown-body .highlight .gu { color: #800080; font-weight: bold; } .markdown-body .highlight .gt { color: #aa0000; } .markdown-body .highlight .ow { font-weight: bold; } .markdown-body .highlight .w { color: #bbb; } .markdown-body .highlight .sr { color: #017936; } .markdown-body .highlight .ss { color: #8b467f; } .markdown-body .highlight .bp { color: #999; } .markdown-body .highlight .gc { color: #999; background-color: #EAF2F5; } .markdown-body .octicon { font: normal normal 16px octicons-anchor; line-height: 1; display: inline-block; text-decoration: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .markdown-body .octicon-link:before { content: '\f05c'; } .markdown-body .task-list-item { list-style-type: none; } .markdown-body .task-list-item+.task-list-item { margin-top: 3px; } .markdown-body .task-list-item input { float: left; margin: 0.3em 0 0.25em -1.6em; vertical-align: middle; } table td{ word-wrap: break-word !important; word-break: break-all !important; } /* github.com style (c) Vasily Polovnyov */ .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #333; background: #f8f8f8; -webkit-text-size-adjust: none; } .hljs-comment, .diff .hljs-header { color: #998; font-style: italic; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status { color: #333; font-weight: bold; } .hljs-number, .hljs-hexcolor, .ruby .hljs-constant { color: #008080; } .hljs-string, .hljs-tag .hljs-value, .hljs-doctag, .tex .hljs-formula { color: #d14; } .hljs-title, .hljs-id, .scss .hljs-preprocessor { color: #900; font-weight: bold; } .hljs-list .hljs-keyword, .hljs-subst { font-weight: normal; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command { color: #458; font-weight: bold; } .hljs-tag, .hljs-tag .hljs-title, .hljs-rule .hljs-property, .django .hljs-tag .hljs-keyword { color: #000080; font-weight: normal; } .hljs-attribute, .hljs-variable, .lisp .hljs-body, .hljs-name { color: #008080; } .hljs-regexp { color: #009926; } .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword, .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special, .hljs-prompt { color: #990073; } .hljs-built_in { color: #0086b3; } .hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang, .hljs-cdata { color: #999; font-weight: bold; } .hljs-deletion { background: #fdd; } .hljs-addition { background: #dfd; } .diff .hljs-change { background: #0086b3; } .hljs-chunk { color: #aaa; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2FMVC%20MVP.html</url>
    <content type="text"><![CDATA[videoref M : Model : 資料 V : View : 畫面 C : Controller P : Presenter MVC C僅負責接收V的要求 並安排後續處理流程 但M處理的結果不再經由C回給V V -&gt; C -&gt; M….-&gt; V MVP V與M互動完全需要透過P 與MVC的差別主要在M到V的部分是完全分離的 V P M MVP的架構會比較好 因為MVC中M回給V的資料畢竟最後透過V顯示 而M有必要替V預處理好便於顯示的資料嗎? 還是V自己再處理資料? 不管哪種好像都有些超出他們該負責的業務 MVVM 將P調換為VM Coding View與Model的部分建議用interface隔開實際類別 一來乾淨 二來不至於讓自己打亂架構 interface MainView&#123;&#125;class MyActivity extends Activity implements MainView&#123;&#125;class Presenter&#123; Presenter(MainView v)&#123; &#125;&#125; 盡量使用依賴注入 一來便於解偶 二來便於測試時抽換 class Presenter&#123; Presenter(MainView v, Model m)&#123; //&lt;---依賴的部分來自外部 &#125; Presenter(MainView v)&#123; m = new ModelDemo(); //&lt;--- 外部無法抽換Model &#125;&#125; 流程 先建interface / data class 建view 架構骨幹簡易畫面 稍加測試 實現interface 資料流情境data class Book&#123; author: String bigText: String&#125; class View&#123; h = Handler() //Android Handler (main thread execution queue) p = Presenter() onUserClick()&#123; //同步 p = p.cmd(arg); // set value / do things rv = p.get(arg); //異步 rv = p.getWithCallback(arg, this); rv = p.getWithCallback(arg, &#123; println("done") &#125;); &#125; onPresenterCallback()&#123; &#125; private changeViewComponent()&#123; //must run at main thread &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2F%E8%A8%AD%E8%A8%88-%E5%87%BD%E6%95%B8%E5%9B%9E%E5%82%B3.html</url>
    <content type="text"><![CDATA[函數的回傳設計 目的 取值 命令 取值式以取值為目的 立即取值 對於不佔用IO/CPU的動作可以即刻返回 func()&#123; return 1;&#125; 等待取值 透過func叫用 透過callback處理回傳 func(callback)&#123; //go async &#123; text = download(url) callback(text); &#125;&#125; 命令式以命令或要求為目的 命令與執行結果分離 一個命令的執行 影響層面不僅在caller上時 須以event的方式處理(通知任何需要得知事件的人) //定義與註冊事件處理函數onDataChange()&#123;&#125;reg(onDataChange);funcModifyData()&#123; //go async &#123; forEach(handler)&#123; notifyDataChange(...); //用async thread處理 //or sendMessage(...); //透過msg queue推送給特定thread處理 &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F%E6%BC%94%E7%AE%97%E6%B3%95%2FBinary%20Tree.html</url>
    <content type="text"><![CDATA[youtube Binary Tree P L RP : parentL : leftR : right搜尋: L &lt; P &amp; R &gt; P 遍歷前序 : PLR =&gt; 複製樹 運算(運算元+運算子) 中序 : LPR =&gt; 排序 搜尋 後序 : LRP =&gt; 查找找最小 找最大 找特定值 沒找到]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2Flangstar-%E8%B3%87%E6%96%99%E6%B5%81%E6%9E%B6%E6%A7%8B.html</url>
    <content type="text"><![CDATA[View DataService(ServiceCache) DataServer(DataAccess/DBCache/DBAccess) 主要分成DataService與DataServer兩大塊 DataService 提供資料服務 向View或任何需要資料者提供資料服務 貼近應用的資料結構 提供有邏輯功能性的操作 (例如新增使用者) ServiceCache 存放使用中的DataService 避免資料服務四散各處 透過ServiceCache存取已建立的資料服務 確保同一來源的資料僅有一個服務 便於資料同步 避免無限制的cache可用WeakRef(weak value)控制 但js只有WeakMap. 只能用 counter 或 時間+數量來workaround DataServer 處理資料讀寫 (僅是一個目錄) DataAccess 提供資料讀寫介面 處裡讀寫機制(本地/遠端) DBCache 本地資料快取 用於離線操作 DBAccess 遠端資料庫讀寫]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FDevOps%20CICD%2F%E6%8C%81%E7%BA%8C%E6%80%A7%E6%95%B4%E5%90%88%E8%88%87%E7%99%BC%E4%BD%88(CI%3ACD).html</url>
    <content type="text"><![CDATA[持續性整合與發佈 這部分屬於整個”開發到佈建”過程的自動化 包含版本控制/編譯/測試/發佈 等等 DevOps:泛指開發與營運的集合 這些工具通常都是以website的形式在雲端運作 也有能自行架設的 BitBucketGithub / Travis CIGitLabGiTeaJenkinscodeshipdronewercker//CDheroku 使用 Jenkins 持續集成與發佈 Android 應用程式]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fdocker%2Fdocker-readme.html</url>
    <content type="text"><![CDATA[一個”執行環境”的打包工具 做成image後可在任何裝有docker engine的os上執行該”執行環境” 跨平台 便於平台切換 抽換 複製 便於交付 Docker 介紹 Docker tutorial dockerfile : 一個特徵檔 用以描述如何建立image dockerhub : 一個官方與社群的image集散網站 類似github的運作方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2Fissus-langstar.html</url>
    <content type="text"><![CDATA[events.js:160 throw er; // Unhandled ‘error’ event執行ionic serve出現錯誤. 聽說跟瀏覽器更新有關, 但有一份較早建立的code執行時並不會有這種錯誤 npm install ws@3.3.2 –save-dev –save-exact admob沒反應 但乾淨的環境正常Show Banner Ads In Ionic With AdMob Free Plugin id: ca-pub-xxxxxxxxxxx 就能正常test 但依舊無法顯示廣告 安裝firebase-toolsnpm install -g firebase-toolsfirebase initfirebase deploy Javascript fetch執行fetch 3000次記憶體用量就破1G,還沒弄清問題在哪…. 找到問題了! 問題在於開啟了瀏覽器的inspection視窗 記錄了太多資訊 與fetch無關 url = "https://translate.googleapis.com/translate_a/single?client=gtx&amp;sl=en&amp;tl=en&amp;dt=t&amp;q=test"await fetch(url); Deeplink在aot時要用字串才行push(MyPage.name);//lazy load 跟 aot都不會有問題push("MyPage"); Hot Code Push//產生cordova-hcp.json (主要設定更新伺服器的檔案路徑)cordova-hcp init//手動添加config.xml, (若從code裡主導更新,這段似乎沒什麼用途) &lt;chcp&gt; &lt;config-file url="http://192.168.1.102:8100/chcp.json" /&gt; &lt;auto-download enabled="false" /&gt; &lt;auto-install enabled="false" /&gt; &lt;/chcp&gt;content_url : //欲release時產生files informationcordova-hcp buildchcp.json : 版本號 更新策略chcp.manifest : 檔案列表 path/hash//---以下為android apk測試編譯步驟//build in aot modenpm run build --prod//build android-debug.apk 在模擬器中執行cordova emulate android//每次重新build code最好透過模擬器把app移除,再進行下次的模擬,否則會有些混淆的現象出現 更新流程(開發端): compile產生www內容 cordova-hcp build,產生版本與file hash 上傳到file server (firebase deploy) 更新流程(用戶端): chcp.fetchUpdate(this.updateCallback, options); //帶入chcp.json路徑 更新後會重新啟動 service worker透過chrome/application的offline測試會造成firebase/auth出現network error,但若直接斷掉wifi則能正常運作. 測試開發期間最好關閉service worker,避免搞混執行的版本. weakMap做cache失敗做cache需要weakRef(weak value),但javascript的weakMap是weak key. 如此…要做程式內能自動釋放參考的ref就要靠自己join/leave了…使用上的繁雜度整個飆高. WeakMap屬於weak key. 其方法無法取得keys也沒辦法拜訪,只能當普通的Map用,但好處是物件放進WeakMap後不會使得該物件無法被回收. console.clear();class Cls&#123;&#125;let a = new Cls();const map = new WeakMap();map.set(a, "a")map.set(new Cls(), "b")console.log(map);setInterval(()=&gt;&#123; console.log("---"); console.log(map); //b會從map中消失&#125;, 1000); cache兩個目的 加速讀取 集結資料,使其參考或聽取同一對象,達到自動資料同步 await的危險瞬間class MyData&#123; uid; data; init(uid)&#123; this.uid = uid; data = await getUserData(this.uid); &#125; set(data)&#123; this.data = data; await setUserData(this.uid, this.data); &#125;&#125;//預設的順序是先init後再set//但其實無法預估getUserData進入異步後,會不會有set動作進入//最陽春的解法: () init(uid)&#123; data = await getUserData(uid); this.uid = uid; &#125;//或用一些變數鎖,但寫出來都不會好看.//或用UI鎖住畫面或按鈕等待動作結束//最好的方式是uid是一次性唯讀的.//但就變成不同uid不能共用於一個物件中,有時候希望一個reference從頭用到尾(重複利用),避免抽換reference時造成大範圍的連鎖反應.data$ = ReplaySubject&lt;T&gt;(1);function onSrcChange(src$)&#123; oldsrc$.unsubscribe(); src$.subscript(data =&gt; &#123; data$.next(data); &#125;);&#125;//以上這個方法也有困擾,因為&lt;T&gt;本身可能不單是data還有method,其中的data還需要再訂閱,要分散出去也很困擾. firebase權限與安全性在firebase限定權限意味著每筆私有資料不能參雜而外資料,例如某人的bookinfo中不能含有views的統計,因為views的統計是由讀者觸發寫入. 如此就需要制定更多的data table,在client做更多的join,寫入時也要同時顧慮到對其他連結table是否有影響需要一併處理 若不在firebase設定權限,就必須在client端做好安全控制,這部分是危險因子比較多的. Can’t resolve all parameters…Uncaught Error: Can't resolve all parameters for EditorPage: ([object Object], ?, [object Object], [object Object], [object Object]).readyGoHome() &#123; this.navTo(HomeSlidesPage); //&lt;--因為HomeSlidesPage引起,無論是否被執行&#125; 這似乎與webpack或即時編譯有關. Subject與ReplaySubject的些微差距const rp = new ReplaySubject&lt;number&gt;(1);const rp = new Subject&lt;number&gt;(); let c = 0;setInterval(async () =&gt; &#123; rp.next(++c); const c_ = c; const v = await rp.take(1).toPromise(); console.log("c:"+c_ + " v:"+v)&#125;, 1000);//ReplaySubjectc:1 v:1c:3 v:2//Subject =&gt; v1不見了c:1 v:2c:2 v:3 主要的問題是產生在toPromise,因為promise需要”下一個值才被驅動”,對一般的Subject是有順序關係的,toPromise是沒辦法取得前面next值,所以總是要等到下一輪的next. 而ReplaySubject只要曾經有值就立刻發送,沒有時序問題. 資料構思需求有時候很難說,隨著細節越來越多,才會發現設計的不足,如果能一次想遠一些,對設計的時程會有很大的助益. //需求:要能分辨Quiz的ans為yes或noQuiz:&#123; quiz, ans&#125;quizs = Quiz[];//進階需求:要知道多少個yes與nogetCount()&#123; //for loop...&#125;//進階需求:資料量大時for loop不流暢yes_cnt++;no_cnt--;//進階需求:要在yes group隨機取樣quiz_yes = Quiz[];quiz_no = Quiz[];//進階需求:ans的yes/no可能動態改變toggleYesNo(quiz) &#123; quiz_yes.push(quiz); quiz_no.remove(quiz);&#125;//進階需求:需要保留原quizs排序toggleYesNo(quiz) &#123; quiz_yes = quizs.filter(data=&gt;data!quiz); //ref被整個取代了&#125;another_ref = quiz_yes; //不知道原本的ref被取代//... offline cache cache放哪? 安全性? 被讀取被竄改? data version control version dirty ? for writable offline read policy by version : 比對版本後決定是否用遠端資料 remote first : 有遠端資料就使用( no version) remote only : 無論如何都用遠端資料(等同沒有cache) write policy 使用Data的考量 資料的取得 (初始化/變更) 資料的寫入 注意資料的污染 資料的用法 (顯示/運算) 減少return值得依賴 改採event //舊思維,偏向同步動作的思考class MyPage&#123; mydata:any; constructor()&#123; //mydata是否為clone data?寫入是否影響到來源資料 mydata = db.get(); db.onChange(data=&gt;&#123; mydata = data; &#125;); //以上兩個動作有些重複 &#125; set(value)&#123; //更動mydata最好不要牽動到來源資料(共用),所以最好為clone mydata.value = value; //set方式較佳,最終正確資料再從onChange返回 db.set(mydata); &#125;&#125;//新思維,observable,immuteable,讀寫異步class MyPage&#123; mydata:any; constructor()&#123; //一次處理資料的初始化與資料變動與設定後的套用結果 //可以使用observable的op操作資料事件 db.subscribe(data=&gt;&#123; mydata = clone(data);//如果需要變動mydata就clone一份 &#125;); &#125; set(value)&#123; //以功能性函數取代直接污染資料 db.changeValue(value) .catch(...); &#125; destory()&#123; db.unsubscribe(); &#125;&#125; 惱人的資料連動listA與listB都有itemC 當itemC改變或移除時如何通知A與B(完整機制的制定)? itemC與itemC’ 都是itemC在程式中是否要共用一個實體或各別實體? 共用實體 更新時使用方便 但要做維護單一實體的機制 各別實體 取用時方便 但維護資料同步時就很頭痛了 list與item list中的item是否要在data model裡就整合在一起? 或各自獨立 視各別應用 使用時再整合? 正規與反正規 正規 寫入方便 但讀取時要用uid連續查詢 反正規 寫入時要維護多組資料 讀取時方便 太過三心二意 做了本地快取原是為了離線瀏覽,但又想用來減少流量,所以又做版本控制,造成混淆,與難度大增. 本地快取:只在資料無法從遠端取得時使用. 不會複寫遠端.(但要想想如何從快取中恢復到遠端,遠端永遠是對的) 本地快取且可離線編輯:更新遠端時要注意資料是否已同步,煩雜很多. 減少流量:需要版本控制,進而需要穩定安全的資料寫入.(用firebase時版本號不能用datetime,因為時區校時等因素客戶端的時間永遠不在一條線上)(就算是同一個用戶只維護自己的資料,也不能用時間當版本號)(用transaction做累加是唯一的可能性) 偶爾想要這樣偶爾想要那樣,反而不能這樣也不能那樣…設計前還是要再多想想,可以少撞一些牆. 資料模組應用上會面臨的排列組合[(權限/資料安全)私有/公有/混合] [本地離線快取/遠端資料庫] [線上/離線] [離線資料回寫(安全性?)] [新增/刪除/讀取(JOIN)/更新(LINK)] [執行期間快取(weak map)] [(程式內資料映射)被動更新/事件更新] 複雜度 資料新增/修改 可離線? uid? 如何驅動回寫? 本地快取 –&gt; 網路來源 –&gt; 應用數據 –&gt; 複製擴散 –&gt; CRUD –&gt; 收斂返回 快取機制 僅讀 (online/offline) 若要寫 版本就很重要 可能需要merge機制 或更陽春 暫時可寫 但一連線仍用網路來源覆蓋 快取容量控制? 本地與遠端 資料同步的邏輯 以較新的為主(time version)(自有資料) 永遠以遠端為主 (共享資料) 除非是 資料建立者 如果保護一連串的網路存取都正常? 例如:po一篇文章,要同時將uid存到多個資料表 以往這樣的動作都在server端完成,可靠性高很多. 用firebase變成server跟client的code寫在一起. [雖然都在client執行但應該分成兩個獨立的個體寫會比較好,不幸我將他們寫在了一起,變得比較混亂也難以解偶] 很困難… 因為用戶隨時都會遇到1.網路不順 2.當機 等等…造成動作被中斷. 程式內存取真實資料 直接存取 : 方便 但欠缺規矩 難debug 難做異常處理 透過api : 較好管理 但api一多就相當困擾 immuteable.js : 永遠保留資料原始狀態 以這樣的概念設計 可以強迫資料維持正確性 架構上比較強壯 很難走捷徑 資料顯示/使用者輸入 不需轉換 : 通過轉換 : 資料更新 : 全部/部分 哪部分? 如果資料已被刪除呢?或起初就沒有同步呢? *** 本地要更新遠端時一定要確認資料同步(尤其是共享資料)！！！否則問題會層出不窮 一個完整的資料更新動作被拆成很多個部分的小更新,就要承擔動作被中斷的風險,因為有些資料應用上僅完成一半造成的後果就是跳exception!. 且 如果做一半的中途被 某人讀取?後果是??? 資料保護 版本不被舊資料覆蓋 &lt;—-自有資料 同一時間僅允許一人寫入(累加) &lt;—-共享資料 資料同步 本地端與遠端永遠都存在著不同步的疑慮,問題是寫入造成的影響 這筆資料只屬於A且是A決定寫入的 : 沒問題 這筆資料只屬於A但由系統寫入 : 系統必須聰明到能否寫入 這筆資料屬於大家,不管是誰寫 : 一定要transaction. 資料版本控制 以大小來區分新舊,必須確認這個值一定只會越來越大 以變化來區分新舊,例如本地端是fw084j2,但遠端是cwo392v,遠端有變動就是新的(本地端是唯獨) 以firebase來說,要做版本控制最好全程使用transaction,這是最安全的方式,但資料太大更新又太頻繁就很耗損流量,因為交換資料時還要確定自己的資料是最新的,就算資料僅供一個用戶寫入,但一個用戶操作多台機器的情況也是有的. 除非!!!資料的寫入是用戶”確認”後才寫入,就無所謂版本了. 離線操作 難度在offline恢復到online的機制,如何無縫接軌. 若是處在離線資料,編輯後要拿來更新遠端資料時,要如何處置. (難度很高最好禁止) 陽春的辦法:只要是離線資料一律不允許更新,直到user自己refresh取得遠端資料. 遠端資料 firebase一類的資料庫在共有資料的保護比較困擾,因為每個用戶的資料可能都在不同的狀態,每一個都是異步動作.(資料在遠端但保護要在本地端) 自有資料 : 可以假設同一時間僅有一個用戶使用 (或一人寫/多人讀) 共享資料 : 同一時間可能多方寫入 刪除 讀取 要注意本地與遠端的狀態 firebase要transaction的欄位要禁止null(共享資料要有初值),因為null同時也被用來判別object是null. 而且transaction不適合太大的物件,因為很常需要整個物件download下來. CORSen cn firebase只取某個欄位data = &#123; value:3;&#125;//ref("data/value")即可取到valuedata = &#123; uid1:&#123; email="A" value:3; &#125;, uid2:&#123; email="B" value:3; &#125;&#125;//ref("data/uid1/value")//如果透過query &#123;email="B"&#125;就沒辦法單獨取到value firebase goOfflinegoOffline後若對database操作會被block住!!直到goOnline繼續完成!網路斷線也是如上的情況! 也就是說動作一旦下達就無法取消 firebase時間排序通常會有這樣的需求where name=’jim’, sort by datetime ref.orderByChild("name").equalTo("jim")//排序欄位給name用後,沒辦法再用其他欄位排序了...//只能用預設的order,也就是object key//所以最初建立key時就要以時間建立key = timeStr+randomUID tab的slide indicator在link back後被歸零只有在{mode:’ios’}時,不設定就沒這問題可以看到換頁動畫的時候被推到0 IonicModule.forRoot(MyApp,&#123;mode:'ios'&#125;),只能改過場動畫了 IonicModule.forRoot(MyApp,&#123;mode:'ios',pageTransition:'md-transition'&#125;), ion-item中放入自己的元件會被移除掉必須在元件html上加以下屬性(directive) item-content, item-left or item-right Can’t bind to ‘ngClass’ since it isn’t a known property of …ngModule要import CommonModule function call 與 action command//message callfunction action(cmd:any) &#123;&#125;=&gt; 沒必要少用這樣的寫法,雖然cmd的彈性很大,但後續很難維護//function callfunction doSomething() &#123;&#125;=&gt; 用途清楚,參數的依賴明確,有lint方邊追蹤除錯 ion-slide當用ion-slide時,ion-content必須被包到ion-slide中,否則會影響髒檢查的效率. 文字垂直置中的技巧用padding取代height. 但多個block若有行數不同時就會偏移了. ionic url?var=123 參數部分會被自動去掉if(!value) 跟 if(value==null) !為強制轉型為boolean Boolean(0) : false &lt;== 注意這個Boolean(1) : trueBoolean('') : false &lt;== 注意這個Boolean(' ') : true//檢查'物件'是否被設定是可以的,但用在'數字'或'字串'要謹慎Boolean(null) : falseBoolean(undefined) : false ==null則為參考比對 //各種型別都適用的檢查方式(undefined)==null : true(undefined)===null : false &lt;== 注意這個 database與表單database雖然可以放boolean跟number,但database(web)回來’可能’會變string,且html from的處理也都以字串較多. 有時不小變成true跟”true”混用,會造成很多困擾,可能盡量用string會好點? forEach跟for的差別 forEach是以callback執行,呼叫CB時沒有前綴await,所以在CB中遇到await就會轉成異步,不會等待. 所以欲同步執行就不能用forEach!!!!! Firebase難處order跟where的語句只能對應一次. 一份資料很難有多種的query方式. 例如post info希望: 以author排序取回 限定type以views排序取回 就必須將post分別置於兩個資料表. Firebase怎麼規劃就我的需求: 能夠離線使用 盡量保持離線(因為免費project僅有100個連線) 減少流量(檢查遠端資料版本) 變更DB的可能性 可能的做法: 做正規劃 免去需更新多個資料表的問題. (但會增加query優化的難度,使得效能變差流量變大) 資料對應比較不複雜, 映射到內部暫存資料庫會比較容易些. =&gt;&gt;&gt;無法正規劃!!!:因為只存uid最後會面臨無法排序選取的問題 =&gt;&gt;&gt; 半正規劃:uid+order,可以,但可能不如直接用反正規劃,因為order欄位也需要更新的 Firebase卡死//data中有一個type欄位值是undefinedlet x = ref.set(data) .then(data =&gt; &#123; console.log("yes"); &#125;) .catch(err =&gt; &#123; console.error(err)&#125;)console.log("???")//沒有錯誤訊息,什麼都沒有//delete data.type; 或 data.type=0;就過去了 Firebase的updatedata:&#123; x:9, y:7, more:&#123; a:5, b:3, &#125;&#125;//錯誤用法 : data下的more會整個被&#123;a:0&#125;取代ref = "data"; update = &#123;more:&#123;a:0&#125;&#125;//正確用法 : data/more下的a被0取代ref = "data/more"; update = &#123;a:0&#125;//跟我預期的不一樣//如果要同時更新x跟a必須update兩次 或 整個data重新set一次//故若有多層的物件要更新就要多一道手續 Firebase的transactiontransaction的callback至少會被呼叫一次 新增資料ref.transaction( (currentData) =&gt; &#123; if (!currentData) &#123; //＊.遠端有無資料都會進入 (第一次都會丟null,目的應在先取得欲更新的資料,而非先從遠端下載資料) //1.遠端若無資料,此次return將新增到遠端 //2.遠端若有資料,又與此次return的資料不同時,下次就會丟回遠端資料 return newData; &#125; else &#123; //當前次return與遠端資料不相等時,此次會丟回確切的遠端資料,以供更新(或原物返回). return currentData; &#125; &#125;) 修改資料ref.transaction( (currentData) =&gt; &#123; if (!currentData) &#123; return currentData; &#125; else &#123; return currentData.count++; &#125; &#125;) angular偵測dirty失敗?value = 0;testFun()&#123; this.value = 99;&#125;//之後用以下三種方式改value的值,其中case1無法被angular偵測其值被修改//case1setTimeout(this.testFun, 0);//case2setTimeout(() =&gt; &#123; this.testFun();&#125;, 0);//case3setTimeout(() =&gt; &#123; this.test = 99;&#125;, 0); 答案 : testFun為一般function的宣告方式,其this為event caller. 完全是因為this指向了不預期的物件. setTimeout(this.testFun.bind(this), 0); firebase的orderByChild()無效?firebase伺服器端會依照order排序並取出結果(例如從10筆資料取出5筆最小的),但其取出的結果不會被排序,主因是firebase是key:value的db,儲存array會被轉成key:value物件,所以回傳也是key:value的物件,要排序只能自己轉array再sort. ionic一個ts裡放兩個component,分別有兩個templateURL會造成webpack掛掉可能立即掛掉 或 再次ionic serve時掛掉 ionic的lifecycle hook有點詭異?無法確認是我理解錯誤 還是 真的有錯 很多hook都不會被call]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2F%E8%A8%AD%E8%A8%88-%E8%B3%87%E6%96%99%E6%B5%81.html</url>
    <content type="text"><![CDATA[CRUD 新增 讀取 全部 / 部分 同步 排序 過濾 更新 全部 / 部分 連動 保護 (transaction) 刪除 架構 雲端 本地(離線用) 雲端+本地 DB SQL noSQL firebase 資料規劃與應用方式習習關關,一但規劃時沒考量到,後續也很難再加入.Order僅能一個欄位,Where也僅能一個欄位,沒有AND OR條件. 變更DB的可能性 資料規劃 正規化 : 以uid指向重複的資料,以join查詢. 反正規 : 為求快速查詢,允許資料重複. 但資料更新時相對麻煩. (要自己寫code處理) 一份資料四散各處?雲端資料庫/本地資料庫/讀取後建立的main data/再分配出去的sub data 雲端資料庫 : user手動重載 / 經提示重載 / 程式自動重載 資料要建立版本? 更改時如何同步其他部分? 更改時是全部或部分? 若只是部分要如何得知是哪部分?如何觸發? 從UI角度建立可能發生的事件 用戶登入後 user.id=… 連動取得news.message… UI在post上點選like user.like=true (部分更新) post.likecnt+=1 (被連動 &amp; 部分更新 &amp; 保護) 同步資料變更其他分裂出的資料 同步post.likecnt到其他user device 資料角色資料通常需要分類封裝,提供適當的介面服務 A提供資料給B做顯示 B依用戶輸入修改A A改變 C連帶改變 Observable適合用於提供異步資料,但對於反向要求變更資料就無法達成. 資料封裝需求(資料模組)繁雜的資料不可能都單獨的存在,必須依照屬性與其被應用方式歸類. 資料讀取 : 直接提供object或Observable / Promise 資料事件 : 提供subscribe/unsubscribe event callback 要求改變資料 : api 要求執行一連串動作 : api 連動其他資料 : api與event執行 異步連動 同步連動 : 一氣呵成 constructor的依賴 : 讓object能先被create,之後再依狀況注入依賴做init,對於有連動性的資料會比較好處理. class Data&#123; dataTree:(any|Observable); regEvent(callback); commitData(); doSomeWork();&#125; 結論資料依特性應用方式眾多,想整合一招打片天下確實很困難,但一定要模組化同時保持彈性.]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2Fjs-promise.html</url>
    <content type="text"><![CDATA[運作1 callbackvar promise = new Promise((resolve, reject) =&gt; &#123; if (ready) resolve('ok'); else reject('err');&#125;)promise.then(cbOk).catch(cbErr);function cbOk(data)&#123;&#125;function cbErr(err)&#123;&#125;//resolve -&gt; then's callback//reject -&gt; catch's callback//設計promise時最後一定要呼叫resolve或reject//無論resolve/reject被呼叫幾次,僅有第一次會產生callback 運作2 狀態var promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve(999); &#125;, 1000);&#125;) promise.then(data =&gt; &#123; console.log('a', data) //於1000ms後印出999&#125;) setTimeout(_ =&gt; &#123; promise.then(data =&gt; &#123; console.log('b', data) //於3000ms後印出999&#125;)&#125;, 3000)//1. promise在new後就已經開始異步執行 (這算是一個缺點)//2. then/catch僅是依其既有狀態呼叫callback//說明同一prmise的狀態是能夠"續用"的. 運作3 awaitasync function func()&#123; var value; setInterval(_ =&gt; &#123; console.log(value) &#125;, 1000) value = new Promise((resolve, reject) =&gt; &#123; // case A value = await new Promise((resolve, reject) =&gt; &#123; // case B setTimeout(function() &#123; resolve(999); &#125;, 3000); &#125;)&#125;//case A : 始終只會印出promise物件//case B : 會從undefined變到999,但code需寫到async中,也就是處於異步 運作4 thenableasync function func()&#123; var value = await new Promise((resolve, reject) =&gt; &#123; // case B setTimeout(function() &#123; resolve(999); &#125;, 3000); &#125;) .then(data=&gt;&#123;return data+1;&#125;) console.log(value); //1000&#125;//then's callback可以接續另一個promise或回傳值 執行多個關聯的異步操作將多個promise放置到一個async或promise異步執行,其中再用await連結成同步執行.也許中間也有一些能夠單獨操作的promise,但如果loading不重放一起也無仿,畢竟要做到極致的異步分工在開發時間的開銷也是很吃重的,況且也會增加程式碼的複雜度,造成後續修改的難度. async func()&#123; let a = await promise.... let b = await promise(a)... let c = await promise...&#125; 多個異步並發執行Promise.all 多個異步搶快執行Promise.race]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2FCORS%E8%B7%A8%E5%9F%9F%E8%B3%87%E6%BA%90%E5%88%86%E4%BA%AB.html</url>
    <content type="text"><![CDATA[參考 同源政策，Same-origin policy。 資源的權限加註在http傳輸的header中 (Access-Control-Allow-Origin:*) 當用戶跨域請求時,需要設定crossOrigin參數,讓browser知道 null : 不設定(預設) anonymous : credentials : browser則依據crossOrigin設定決定資源能否被使用 或僅能被怎樣使用 getBase64Image(url): Promise&lt;any&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; var img = new Image(); img.crossOrigin = "Anonymous"; img.onerror = reject; img.onload = () =&gt; &#123; console.log("img.complete:",img.complete) if (!img.complete) return; var canvas = document.createElement("canvas"); canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0); var dataURL = canvas.toDataURL("image/png"); resolve(dataURL); &#125;; img.src = url; &#125;);&#125; 上述程式碼有兩個地方與CORS有關 向伺服器請求圖檔 : anonymous與Access-Control-Allow-Origing的關聯. (jsbin的icon遇過資源沒設定ACAO時用anonymous反而會造成block) canvas的toDataURL : 對資源的再處理也受到限制. 一般認知為資源ACAO為*時,設定anonymous即可使用資源. 麻煩資源沒設ACAO,所以不能設anonymous,但沒設anonymous又不能用canvas的toDataURL. (Chrome)]]></content>
  </entry>
  <entry>
    <title><![CDATA[設計-同步異步]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2F%E8%A8%AD%E8%A8%88-%E5%90%8C%E6%AD%A5%E7%95%B0%E6%AD%A5.html</url>
    <content type="text"><![CDATA[如何同步 同步 : 等待式執行,依序完成. 處理相依性任務. 異步 : 跳躍式執行,各自完成. 效率好,但流程難掌握. 為何要同步基本上js是同步執行的,要進入異步執行通常是藉由event產生callback.但js有大多數的應用都被迫使用異步處理,一是因為大多數處理的時機都在eventcallback中,二是因為大多跟取得資料相關的api都是異步的.但有時異步動作是有先後或相依性時就必須要使其同步. 範例test裡兩個任務task1是同步的,但task2是異步的,回傳值是兩個task的合. async function test()&#123; var task1 = 1; console.log(task1); var task2 = await 2; //假設取得2的過程是異步的 console.log(task2); return task1+task2;&#125; await : 等待異步執行結果. async : 只有在宣告為async(異步)的函數中才能await. case1 : 不等待console.log("in");let ans = test()console.log("ans : "+ ans);ans.then(data=&gt;&#123; console.log("final : " + data) &#125;)console.log("out");// "in"// 1// "ans : [object Promise]"// "out"// 2// "final : 3" 在task1執行完就被迫回傳了(因為之後的await) 回傳的是一個Promise物件 task2排進了異步執行,所以不會立即被執行,而是等當下程序執行完回到js engine後才可能被執行. *雖然test被宣告為異步,但不是被呼叫就立刻排入異步執行,而是等到await的產生. 最終的結果要從回傳的Promise的callback取得,但那又是在另一個異步執行中了. case2 : 等待setTimeout(async _=&gt;&#123; console.log("in"); let ans = await test() console.log("ans : "+ ans); console.log("out");&#125;, 0)// "in"// 1// 2// "ans : 3"// "out" 要在async中才能await,所以用setTimeout做一個異步的event callback test等到最後的結果才回傳,而且不再回傳Promise. test雖然宣告是async,內部也做了await,但也只是確保test內是同步的,而caller要不要await又是另一回事. 異步執行 優點:效率好 缺點:流程較能掌控 在JS的世界裡,事件與外來資料通常都是異步的,資料取得的效率會很好,但是狀態會很亂. 例如當click事件發生時要取得某一資料或完整一些異步操作後才返回,就是一件’無法’達成的工作,因為click event呼叫callback時就沒預期到其中是有異步執行(取得資料)要等待的,所以當callback一進入異步的等待時,對caller來說就已經收到return了, async function clickCB()&#123; //clickCB進入異步等待await //但event caller沒有await,所以不會跟著等 //這時caller會收到一個promise物件的回傳(即async function) //當下無法目睹最後的value回傳值 var value = await new Promise((resolve, reject) =&gt; &#123; resolve(999); &#125;) return value;&#125; 舉例,當user按下按鈕會post一個留言(異步),而當留言尚未確認完成前不允許其他任何的操作. 以往c或java的經驗很直覺的會想鎖process等到thread執行完再return,但在異步環境中是完全無法實現的,或說這是不理想的設計模式. function clickCB(event)&#123; //block operations new Promise((resolve, reject) =&gt; &#123; resolve('data'); &#125;) .then(okCB) .catch(errCB); function okCB()&#123; //release operations &#125; function errCB()&#123; //release operations &#125;&#125;//block operations的方式很多種,例如event.target.disabled=true,或在畫面上疊一層block layer. 同步執行同步也僅能是在某個異步執行中的一部分,最終還是異步,只是多了等待的機制. async function func()&#123; var a = await new Promise().... var b = await new Promise(b)....&#125;//在func裡用await讓裡面的異步任務能夠同步依序執行//但對callar來說func仍然是異步的 異步到一個極致 就是累死自己多個異步任務若沒有相依性可以併發執行提高效率,不過雖然執行沒有相依性但最終執行的狀態可能有相依性,需要收集分析,若是將其以同步執行的開銷不大,仍以同步執行的設計方式實作會較佳,一來可讀性好,後續的維護或重構也容易些.]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2Fangularfire2.html</url>
    <content type="text"><![CDATA[Using AngularFire with Ionic 3 &#123; "client_info": &#123; "mobilesdk_app_id": "1:547724781060:android:e5981ae992ce8ee6", "android_client_info": &#123; "package_name": "tw.com.langstar.t1" &#125; &#125;, "oauth_client": [ &#123; //app用(cordova native) "client_id": "547724781060-adha3kg97gj8j9qkqeri19omc24d57sh.apps.googleusercontent.com", "client_type": 1, "android_info": &#123; "package_name": "tw.com.langstar.t1", "certificate_hash": "07703431b4269874caf58d1ebb009df30011a57e" &#125; &#125;, &#123; //web用,即webClientId "client_id": "547724781060-kr06v8821b2v84ln7808qpf662rbaf05.apps.googleusercontent.com", "client_type": 3 &#125; ], "api_key": [ &#123; "current_key": "AIzaSyDtJRlLi0N1wr85C-w5X-CgTCXoWVdAPQY" &#125; ], "services": &#123; "analytics_service": &#123; "status": 1 &#125;, "appinvite_service": &#123; "status": 2, "other_platform_oauth_client": [ &#123; "client_id": "547724781060-kr06v8821b2v84ln7808qpf662rbaf05.apps.googleusercontent.com", "client_type": 3 &#125; ] &#125;, "ads_service": &#123; "status": 2 &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2F%E5%8A%A0%E5%AF%86%E9%80%9A%E8%A8%8A.html</url>
    <content type="text"><![CDATA[加密方式 對稱式 : 加解密都用同一個key,速度快,適合大量資料加密,用於通訊時key本身需被暴露. (一般壓縮工具的加密) 非對稱 : 分public與private key,一組加密則需另一組解密,速度慢,但安全性高,較適合通訊. (最常見的演算法為RSA) CA (Certification Authority) (憑證中心)數位憑證 通常理解為可信賴的第三方的機構,替server製作憑證,即用CA的私鑰加密server的公鑰,若此憑證能被用戶以CA的公鑰解開,即表示該憑證確實為CA所發行,所取得的server公鑰是可以信賴的. 之所以要透過CA確認server的公鑰,是因為網路環境有機會讓惡意的第三方假冒該server,並用假冒(私做)的公鑰騙取用戶加密重要資訊給server,因為沒有可信賴的第三方用戶無從得知該公鑰是否確實來自該server. 這其中的安全性基於值得信賴的第三方,環環相扣,最後的環節依舊是人,並非機器或技術. Bitcoin的block chain是一個可能突破這方面的新技術,減少對第三方的依賴(每個領域很難說). Digital Signature 數位簽章計算要傳送內容的hash值,該hash值即為該內容的特徵碼(digest/MD5…).發信人再以私鑰加密該特徵碼,即成為數位簽章.收信人若能以發信人的公鑰解開數位簽章得到特徵碼A,並以同樣的hash function取得內容的特徵碼B,假若AB相等,即能確認該內容確實為該發信人所發出. 應用 - SSL (Secure Sockets Layer)其目的在於提供兩個應用程式間，透過網路的一個不安全通道，建立起安全的連線，來交換資料，防止資料受到竊聽及篡改。SSL/TLS ,圖解SSL/TLS協議 流程: 客戶端向服務器端索要並驗證公鑰。 雙方協商生成”對話密鑰”。 雙方採用”對話密鑰”進行加密通信。 注意: 生成對話密鑰一共需要三個隨機數。 握手之後的對話使用”對話密鑰”加密（對稱加密），服務器的公鑰和私鑰只用於加密和解密”對話密鑰”（非對稱加密），無其他作用。 服務器公鑰放在服務器的數位憑證之中。 身份驗證: 帳號密碼 RSA驗證. user將public key存於server server傳一字串請user加密並回傳 server驗證該回傳用哪位user的public key能解開 非對稱做: 身份驗證 保護另一個key(對稱式),應用上稱為session key,通訊安全無慮後,雙方即用加對稱的session key加解密. session key:於交握時雙方產的隨機數再衍生而出. 工具SSH / TLS實踐]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2Fionic-oauth.html</url>
    <content type="text"><![CDATA[從web登入彈出視窗方式申請clientID(即webClientId)通常只需要鎖網域 從app登入透過app內建的widget程式登入. (client端主要是驗證apk的signed資訊,似乎與程式碼無關.)申請登錄clientID需要: app id (widget id of config.xml) app SHA-1 登入時若沒有加webClientId只會回傳少數文字資料,所以透過app.登入若需要進一步操作用戶資料就同時也需要web client id. Android Studio預設的debug.keystore設定參考 android開發有一組預設的~/.android/debug.keystore,密碼為’android’(當初不知道有這樣的設定,一直嘗試一些無法關聯的調整,浪費了一兩天) Keystore name: &quot;debug.keystore&quot;Keystore password: &quot;android&quot;Key alias: &quot;androiddebugkey&quot;Key password: &quot;android&quot;CN: &quot;CN=Android Debug,O=Android,C=US&quot; 申請OAuth Client ID取得key的SHA1 //自建key (做成apk要publish才使用這種方式)keytool -genkey -v -keystore my-key.keystore -alias myalias -keyalg RSA -keysize 2048 -validity 10000keytool -exportcert -list -v -alias myalias -keystore my-key.keystore//使用預設~/.android/debug.keystore (開發階段使用)keytool -exportcert -list -v -alias androiddebugkey -keystore ~/.android/debug.keystore//申請OAuth Client ID&gt; Android, 貼上sha1,與config.xml的&apos;widget id&apos;//https://developers.google.com/mobile/add//https://console.developers.google.com 安裝package//據說REVERSED_CLIENT_ID是給iOS看的 (之前沒reverse也能正常)ionic cordova plugin add cordova-plugin-googleplus --variable REVERSED_CLIENT_ID=com.googleusercontent.apps.686840052494-pclnksh67f04srjmnta2tqa2m7mmroct//REVERSED_CLIENT_ID若用686...,用android測試時可以登入//若真reverse會???npm install --save @ionic-native/google-plus app informationdevice app的oauth很依賴app提供的資訊(widget id, SHA-1). app的資訊除了在config.xml能看到,還散佈在其他檔案,當需要修改app id或一些其他ID時要注意,最好project一開始就決定好,不然可能會被搞死. config.xmlplugins/android.jsonplugins/fetch.jsonplatforms/android/android.json app登入Google this.platform.ready().then((readySource) =&gt; &#123; //不加webClientId僅能取得部份文字資料,不包含idToken this.googlePlus.login(&#123; 'webClientId': '686840052494-pclnksh67f04srjmnta2tqa2m7mmroct.apps.googleusercontent.com', 'offline': true &#125;) .then(res =&gt; &#123; console.log(res) &#125;) .catch( err =&gt; &#123; console.error(err) &#125;);&#125;) npm package angular-social-auth (mobile base)]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2FAngular%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E6%8E%9B%E5%8B%BE%E5%87%BD%E6%95%B8.html</url>
    <content type="text"><![CDATA[import &#123; OnChanges,SimpleChanges, OnInit, DoCheck, AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, OnDestroy&#125; from '@angular/core'; Init/Destory的動作僅會執行一次,之後的髒檢查不會再被呼叫,屬於生命週期的部分.其他Check的部分會隨髒檢查循環執行,與’生命’無關. AfterViewInit : View已完成初次初始化,表示已能取得View上的元件參考,也可以再執行變更View相關的動作, AfterViewChecked : 表示已經做完View的髒檢查,若在此又執行變更View相關的動作,會造成顯示後立刻又進入DoCheck,變成無窮循環. 運用時機動態建立view時需善用onInit與afterViewInit. onInit時雖沒有任何view ref,但能初始化一些變數,改變view的結構(ngIf/ngFor…) afterViewInit是最後改變’第一畫面’的機會,該取得的view ref都該趁onInit時製造出來.]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular%E5%8B%95%E6%85%8B%E6%96%B0%E5%A2%9E%E5%85%83%E4%BB%B6.html</url>
    <content type="text"><![CDATA[參考 //tmeplate會變成HTML註解(comment)元素,元件會插入成為其next sibling(不是child)&lt;template #placehere&gt;&lt;/template&gt;@ViewChild('placehere',&#123;read:ViewContainerRef&#125;) tplvcf: ViewContainerRef;//用ComponentFactoryResolver建立factorylet factory = this.cfr.resolveComponentFactory(MyComponent);//建立元件並安插let compref = this.tplvcf.createComponent(factory, this.tplvcf.length, this.tplvcf.injector); ng元件的nativeElement的 Dom樹狀結構 與 ng元件的依賴結構 沒有一定的關聯,只是設計習慣上會使兩者結構相似,但實際上可以完全不相干,尤其是動態新增的元件. 也就是說建立元件時的依賴可以來自任何能取得的Injector,安插在任何能取得的ViewContainerRef. //分離 建立元件 與 安插//建立元件let compref = factory.create(this.tplvcf.injector);//安插this.tplvcf.insert(compref.hostView); 建立Provider被依賴的對象須建立一個provider物件才能傳遞給injector. 有四種類型 //useClass&#123; provide: ApiService, useClass: ApiService &#125;//或直接用 ApiService, ng也能識別//useValue&#123; provide: 'MyApiService', useValue: myService &#125;//useExisting&#123; provide: 'ApiServiceAlias', useExisting: ApiService &#125;//useFactoryexport function configFactory(config: AppConfig) &#123; return () =&gt; config.load();&#125;&#123; provide: APP_INITIALIZER, useFactory: configFactory, deps: [AppConfig], multi: true &#125; 假設要provide一個服務. provide就像是服務的名稱, useXXX則像是提供的實際內容物. 建立Injector (加入其他provider)let resolvedProvider = ReflectiveInjector.resolve([&#123; provide: 'myService', useValue: myService &#125;]); let injector = ReflectiveInjector.fromResolvedProviders(resolvedProvider, this.vcf.parentInjector);]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular%20-%20host.html</url>
    <content type="text"><![CDATA[ref host : directive都是依附在dom物件上運作, host則指其所依附的dom物件 //button-press.directive.tsimport &#123; Directive, HostBinding, HostListener &#125; from '@angular/core';@Directive(&#123; selector: '[exeButtonPress]'&#125;)export class ExeButtonPress &#123; @HostBinding('attr.role') role = 'button'; @HostBinding('class.pressed') isPressed: boolean; @HostListener('mousedown') hasPressed() &#123; this.isPressed = true; &#125; @HostListener('mouseup') hasReleased() &#123; this.isPressed = false; &#125; @HostListener('mouseup',['$event']) hasReleased2(event) &#123; this.isPressed = false; &#125;&#125;//button-press.directive.ts (another way)@Directive(&#123; selector: '[exeButtonPress]', host: &#123; 'role': 'button', '[class.pressed]': 'isPressed' &#125;&#125;)export class ExeButtonPress &#123; isPressed: boolean; // you have to declare here also ...&#125;//app.component.ts (how to use it)import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'exe-app', styles: [` button &#123; background: blue; color: white; border: 1px solid #eee; &#125; button.pressed &#123; background: red; &#125; `], template: ` &lt;button exeButtonPress&gt;按下按鈕&lt;/button&gt; `&#125;)export class AppComponent &#123; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular-keywords.html</url>
    <content type="text"><![CDATA[Events : publish跟subscribe間是同步執行 entryComponet : 正常route內沒有的component要加入這個meta中,通常是動態產生的或動態route]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular-code%20snippet.html</url>
    <content type="text"><![CDATA[template動態產生元件參考 import &#123; Component, ComponentFactoryResolver, ViewChild, ViewContainerRef &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;template #nametag let-y&gt; &lt;div&gt;Hello &#123;&#123; y.name &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;div [ngTemplateOutlet]="nametag" [ngOutletContext]="myContext"&gt;&lt;/div&gt; &lt;div [ngTemplateOutlet]="nametag" [ngOutletContext]="myContext2"&gt;&lt;/div&gt;`&#125;)export class AppComponent &#123; name = 'kevin'; myContext = &#123; '$implicit': &#123;name: 'kevin'&#125;&#125;; myContext2 = &#123; '$implicit': &#123;name: 'Jeff'&#125;&#125;;&#125; ngTemplateOutlet指向TemplateRef ngOutletContext指向dataContext $implicit隱含變數(以字串形式建立,ng會將其轉為別名) let-$implicit的別名 template動態產生元件動態建立元件 並加入template (類似ngFor/\ngIF) import &#123; Component, ComponentFactoryResolver, ViewChild, ViewContainerRef &#125; from '@angular/core';//MyDynamicComponent因為是動態產生的,必須加到ngModule meta的entryComponents@Component(&#123; selector: 'my-dynamic-component', template: `&lt;div&gt;Hello world&lt;/div&gt;`&#125;)export class MyDynamicComponent&#123; &#125;@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &lt;template #target&gt;&lt;/template&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;` &#125;)export class AppComponent &#123; @ViewChild('target', &#123;read: ViewContainerRef&#125;) target: ViewContainerRef; title = 'app works!'; constructor(private cfr: ComponentFactoryResolver)&#123; &#125; ngAfterViewInit()&#123; //MyDynamicComponent須加到module的entryComponents let myFactory = this.cfr.resolveComponentFactory(MyDynamicComponent); let compRef = this.target.createComponent(myFactory); &#125;&#125; 自訂Directiveimport &#123; Component, Directive, Input, TemplateRef, ViewContainerRef, EmbeddedViewRef, ChangeDetectorRef, ChangeDetectionStrategy&#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs/Rx';@Directive(&#123; selector: '[rxContext][rxContextOn]'&#125;)export class RxContext &#123; @Input() rxContextOn: Observable&lt;any&gt;; _viewRef: EmbeddedViewRef&lt;any&gt;; //TemplateRef:該directive所在的tag即為template (directive須加*才會inject) //ViewContainerRef:其directive的tag容器所處的位置 constructor(private templateRef: TemplateRef&lt;any&gt;, private vcr: ViewContainerRef) &#123; &#125; ngOnInit() &#123; // console.log(this.rxContextOn); this.rxContextOn.subscribe(state =&gt; &#123; if (!this._viewRef) &#123; //在容器上坎入新的view this._viewRef = this.vcr.createEmbeddedView(this.templateRef, &#123; '$implicit': state &#125;); &#125; this._viewRef.context.$implicit = state; &#125;); &#125;&#125;@Component(&#123; selector: 'app-root', template: ` &lt;div *rxContext="let user on userStream"&gt; &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt;`&#125;)export class AppComponent &#123; userStream = Observable.of(&#123; name: 'kevin', age: 35 &#125;).concat(Observable.timer(3000).mapTo(&#123; name: 'Jeff', age: 30 &#125;));&#125; template拆解 &lt;template rxContext let-user [rxContextOn]="userStream"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;template&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2Fionic-nav.html</url>
    <content type="text"><![CDATA[ionView DidLoad WillUnload Enter Will Did (become the active page) Leave Will Did (no longer the active page) CanEnter / CanLeave 類似於iOS的life cycle view轉換FIRST TIME VIEW INITIALIZATION View 1 – DidLoad View 1 – WillEnter View 1 – DidEnter TRANSITION FROM ONE VIEW TO ANOTHER View 2 – DidLoad View 2 – WillEnter View 1 – WillLeave View 2 – DidEnter View 1 – DidLeave 換頁NavController Tab //page1.html&lt;ion-item navPush="page2" [navParams]="toUser"&gt;//page1.tstoUser:any=&#123;toUserId:'somebody'&#125;;//page1.tsthis.nav.push(page2, toUser);//page2.tsconstructor(navParams: NavParams) &#123; this.toUserId = navParams.get('toUserId');&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular-template.html</url>
    <content type="text"><![CDATA[從template取得元件//.html&lt;ion-content #myid&gt;&lt;/ion-content&gt;&lt;div #mydiv&gt;&lt;/div&gt;//.ts@ViewChild('myid') mycom:Content@ViewChild(Content) mycom:Content //by component class name, and return first one of page@ViewChild(Content) set content(c:Content)&#123;...&#125; //check with setter@ViewChildren(Pane) panes: QueryList&lt;Pane&gt;;@ViewChild('mydiv') mydiv: ElementRef ;this.mycom.setElementStyle("border", '1px solid red');this.mydiv.nativeElement; @ViewChild可使ng動態改變reference(參考*ngIf,動態選到第一個) bind () 資料從dom(html)流向module(ts), 綁定’事件’發生的處理方式 [] 資料從module(ts)流向dom(html), 綁定’變數’改變直接導向dom元件 [(ngModel)] 僅有ngModel一類的directive能用(還沒看過別的) //.html&lt;input [(ngModel)]="myvar"&gt;&lt;input (ngModelChange)="myvar=$event" [ngModel]="myvar"&gt;&lt;input (input)="myvar=$event.target.value" [value]="myvar"&gt;//以上三種寫法都能達到同等功能&lt;input #inp (keyup)="myvar=inp.value"&gt;&lt;input (keyup.enter)="sendMsg()"&gt;//.tsmyvar:string; ngModel NgModel一種雙向綁定 但只限於表單控制項 (FormControl) NgModel 主要用來建立一個 表單控制項 (FormControl) 實體 (ngModel)是沒有意義的 &lt;input ngModel #mUsername="ngModel"&gt;&lt;input [ngModel]="username" #mUsername="ngModel"&gt;&lt;input [(ngModel)]="username" #mUsername="ngModel"&gt; form相關directive依階層排列如下 ngForm ngModelGroup ngModel : 通常html tag上要有name屬性,方便ts編寫時依name檢查 元件中加入ngModel功能ionic3-chat 綁定A時另一端(ngModel)會產生一個A’的變數,兩個變數靠ng居中做髒檢查才能提供這樣的功能. (用起來像是同一個變數,實際上是兩個,可以用getter/setter與debugger做時間差的驗證) export const EMOJI_PICKER_VALUE_ACCESSOR: any = &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; EmojiPickerComponent), multi: true&#125;;export class EmojiPickerComponent implements ControlValueAccessor&#123; //obj is the var you need to bind (from ngModel) writeValue(obj: any): void; //call this fn when data(obj) changed registerOnChange(fn: any): void; registerOnTouched(fn: any): void;&#125; 追蹤函數呼叫function funclog(target: any, key: string, descriptor:any) &#123; var orifunc = descriptor.value; var cnt = 0; descriptor.value = function (...args) &#123; console.log('&gt;&gt;&gt;'+key + " x " + (++cnt)) return orifunc.call(this,...args); &#125;&#125;@funclogafunc()&#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fhome%2F%2Fgit%2Fgit_.html</url>
    <content type="text"><![CDATA[***Git的好習慣 Git版本控制视频教程 SVN(subversion) 與 Gitcvs 集中式 svn 集中式: 所有版本都在svn server上,client端僅存有某一特定版本,所以版本切換時很慢 server一掛就全部死光. 紀錄diff patch,每個版本透過patch還原,所以換版本時也很慢. git 分散式 本地端含有所有版本,遠端僅進行與各個用戶端同步. 紀錄個別檔案 使用ssh連結遠端git//產生公私鑰ssh-keygen -t rsa -b 4096 -C jimliuxyz@gmail.com//將pub key貼到gitbut網站的setting&gt;SSH keys&gt;new key//針對目錄設定就不要加globalgit config --global user.name jimliuxyzgit config --global user.email jimliuxyz@gmail.comgit config --listgit remote add origin https://github.com/jimliuxyz/wovo.git ssh機制與私人repo較有關聯ssh config 常用指令常用指令 //取得remote repo變數設定git remote -v//取得所有branch與當下使用的branch (與本地追蹤狀況)git branch -a//取得遠端分支資訊git ls-remote//取得當下branch名稱與其版本狀態git status //測試git clone ... //會自建一個目錄touch file.txtecho 123 &gt;&gt; file.txtgit add file.txtgit commit -a -m comment...git push //建立project (wovo)git initgit add &lt;...&gt;git commit -m "first commit"//建立origin(remote repo var)並對應到remote url//origin是慣用預設對remote repo的命名git remote add origin https://github.com/jimliuxyz/wovo.git//將本地版本推送到 origin/master (remote repo/branch)//master是慣用預設對主要branch的命名//-u | --set-upstream設定master的remote repo是origingit push -u origin master //建立新分支newfeature,從master分出git branch newfeature master//切換分支git checkout newfeature//推送分支到remotegit push -u origin newfeature//之後的push動作git push origin//本地端分支:遠端分支git push -u origin master:master //更新local repo,但不合併git fetch//合併git merge origin/master// (fetch + merge)git pull 初建立rm -rf .gitgit init//重新commitgit commit -a -m "first commmit"//增加遠端origin路徑git remote add origin https://github.com/jimliuxyz/...//push到遠端origingit push -u origin master 參數-u設定本地端master追蹤遠端origin/master,設定一次後以後可以直接使用git push上傳 標籤感覺標籤像一個release的紀錄點,至少在github上確實會產生release的內容 git tag -a 1.0 -m &quot;first release&quot;git push origin 1.0]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fvscode%2Fvscode-extension.html</url>
    <content type="text"><![CDATA[create projectnpm install -g yo generator-codeyo code publish extensionnpm install -g vsce//申請VSTS(Visual Studio Team Services)帳號, then create tokenhttps://go.microsoft.com/fwlink/?LinkId=307137//create publisher by tokenvsce create-publisher jimliuxyzvsce login jimliuxyzvsce publish 1.0.0vsce publish majorvsce publish minorvsce publish patchvsce publish publish-extension Semantic Versioning devlopment直接點選側欄選單的debug, start debug package.json"icon": "assert/logo.png","activationEvents": [ "*"],"contributes": &#123; "configuration": &#123; "type": "object", "title": "Word Voice configuration", "properties": &#123; "wovo.voice_filename": &#123; "type": "boolean", "default": true, "description": "voice filename when changing editor." &#125;, "wovo.voice_editing": &#123; "type": "boolean", "default": true, "description": "voice word when editing." &#125;, "wovo.voice_cursor": &#123; "type": "boolean", "default": true, "description": "voice filename when moving cursor." &#125; &#125; &#125;&#125;, import &#123;window, commands, Disposable, ExtensionContext, StatusBarAlignment, StatusBarItem, TextDocument&#125; from 'vscode';import * as vscode from 'vscode';import * as say from 'say';const cfgVoFilename = (): boolean =&gt;vscode.workspace.getConfiguration('wovo').get&lt;boolean&gt;('voice_filename');const cfgVoEditing = (): boolean =&gt;vscode.workspace.getConfiguration('wovo').get&lt;boolean&gt;('voice_editing');const cfgVoCursor = (): boolean =&gt;vscode.workspace.getConfiguration('wovo').get&lt;boolean&gt;('voice_cursor');export function activate(context: ExtensionContext) &#123; console.log('"WoVo" is now active!'); // create a new word voice let wordVoice = new WordVoice(); let controller = new WordVoiceController(wordVoice); // Add to a list of disposables which are disposed when this extension is deactivated. context.subscriptions.push(controller); context.subscriptions.push(wordVoice); console.log(cfgVoFilename())&#125;class WordVoice &#123; private WORDRE = /[A-Za-z0-9_]+/; private _statusBarItem: StatusBarItem; private _prevFilename: string; private _prevVersion: number; private _delaycall:NodeJS.Timer; public onDidChnage() &#123; // Create as needed if (!this._statusBarItem) &#123; this._statusBarItem = window.createStatusBarItem(StatusBarAlignment.Left); &#125; // Get the current text editor let editor = window.activeTextEditor; if (!editor) &#123; this._statusBarItem.hide(); return; &#125; let doc = editor.document; // this._statusBarItem.text = doc.fileName+" : "+doc.version; // this._statusBarItem.show(); // this._statusBarItem.hide(); //changing active editor if (doc.fileName !== this._prevFilename) &#123; var fname = doc.fileName.replace(/^.*[\\\/]/, "").replace(/[^A-Za-z0-9]/g,". ")/*.replace(/[.].*$/,"")*/; //to avoid stopped by cursor voice, so it should voice later setTimeout(() =&gt; &#123; say.stop() //stop cursor voice if (cfgVoFilename()) say.speak(fname) &#125;,1) this._prevFilename = doc.fileName; this._prevVersion = doc.version; return; &#125; var editing = this._prevVersion !== doc.version; this._prevVersion = doc.version; var stext:string; if (editor.selection.isEmpty) &#123; var pos = editor.selection.active; if (pos.line == 0 &amp;&amp; pos.character == 0) return; var char = '\n'; if (pos.character &gt; 0) &#123; char = (doc.lineAt(pos.line).text)[pos.character - 1] &#125; //on editing if (editing) &#123; if (!cfgVoEditing()) return; //move back one character if cursor not in a word if (!this.WORDRE.test(char)) &#123; pos = new vscode.Position(pos.line + (pos.character == 0 ? -1 : 0), pos.character &gt; 0 ? (pos.character - 1) : (doc.lineAt(pos.line - 1).text.length)) &#125; //delay if editing a word else &#123; clearTimeout(this._delaycall); this._delaycall = setTimeout(() =&gt; this.onDidChnage(), 500); return; &#125; &#125; else if (!cfgVoCursor()) return; var range = doc.getWordRangeAtPosition(pos,this.WORDRE); if (range) &#123; stext = doc.getText(range); // vscode.window.showInformationMessage(stext) &#125; &#125; //split text if has both lower and upper case if (stext &amp;&amp; (stext !== stext.toLowerCase() &amp;&amp; stext !== stext.toUpperCase())) &#123; var arr: string[]=[]; var word = ""; for (var s of &lt;any&gt;stext) &#123; if (s === s.toUpperCase()) &#123; arr.push(word); word = ""; &#125; word += s; &#125; arr.push(word); stext = arr.join(" "); &#125; if (stext) &#123; say.stop() say.speak(stext) &#125; &#125; dispose() &#123; this._statusBarItem.dispose(); &#125;&#125;class WordVoiceController &#123; private _wordVoice: WordVoice; private _disposable: Disposable; constructor(wordVoice: WordVoice) &#123; this._wordVoice = wordVoice; // subscribe to selection change and editor activation events let subscriptions: Disposable[] = []; window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions); window.onDidChangeTextEditorSelection(this._onEvent, this, subscriptions); // create a combined disposable from both event subscriptions this._disposable = Disposable.from(...subscriptions); &#125; dispose() &#123; this._disposable.dispose(); &#125; private _onEvent() &#123; this._wordVoice.onDidChnage(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Freact%2Fredux.html</url>
    <content type="text"><![CDATA[概念redux基本上是針對狀態讀寫(不是針對變數)的一種設計思想,把散落的狀態讀寫集中到一個稱為’store‘的模組上. 制定狀態結構interface SpeedState &#123; speed: number;&#125;INI_STATE: SpeedState = &#123; speed: 0&#125;; 怎麼寫入狀態？狀態的寫入需要透過發送’action’,其實就是一個{type,payload}的物件,做為一個命令傳送給store. store.dispath(&#123; type:SET_SPEED, payload:&#123; speed:1 &#125;&#125;); 誰處理action處理的函數稱做reducer,這個名稱來自於Array的reduce函數,也提供類似的行為new=f(old,act) reducer須符合pure function的設計,意即同樣輸入必須得到同樣輸出,這是設計理念,涉及狀態回朔的可能性,與何者該被定義為’狀態’有關. function speedReducer(state: SpeedState=INI_STATE, action: Action): SpeedState &#123; const &#123;type, payload&#125; = action; switch (type) &#123; case SET_SPEED: //依照action.type產生新的狀態(以不修改原state的方式使其舊state能保留) return &#123;...state, speed: payload.speed&#125;; default: return state; &#125; 建立storeimport &#123;StoreModule&#125; from '@ngrx/store';...@NgModule(&#123; imports: [ StoreModule.provideStore(speedReducer), ]... 怎麼讀？mynum: Observable&lt;number&gt;mynum = store.select('num'); //回傳observable &lt;p&gt;num: &#123;&#123; mynum | async &#125;&#125;&lt;/p&gt;//或直接subscribe observable(mynum)進行更多處理 結論redux架構的使用很容易導致over design,用ng service + RxJs會比較精簡些 http://oomusou.io/angular/angular-ngrx/ https://www.youtube.com/watch?v=hJtUdXqPLDc]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fnpm%2F%E7%89%88%E6%9C%AC%E8%A6%8F%E7%AF%84semver.html</url>
    <content type="text"><![CDATA[版本規範semver3.4.1MAJOR.MINOR.PATCH主版號.次版號.修訂號MAJOR : 用於造成'相容性變動'時MINOR : 用於仍維持相容性的'功能新增'PATCH : 用於仍維持相容性的'功能修正' package.json 版本* : 任意版本^ : MAJOR不能變 (允許新增功能與修正)~ : MAJOR與MINOR不能變 (僅允許新增修正:更嚴格)~1.2.3 表示 &gt;=1.2.3 and &lt; 1.3.0^1.2.3 表示 &gt;=1.2.3 and &lt; 2.0.0^0.1.2 表示 &gt;=0.1.2 and &lt; 0.2.0]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fangular%E6%B7%B1%E5%85%A5.html</url>
    <content type="text"><![CDATA[髒檢測觸發Angular 2 Change Detection-1 Events：click, mouseover, keyup … Timers：setInterval、setTimeout XHRs：Ajax(GET、POST …) zone.js : 它是用於攔截和跟蹤異步工作 Monkey-patched : 覆寫預設method Change Detection提高效率Angular 2 Change Detection-2 Change Detection markForCheck input需要改變時採immuteable策略,用Object.assign({}, person, {name: ‘new name’});複製物件再整個assign到input,避免ng做深層的髒檢測 改為手動策略changeDetection: ChangeDetectionStrategy.OnPush,改用ChangeDetectorRef.markForCheck()的方式推動髒檢測 ngZone]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2FIonic%2FIonic.html</url>
    <content type="text"><![CDATA[release APK參考 // 產生private key (alias_name可自訂)keytool -genkey -v -keystore mykey.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000// 檢視private keykeytool -list -v -keystore mykey.keystore cd ~/.android///for langstar / pw:9xxxxxkeytool -genkey -v -keystore langstar.keystore -alias langstar -keyalg RSA -keysize 2048 -validity 10000keytool -exportcert -list -v -keystore langstar.keystore -alias langstar //自建build.json&#123; "android": &#123; "release": &#123; "keystore": "android.keystore", "storePassword": "storepassword", "alias": "mykey", "password" : "password", "keystoreType": "" &#125; &#125;&#125; IonicPage的問題//讓url能正常運作的兩種方式nav.push('pagename');&lt;ion-item navPush="pagename"&gt;link&lt;/ion-item&gt; page的載入由ionic背景執行,在其載入之前只有透過ionViewCanEnter回傳promise阻止,用以檢查異步的custom init ready狀態. 編譯環境//.bash_profile//jdk must &lt;= 1.8export JAVA_HOME=`/usr/libexec/java_home -v 1.8`export SDK_HOME=/Users/jimliu/Library/Android/sdkexport ANDROID_HOME=/Users/jimliu/Library/Android/sdkexport PATH=$JAVA_HOME/bin:$&#123;SDK_HOME&#125;/tools/bin:$&#123;SDK_HOME&#125;/platform-tools:$PATH source .bash_profile//install sdk dependencesdkmanager &quot;system-images;android-25;google_apis;x86&quot;//create virtual deviceavdmanager create avd -n mydevice -k &quot;system-images;android-25;google_apis;x86&quot;cordova platform add androidcordova platform add android@6.2.3 --save//run on local browserionic serve//run on avdionic cordova run android --livereload//build .apkionic cordova build --release androidcordova emulate android cordova run android失敗可以嘗試移除./platforms/android/.gradle目錄 real device : The connection to the server was unsuccessful. (http://140.254.160.122:8100) ionic cordova run android –prod –livereload 似乎與Splashscreen有關 //config.xml &lt;platform name=&quot;android&quot;&gt; &lt;preference name=&quot;loadUrlTimeoutValue&quot; value=&quot;700000&quot; /&gt; &lt;/platform&gt; real device : PLUGIN_NOT_INSTALLEDimport &#123; Platform &#125; from 'ionic-angular';import &#123; AndroidPermissions &#125; from '@ionic-native/android-permissions';import &#123; SpeechRecognition &#125; from '@ionic-native/speech-recognition';this.platform.ready().then((readySource) =&gt; &#123; alert('Platform ready from'+readySource); // Platform now ready, execute any required native code this.androidPermissions.checkPermission(this.androidPermissions.PERMISSION.RECORD_AUDIO).then( success =&gt; alert('Permission granted'), err =&gt; alert('Permission not granted') ); this.speechRecognition.isRecognitionAvailable() .then((available: boolean) =&gt; alert('1?'+available)) this.speechRecognition.startListening(&#123;&#125;) .subscribe( (matches: Array&lt;string&gt;) =&gt; alert('2?'+matches), (onerror) =&gt; alert('error:'+ onerror) ) &#125;); 實測裝置 device要開啟開發人員模式 與 usb debug 與 wifi(與server同網域) app nav tab viewapp 本身有一預設的navtab也算一個nav (但tabs不是) ion-tab本身算一個可nav元件,url名稱為tag上的tab-Title,不設定會變tab-0 IonicPage@IonicPage(&#123; name: 'my-page', //ion-nav [root]=...對應的字串 (預設為元件名稱) segment: 'some-path' //僅url顯示 與程式碼沒有連結 (預設為檔名) defaultHistory: ['my-page']&#125;)//linkpage.module.ts 與 linkpage.ts 檔名需一致,其檔名為預設的segment字串 routeIonicPage與Componet類似,大概差在deeplink,但好像有bug IonicPage可用其component name的字串做nav (name:? segment:?) tab url路徑的目錄名稱是來自”tabComponentFilename/ion-tab的tabTitle/ComponentFilename” IonicPage url路徑名稱覆寫 url還是會穿插一些內部的nav路徑 像是nav/n4/tabs/t0 更新到3.6可以解決 //ionic-app-scriptscd node_modules/@ionic/app-scripts/distproviders: [ &#123;provide: APP_BASE_HREF, useValue: "/"&#125;,...locationStrategy: 'path'//url上不使用#,但server要配合導向index.html//page stack會保留,back不會reload,但url不會跳到pageurlnav.push('...')//每次back都會reload,但url會跳到pageurlnav.setRoot('...'); 調整slide.scroll-content&#123; overflow-y: hidden;&#125;.slide-zoom&#123; height:100%; overflow-y: auto;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fnpm%2Ftoollist.html</url>
    <content type="text"><![CDATA[nodejs 一個讓本地端能夠執行javascript的環境,搭配express(外部的library)能實現http server. 同時也被開發成了一個模組管理的平台(npm) nodemon 能讓透過偵測檔案更新自動重啟node server –inspect參數能將node對應到chrome做debug browserSync 偵測檔案更新能讓browser自動重新整理 原理browser -&gt; proxy(browserSync) -&gt; server,透過proxy代轉並插入程式碼.]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2FAngular(ts)%2002.html</url>
    <content type="text"><![CDATA[pluginautoimport .ts區分script與module與轉譯編譯有關 script : 變數宣告會直接到global(window)下,或說不是被import而執行的 angulre.cli.json的scripts會以script執行 module : 有用到export的script就會變成一個module,變數宣告會在某個namespace下 此時定義window下的global變數要用declare global 簡單說module是存在於global(window)內的另一個scope vscode在type的hint方面整合很不錯,幾乎可以預先分析所有的狀況 import若import的不是ts則沒有types可以參考除錯. // your.tsimport * as objectHash from 'object-hash';console.log(objectHash.MD5('str')) 同一個module多次import也只會被執行一次(export出來的物件是共享的) 什麼適合放到angular.cli.json的scripts當js/ts被放到angulare.cli.json的scripts下其實就已經相當於html的&lt; script src=…&gt;的global執行情境(相對於import module),已經放在scripts中的就不需要再被import了,若再import會變成在另一個namespace再建立一次. 與module無關的,自己可以運作的,例如bootstrap.js 有@types像JQuery,放進去後就不用再import了 沒有@types,直接把type定義成any (像是object-hash) //angular.cli.jsonscripts : "...object-hash.js"// yourmodule.ts, no need to import * from 'object-hash'// but you got to know the global name of it, is 'objectHash'// you can also check it by console.dir(window)// decleare沒有執行順序(僅供編譯器與lint識別)declare global&#123; //在module裡定義script(global)的變數 let objectHash: any;&#125;console.log(objectHash('str')) //或將定義寫到d.ts//typings.d.tsdeclare let objectHash: any; //不加global,因為是script執行不是module 3rd party extension (透過import方式則無法在前期執行完畢) //angular.cli.jsonscripts : "... extension.ts"//extension.tsinterface JQuery &#123; removeClassRegex(regex: RegExp): JQuery;&#125;$.fn.removeClassRegex = function(regex) &#123; return $(this).removeClass(function(index, classes) &#123; return classes.split(/\s+/).filter(function (c) &#123; console.log(c + " ? " + regex.test(c)) return regex.test(c); &#125;).join(' '); &#125;);&#125;; extend 3rd party function//entry.ts (import any object of extends.ts to make compiler link it)import &#123; Empty &#125; from './mods/pure/global'//extends.ts (module)declare global &#123; interface JQuery &#123; removeClassRegex(regex: RegExp): JQuery; &#125;&#125;$.fn.removeClassRegex = function(regex) &#123; return $(this).removeClass(function(index, classes) &#123; return classes.split(/\s+/).filter(function (c) &#123; console.log(c + " ? " + regex.test(c)) return regex.test(c); &#125;).join(' '); &#125;);&#125;;export class Empty&#123;&#125; 取得html元件template:`&lt;div #mychild&gt;&lt;/div&gt;`;import &#123; ViewChild &#125; from '@angular/core';@ViewChild('mychild') elem; this.elem.nativeElement;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fcss%2Fscss.html</url>
    <content type="text"><![CDATA[參考 SCSS to CSS online 內建函數 //變數宣告$tag:body;$resizer-size:15px;$list: (orange, purple, teal);$font-style:( family: sans-serif, size: 15px);//載入外部scss@import "../node_modules/bootstrap-4.0.0-beta/scss/bootstrap";//在selector使用變數 #&#123;...&#125;#&#123;$tag&#125; &#123;&#125;//maps變數讀取map-get($font-style, size); //函數@function func($var) &#123; @return 10;&#125; //混入 用法類似函數 沒有回傳值 而是混入css@mixin mixfont($family, $size:10px) &#123;&#125;body &#123; @include mixfont(sans-serif, 10px); @include mixfont($font-style...);&#125; //運算元 + - * /@each $item in $list &#123;...&#125;@for $i from 1 through $total &#123;...&#125; //巢狀.parent &#123; .child &#123; // .parent .child&#123;&#125; &#125;&#125;.parent &#123; font : &#123; family: sans-serif; &#125;&#125;.parent &#123; &amp;:hover &#123; &#125; &amp;:dialog &#123; // .parent.dialog&#123;&#125; &#125;&#125; //繼承.A&#123;&#125;.A1&#123; @extend .A;&#125;//placeholderdiv%B &#123;&#125;.test &#123; @extend %B; //產生div.test&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fcss%2F04-Selector.html</url>
    <content type="text"><![CDATA[基礎// OR |img, a =&gt; &lt;img&gt; &lt;a&gt;// AND &amp;div.cls =&gt; &lt;div class='cls'&gt;.cls1.cls2 =&gt; &lt;div class='cls1 cls2'&gt; Attribute Selector = 完全匹配 ^= 字串開頭匹配 |= 類似^但更精準,例如btn只能匹配’btn’與’btn-‘,如果是’btn1’就不行 ~= 字串以空白切割後完全匹配 *= 有出現即可匹配 $= 字串結尾匹配 //匹配div中有status-開頭的classdiv[class^="status-"], div[class*=" status-"] 測試頁 ## Combinator .cls + * : 選到cls的nextSibling (僅next一次) .cls ~ * : 選到cls的all nextSibling (next全部) .cls * : 選到cls的所有後代 (遞迴多層) .cls &gt; * : 選到cls的子層 (僅一層) Form Selectors偽元素選擇器一個依附在某元素的假元素 偽類選擇器一個依屬性產生的css class]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fcss%2F02-Basic.html</url>
    <content type="text"><![CDATA[div.test div{ margin:8px; padding:5px; border:.5px solid red; } 前提知識單位元件寬高 px cm % 容器空間的百分比 vh/vw/vmin/vmax : 可視空間的百分比。與%不同在於能撐開空白元件，類似px的行為。 em : 上層元件字體的倍數 rem : html元件字體的倍數 其他 fr : fraction.用於grid-template 控制內容物排版 align-items：center (垂直置中) justify-content : center(水平置中) text-align:justify 使全形半形混用的文章頭尾對齊(左右平衡) 文字斷行word-wrap跟word-break似乎有些重疊… word-wrap 單詞內斷行 (同overflow-wrap) normal aaaaaaaaa 123456789 中中中中中 break-word 確保一定斷行,盡量保持行的開頭為單詞的開頭 aaaaaaaaa 123456789 中中中中中 word-break 單詞內斷行策略 keep-all 不確保一定斷行,盡量保持行的開頭為單詞的開頭 (斷在符號) aaaaaaaaa 123456789 中中中中中 break-all 確保一定斷行,在任意字元都可以斷 aaaaaaaaa 123456789 中中中中中 MacDown無法順利顯示確實的效果 文字column排版column pistion static : 預設值，位置照版面推移 fixed : 相對於瀏覽器視窗位置，不佔版面 relative : 相對於當下位置，仍佔原版面空間 absolute : 相對於relative parent(往上搜尋)，不佔版面 定位都用(top/bottom)與（left/right)，其值為與其相對物件的距離 overflow當容器有指定寬度時,就表示容器不會隨內容物縮放空間,就可能造成內容物溢出,overflow則是其對策eion.com.tw hidden / visible / scroll @media query//括弧中條件成立才apply 即width不超過640@media screen and (max-width:640px) &#123; nav li &#123; display: none; &#125;&#125;//這種方式載入的css會與link載入的css會有時間差,畫面可能會閃爍@import "style.css" screen and ...; &lt;link rel="stylesheet" type="text/css" href="default.css" /&gt;//screen handheld all ...&lt;link rel="stylesheet" type="text/css" href="print.css" media="print"/&gt;&lt;link rel="stylesheet" media="screen and (min-width: 400px) and (max-width: 700px)" href="example.css" /&gt; ref @viewport 手持裝置瀏覽器有些不同於桌上型的特性,通常是盡力將整個網頁呈現 內部有一個虛擬的viewport width(不是手機解析度)與scale值做自動調整 viewport width指的是可視寬度,即螢幕寬度對應的部分,scroll出去的不算 initial-scale的優先權比設定viewport width大(實驗:設了scale,width就沒作用了) initial-scale=0.5其實是把viewport width*2. 不設initial-scale再將body.width:100%取出document.body.offsetWidth即為viewport width 因為這樣的特性使得畫面被縮小,不容易瀏覽與點擊操作,故做響應式設計(RWD)時會將scale設為1,讓layout能透過css的media query做調整,而不是直接被scale @viewport &#123; width: device-width; /*width: 1024;*/ initial-scale: 1;&#125; &lt;meta name="viewport" content="width=device-width"&gt;//關閉畫面縮放&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=no"&gt;css file:@viewport&#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJavaScript%20DOM%20Crash%20Course.html</url>
    <content type="text"><![CDATA[JavaScript DOM Crash Course 選取元件document.querySelector("input[type='submit']")document.querySelectorAll(".myclass") innerText與textContent的差別innerText能反應內元素display:none的變化,textContent僅是列出text node. Node/Element/HTMLElement之間是繼承關係 Node 在分類中包含TextNode Element 可以看作tag HTMLElement 即Element再包裹一層HTML特性,相對表示也有XMLElement JSel=document.createElement('div');el=document.createTextNode('some text');el.className = 'myclass';el.style.border = "1px solid red";el.setAttribute('type', 'none');el.addElementListener('click', eventhandle); event typeclick dblclickmouse~ down up enter leave over out movekey~ down up pressfoucs blurcut pasteinput change submit eventfunction eventhandle(e)&#123; e.target e.preventDefault() //停止預設事件對應 e.clientX //滑鼠位置 相對於瀏覽器視窗 e.offsetX //滑鼠位置 相對於e.target e.altKey e.ctrlKey e.shiftKey&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fcss%2F03-Layout.html</url>
    <content type="text"><![CDATA[前提知識Element (Box)一個元件的完整空間由margin border padding content組成 content 內容物 border 邊線 padding content與border的間距 margin 元件間的間距 兩元件取margin大者做為間距 常做為元件垂直置中的手段 margin可以只撐開外容器 padding可以撐開自身(進而影響外容器) 但在inline元素中兩者的margin-top/margin-bottom都強制為零(除非是inline-block) 補充 block元件間的margin是border to border,但inline元件是content to content(不是很重要) 參數順序：上下 左右 box-sizing決定width/height的組成成員。以border決定空間的border-box顯得更直覺。 content-box 預設值 border-box (border+padding+content) inline / block inline 行內元素 block 換行(列)元素,預設有左右撐開佔滿的特性(就算沒有內容) inline-block 對外是inline,但對內是block(可以被撐開,外容器空間會改變) none 不顯示且不佔版面(visiability:hidden會佔版面) div.test div{ margin:8px; padding:5px; border:.5px solid red; } inline block 容器概念 容器 wrapper / container 內容物 item 元件的排列從視覺上像是挖空往內塞,但實際上是一層一層‘往上’推疊. (所以處理不當時內容物才會暴露到容器外) 設計容器有兩種角度(以高度舉例) 容器有確切的高度或比例 由外層向內層定義 內容物有確切高度 由內層向外層定義 容器最後的大小是從內向外撐開的 容器一但指定了height(px或%或其他),就不會被內容物撐開容器若沒有指定height,內容物用%時就會參考到更上層有指定height的容器作分子 沒有指定height的情況通常是希望瀏覽器內部能自動排版位置與空間,像是用了display:flex,但層層的容器中終究會遇到要指定寬高的內容物,通常會想設定容器的n%,但卻發現容器被撐破了. 以下是一個使wrapper撐破與修復的範例. 修復的方式是在要設定寬高的層中加入absolute,並在外容器加上relative對應,這算是relative另一個很大的用處. &lt;div class='wrapper'&gt; &lt;div class="flowbox"&gt; &lt;div class="box1"&gt;1&lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="fullbox"&gt;fullbox&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; * &#123; box-sizing:border-box;&#125;.wrapper&#123; width:100px; height:100px; background-color: gray;&#125;.flowbox&#123; height:100%; width:100%; display:flex; flex-flow:column; border:2px solid blue; .box1&#123; margin:5px; border:2px solid green; &#125; .box2&#123; //沒有指定height margin:5px; border:2px solid green; flex:1; /* position:relative; //fix */ &#125;&#125;.fullbox&#123; width:100%; height:100%; //要參考box2的height background-color: pink; /* position:absolute; //fix */&#125; float:left/rightfloat的概念是將元件A抽離原本的位置,讓給下一個元件B,而自身則轉移到另一個xy相近但z軸更高的容器上,造成AB外框重疊,但content不重疊的特性,也就是B元件的內容會避開A元件,常見的應用就是文(B)繞圖(A)。另一種應用就是拿來做選單,只想取其使元件水平排列的特性,但不想造成B被A覆蓋的情形,就會在B做clear的動作,使B整個移動出float容器的遮擋。這應該算過渡時期的用法，CSS3後多用flex做選單。 透過float可將block元件的流動調整為水平的 float可以自動換行 自適應式Layout (RWD)display:flexflex (wrapper) flex-flow : 流動方向(main-axis) row(水平流) colume flex-wrap : 換行 nowrap wrap justify-content : 配位(main-axis) flex-start flex-end center space-between space-around align-content : 配位(cross-axis) flex-start flex-end center space-between space-around stretch align-items: 對齊(cross-axis) flex-start flex-end center baseline stretch flex (item) flex-grow : 空間權重(有設定時容器才會撐開,一律只能左右撐開) flex-shrink : 空間權重(當wrapper被縮的比固定px還小時) flex-basis : 最小空間(px，通常設auto，設0會變成能放不能縮) flex : 結合上述三者一起設定 align-self : 脫離wrapper自己對齊 order : 調整順序 數字越小越前 display:gridgrid (wrapper) grid-template-columns(水平流) grid-template-rows分別指定一個CxR的grid line規範,line可以命名,單位 px fr % atuo,函數repeat grid-template-areas定義區塊area name grid-gap : 間隔 justify-content align-content justify-items .grid-wrapper &#123; display: grid; grid-template-columns: [gc1] 100px [gc2] 1fr [gc3] 2fr [gc-end]; grid-template-rows: [gr1] 100px [gr2] auto [gr-end]; grid-template-areas: "r1c1 r1c2" "r2c1 r2c2" "footer footer";&#125; flex裡的item空間使用％時會對應到body甚至完全無法對應 必須在item裡做position:absolute,外容器做position:relative 讓item重新定位到reference parent grid (item) grid-column : 以數字或名稱指定column的start/end grid-row : 以數字或名稱指定row的start/end grid-area : 以area name指定區塊 justify-self align-self .grid-item&#123; grid-column: gc2 / gc-end; grid-row: gr2 / gr-end; grid-area: footer;&#125; var x=document.getElementById('xxx'); x.innerText='哈哈';]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Fdiary.html</url>
    <content type="text"><![CDATA[Resizer一個看似單純的東西竟然寫了整整兩天,四個版本 原本用每次move的delta推動,但體驗上會出現cursor與resizer產生距離,必須用drag start event與move event的差,而非每次move event之間的差 多級運作時沒辦法推動下一級,與推動後要定位 原本用px運作,忘了resize擴大時會無法填滿 載入CSS時機以angular只有單一html入口的情況,如果在A/B兩網址(非SPA)用上不同的‘body bgcolor? 非原生存在於.html的style的插入或變更都可能使畫面抖動 最後只能從server端吐出對應好的css style 可以嘗試用binding，讓server吐不同的href &lt;link id=&quot;theme&quot; rel=&apos;stylesheet&apos; href=&apos;assets/demo.css&apos;&gt;//--- $(&apos;body&apos;).addClass(&apos;fullbody&apos;)//-- var style = document.createElement(&apos;link&apos;); style.setAttribute(&apos;rel&apos;, &apos;stylesheet&apos;); style.setAttribute(&apos;href&apos;, &apos;assets/demo.css&apos;); document.querySelector(&apos;head&apos;).appendChild(style); 實現方式太多驚覺常常進入放空狀態，不知從哪下手比較正規 bootstrapnpm install bootstrap@3 --save或npm install bootstrap-sass@3 --save &quot;../node_modules/bootstrap-sass/assets/stylesheets/_bootstrap.scss&quot; &quot;../node_modules/bootstrap-sass/assets/javascripts/bootstrap.js&quot; $icon-font-path: &apos;../node_modules/bootstrap-sass/assets/fonts/bootstrap/&apos;; //fix path error@import &quot;assets/variables&quot;; //a copy to override bootstrap variables@import &quot;../node_modules/bootstrap-sass/assets/stylesheets/_bootstrap&quot;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[layout css]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Flayout-css.html</url>
    <content type="text"><![CDATA[佔滿整頁的設計 body height:100% body padding-bottom:?? (非百分比的高度和,手動計算)]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Fstarbook.html</url>
    <content type="text"><![CDATA[1+2=3 \1+3=4 ?以下何者大於10? 敘述1 敘述2 =14 1 -3 解題 //https://translate.google.com.tw/translate_a/single?client=t&amp;sl=en&amp;tl=zh-TW&amp;dt=t&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=who%20are%20you//https://ctrlq.org/code/19899-google-translate-languages#languages//https://translate.google.com/translate_tts?ie=UTF-8&amp;client=tw-ob&amp;tl=zh-TW&amp;q=測試 console.clear(); var sourceLang=”zh-TW”var targetLang=”en”var sourceText=”我愛妳” var url = “https://translate.googleapis.com/translate_a/single?client=gtx&amp;sl=&quot; + sourceLang + &quot;&amp;tl=&quot; + targetLang + &quot;&amp;dt=t&amp;q=&quot; + encodeURI(sourceText); // var result = JSON.parse(fetch(url).getContentText()); //console.log(result); fetch(url).then(res=&gt;{// console.log(res.json()) res.json().then(function(data) { console.log(data); });})]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Fnodejs.html</url>
    <content type="text"><![CDATA[npm init//create package.json npm install g live-server npm install//install dependences Live-server npm startnpm app//app.js editor : install ESLint debug Node.js V8 –inspector Manager (NiM)https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj/related?hl=en-US chrome://inspect/#devices node -inspect server.jsnode -inspect=9229 –debug-brk server.jsts-node …. node –inspect ./node_modules/.bin/gulp test Unable to open devtools socket: address already in uselsof -i tcp:9229kill -9 [PID]]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Fvscode.html</url>
    <content type="text"><![CDATA[workbench.action.togglePanel“cmd+j”換cmd enter cursorWordEndRightopt 右換:cmd L cursorWordEndRightSelectopt sft 右換:cmd sft L 上下左右cmd opt 上下左右換:cmd opt IKJL commentcmd / toggle terminal windowcmd J new terminalctrl ` show termainlctrl ` sft beautifysft opt F 1.檔案需要固定route,加到.angular-cli.json let mydiv=document.getElementById(“mydiv”) el=mydiv;i=0; while (el) { console.log(i + ‘. ‘ + el.nodeName); if (el.nodeName==”SCRIPT”) break; //if(el.nodeType==3) // console.log(el.childNodes) el.childNodes.forEach((v,i)=&gt;{ //console.dir(v) v.style=”border:1px solid red” console.log(“ “+v.nodeName + “ “ + v.textContent) }) el = el.nextSibling; i++;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FWorkingNotes%2Fangular.html</url>
    <content type="text"><![CDATA[angular會自動剔除不需要被編譯的ts檔案angular universal做server render會在server也跑一次client的js code,要用isPlatformServer做路徑分離 npm install -g @angular/cli npm install bootstrap -save angular-cli.json : app.styles “./../node_modules/bootstrap/dist/css/bootstrap.min.css” ng new myAppng new My_New_Project –style=scss tsconfig.json : “allowJs”: true ng g c ‘mods/mod-nodereader’ –module app.module –skip-import gulp serverng build -w npm install bootstrapnpm install jquery add path to angular.cli.json “style/script” “../node_modules/bootstrap/dist/css/bootstrap.min.css” “../node_modules/jquery/dist/jquery.min.js” npm install @types/jquery add ‘jquery’ to tsconfig.js “types”=&gt; not really needed, depending on versions of Typescript import * as $ from ‘jquery’;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FRxJS%2F02.Scheduler.html</url>
    <content type="text"><![CDATA[Scheduler主要用來控制Obs的發送機制,基本上有… queue : 多用於never complete的op (repeat) asap : 異步, =&gt; setTimeout(0) async : 異步, =&gt; setInterval 多用於timer相關的op animationFrame : scheduler的設定可以接在creation operators的最後一個參數或是用obs的方法observeOn() obs.observeOn(Rx.Scheduler.async)//讓obs的next()變成非同步執行//內部的動作比較像是buffer住資料,再用setTimeout做next()]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FRxJS%2F01.Subject.html</url>
    <content type="text"><![CDATA[Subject是一個將Obs包裹起來供多個Observer共用一個Obs的shell(等同於Obs)除了Obs的角色同時擔任Observer的角色，所以可以出現在subscribe的左邊(當Obs)或右邊(當Observer) var subject = new Rx.Subject()subject.subscribe(observerA); // subject先把A加入source.subscribe(subject); // source再加subject,以確保中間資料會到A //之後B再加入時,可以與A共用同一個source實體setTimeout(() =&gt; {subject.subscribe(observerB);}, 1000); Subject的實作其實就像是Observable pattern(Event emit/listen) BehaviorSubject一個可以設定起始(startsWith)值給每個observer的subject,起始值===最新值 new Rx.BehaviorSubject(0); ReplaySubjectstartsWith最新的n個值 new Rx.ReplaySubject(2); // 重複發送最後 2 個元素 AsyncSubject只在complete送出最後一個值 new Rx.AsyncSubject(); multicast (op)Obs透過multicast與subject產生連結,也可達到Obs共用 var source = Rx.Observable.from([1, 2, 3]);var subject = new Rx.Subject();var multicasted = source.multicast(subject); var subscriptionA = multicasted.subscribe(observerA);var subscriptionB = multicasted.subscribe(observerB);//subscriptionA.unsubscribe(); var mainSubscription = multicasted.connect(); //source會multicast到subject//mainSubscription.unsubscribe() refCount (op)簡化multicast使其不須connect()只要有observer訂閱就開始，並在所有observer取消訂閱時結束 var multicasted = source.multicast(subject).refCount(); publish簡化multicast(new Rx.Subject()) Rx.Observable.interval(1000) .publish() .refCount(); Rx.Observable.interval(1000) .publishReplay(1) .refCount(); Rx.Observable.interval(1000) .publishBehavior(0) .refCount(); Rx.Observable.interval(1000) .publishLast() .refCount(); share簡化publish + refCount Rx.Observable.interval(1000) .share();]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2FRxJS%2F00.readme.html</url>
    <content type="text"><![CDATA[http://ithelp.ithome.com.tw/articles/10188554http://reactivex.io/rxjs/manual/overview.htmlhttp://reactivex.io/rxjs/class/es6/Observable.js~Observable.htmlhttp://reactivex.io/rxjs/manual/overview.html#categories-of-operators 一個Reactive Programming概念的library 大多的使用情境都與”事件(互動)處理流程”相關 多能用於同步與非同步的事件互動 很像是single thread的多工機制 同樣也為Functional Programming 使用的技巧跟Array的map/filter/reduce相似 map:產出同樣數量但不同資料內容的陣列filter:產出不同數量但相同資料內容的陣列reduce:化整為一concatAll:將第二維轉到第一維(第一維消失)(將數量與內容轉到二維決定) Functional Programming的串接連環call 同步的連環call大概不會有什麼疑慮,但進入異步就變得很混亂了 首先還是照串接呼叫一次，不過僅是設定callback，直到呼叫subscribe才啟動整個機制 執行時就是一層一層的異步或同步的callback呼叫 不要搞混串接函數的return跟callback的return callback的return通常是當下一級函數的參數 下列都可以印出5 click .map(e=&gt;5) //map回傳一個Obs,T為5 .subscribe(console.log); click .map(e=&gt;Rx.Observable.of(5)) //map回傳一個Obs,T又是另一個Obs,即map回傳Obs&lt;Obs&gt; .subscribe(obs=&gt;{obs.subscribe(console.log)}); click .map(e=&gt;Rx.Observable.of(5)) //map回傳一個Obs,T又是另一個Obs,即map回傳Obs&lt;Obs&gt; .concatAll() .subscribe(console.log); click .mapTo(5) //mapTo回傳一個Obs .groupBy(_=&gt;0) //groupBy回傳Obs,T又是另一個Obs,即groupBy回傳Obs&lt;Obs&gt; .concatAll() .subscribe(console.log); 有些op被next立即就會return Obs,像是map,filter; 但有些則必須等complete才會return Obs讓下一級處理,像是reduce,cound。所以必須注意各別Obs的數據串列特性 click.count().subscribe(console.log) // click不complete就永遠不會log Observable很多情境都是用於處理異步事件很多發展都是基於single thread的執行技巧上一個很主要觀念就是”切割分時執行”,更有效率的使用single thread像是generator/iterater的延遲運算特性都同樣與這個議題相關 而應用的情境上則多與使用者(event)互動相關從任務執行的驅動角度來觀察iterator是主動透過next()來執行任務 (poll)obserable是經由event來驅動callback執行 (push) 靠事件驅動就是observable的重點(類似於setListener的模式(Observer Pattern))但observable不僅能靠事件驅動,還能自己”產生”事件驅動所以observable整合了產生事件與處理事件兩個部分 iterator的next()用來拉取(poll)事件observable的next()用來推送(push)事件 程式碼上的名詞 基本建立方式Rx.Observable.create(onSubscription: function(observer: Observer) example = Rx.Observable.creator(observer =&gt; { const source = getSomeEventSource(); // 某個事件源 例如input source.addListener(‘some’, (some) =&gt; { observer.next(some) })}); observable:主要物件 observable.subscribe(handleNext,handleErr,handleComplete):執行observable與建立觀察者函數 handleNext,handleErr,handleComplete:這一系列函數將與observable掛勾,某種程度上 observer:觀察者.集合上述handle的物件 subscription:observable的執行函數 OperatorRxJS透過各式的function做功能的簡化或延伸把這樣的function稱做Operator Cold and Hot Observable cold:指固定的數據流,無論何時訂閱都得到相同的數據,僅是訂閱點不同 hot:通常即時數據屬於這一類,例如滑鼠點擊,數據隨時都反應最新的狀態 Creation Operator //從’值’Rx.Observable.of(‘Jerry’, ‘Anna’); //從’enumerable’ (any enumerable, ex: Set, WeakSet, Iterator, String, Promise)Rx.Observable.from([‘Jerry’, ‘Anna’]); //從事件Rx.Observable.fromEvent(document.body, ‘click’); //從既有或自訂的EventPattern (配合take下達complete)Rx.Observable.fromEventPattern( (handler) =&gt; someobj.addListener(handler), (handler) =&gt; someobj.removeListener(handler) ).take(1); //建立空白Obs (可以complete)Rx.Observable.empty(); //建立空白Obs (無法complete)Rx.Observable.never(); //拋出errorRx.Observable.throw(‘Oop!’); //間格1000ms送一壘加數字 (從0開始)Rx.Observable.interval(1000); //1000ms後送0並結束Rx.Observable.timer(1000); //1000ms後送0之後5000ms送一壘加數字Rx.Observable.timer(1000,5000); //重複 Rx.Observable.of(‘Jerry’, ‘Anna’).repeat(1)Transformation Operators //同JS的陣列source.map(x =&gt; x + 2); //map成固定值source.mapTo(2); //同JS的陣列source.filter(x =&gt; x % 2 === 0); //同JS的陣列mouseDown.map(event =&gt; mouseMove.takeUntil(mouseUp)) .concatAll() .subscribe(value =&gt; { console.log(value); }) //同JS陣列的reduceRx.Observable.of(5,3).scan((origin, next) =&gt; origin + next, 0);// 8 Transformation Operators 2//buffer資料 (累積的資料以陣列傳出)var source = Rx.Observable.interval(300);var source2 = Rx.Observable.interval(1000).mapTo(’emit’);var example = source.buffer(source2);//[0,1,2] [3,4,5]//source2只當作buffer的emit信號，值是什麼無所謂 //固定時間emitsource.bufferTime(1000); //固定資料次數emitsource.bufferCount(3); //固定事件emitclick.bufferWhen(() =&gt; click.delay(500)) Transformation Operators 3 (產生higher order Obs)window同buffer,但buffer是包裝成Obs&lt;Array&gt;,window是包裝成新的Obs&lt;Obs&gt;,要兩次subscribe才能解到T,所以window後面要接higher-oder convert，像是switch windowToggle類window,但trigger的概念改成starter跟stopervar example = Rx.Observable.interval(1000) .windowToggle(mouseDown, () =&gt; mouseUp) .switch(); groupByRx.Observable.interval(300).take(5) .groupBy(x =&gt; x % 2);//將x以(x%2)為key做分類產生Obs Filtering Operators //只取3個後completeRx.Observable.interval(1000).take(3); //同take(1)Rx.Observable.interval(1000).first(); //只取complete前的最後2個Rx.Observable.interval(1000).takeLast(2); //同takeLast(1)Rx.Observable.interval(1000).last(); //直到另一個Observable發出next()才結束mouseDown.map(event =&gt; mouseMove.takeUntil(mouseUp)).concatAll()//mouseDown後捕捉mouseMove直到mouseUp結束 //略過前3個Rx.Observable.interval(1000).skip(3); //去抖動 當source達1000ms沒有在變動時才emit//在資料’穩定時取樣‘避免無謂的執行 降低觸發頻率source.debounceTime(1000); //與debounce相同是為了降低觸發頻率//但採用的策略是’定時取樣’,像處理mouseMove事件就適合用source.throttleTime(1000); //distinct : 只emit沒有出現過的 （過濾掉相同的）Rx.Observable.from([‘a’, ‘a’, ‘b’, ‘c’, ‘b’]).distinct() // a b cdistinct((obj) =&gt; {return obj.value}); //指定檢查的元素 //distinct內部有一個set在記錄歷史數據，可以定期flushevar flushes = Rx.Observable.interval(1300);var example = source.distinct(null, flushes); //distinctUntilChanged : 只emit與前一個不同的 （過濾掉與前一個相同的）Rx.Observable.from([‘a’, ‘a’, ‘b’, ‘c’, ‘b’]).distinctUntilChanged() // a b c b Combination Operators //先送某特定值Rx.Observable.timer(5000,1000).startWith(0); //concat : 串接多個Observablesource.concat( Rx.Observable.of(4,5,6), Rx.Observable.of(7,8,9));// (456789)//***concat的Observable必須等到前一個complete才輪到下一個 //merge : 併發多個Observablevar source = Rx.Observable.interval(500).mapTo(1);var source2 = Rx.Observable.interval(501).mapTo(2);var example = source.merge(source2);// 12–12–12–12….//當一個工作可能被多種事件觸發時 //combineLatest : 兩observable最後一值合併（source newest都會觸發）var source = Rx.Observable.interval(500).take(4).map(v=&gt;’abcd’[v]);var newest = Rx.Observable.interval(300).take(6);var example = source.combineLatest(newest, (x, y) =&gt; x + y);//a0 a1 b2 b3 c3 c4 d4 //zip : 兩observablea同一位置的值合併var source = Rx.Observable.from(‘abcd’);var newest = Rx.Observable.interval(300).take(6);var example = source.combineLatest(newest, (x, y) =&gt; x + y);//a0 b1 c2 d3 //withLatestFrom : 兩observable最後一值合併（只有source會觸發）(觸發時若newest尚未有值就會被跳過。這與同步異步的運作有關，同步OBS：會直接跳到最後一個，異步：要等待啟動前的值都會被拋掉)var source = Rx.Observable.interval(500).take(4).map(v=&gt;’abcd’[v]);var newest = Rx.Observable.interval(300).take(6);var example = source.withLatestFrom(newest, (x, y) =&gt; x + y);//a0 b2 c4 d4 *** 在Observable中是有自己的狀態的，可以得知最後emit的變數與是否complete.除非是一個新的subscribe才會產生新的狀態，如果沒有subscribe只是放到operator中使用 combineLatest/withLatestFrom/zip:這類的operator可想像成函數內部有一個專門管理subscribe每一個Observable的機制，記住每個的狀態， 事件型OBS：同樣的事件多個subscriber,事件發生的當下都可以取得事件。例如mouseDown發生時再subscribe同樣的事件，立即就可以得到事件發生的callback Combination Operators (higher-order convert) Converts a higher-order Observable into a first-order Observable將更高一階的Obs轉換到第一階常有需求將一Obs轉換map成另一個更多解的Obs例如:將一個click產生3個值，所以map到新的Obs上var obs = click.map(e=&gt;Rx.Observable.interval(1000).take(3))但回傳的Obs並非”解”，故需再subscribe新的Obs，變成有兩層的Obsobs.subscribe(obs=&gt;{obs.subscribe(console.log)});此時就需要concatAll/switch/mergeAll簡化這樣的動作 concatAll:連接的Obs必須等待前一個complete才執行下一個，所以不會complete的不適合用concatAll連接，像是groupBy產生的Obs switch: mergeAll: //concatAll : 第二層Observable合併 (去除第一層Observable,相當於換一個Observable)source = Rx.Observable.of(10,20,30) .map(function(item){ return Rx.Observable.of(‘a’); });source.subscribe(console.log); //三個Rx.Observable.of(‘a’)物件source.concatAll().subscribe(console.log); //a a a //var click = Rx.Observable.fromEvent(document.body, ‘click’);var source = click.map(e =&gt; Rx.Observable.interval(1000));var example = source.concatAll();// c 0 1 2 3 4 …. (click要等source complete才能動作) //switch :var click = Rx.Observable.fromEvent(document.body, ‘click’);var source = click.map(e =&gt; Rx.Observable.interval(1000));var example = source.switch();// c 0 1 2 c 0 1 …. (click有動作時source會先被unsubscribe) //mergeAllvar click = Rx.Observable.fromEvent(document.body, ‘click’);var source = click.map(e =&gt; Rx.Observable.interval(1000).take(3));var example = source.mergeAll(2);//click跟map回傳Obs會並行執行，click動作越多產生越多Obs，但只有N個可以並行ˊˇ，其他則等待並行。 Transformation Operators 2concatMap 簡化 map再concatAll的動作switchMap 簡化 map再switch的動作mergeMap 簡化 map再mergeAll的動作 參數1:map function,回傳Obs參數2(op):map function2,回傳value參數3(op):merge並行數量限制 Utility Operators //延遲emitsource.delay(500);source.delay(new Date(Date.now()+500)); source.delayWhen( x =&gt; Rx.Observable.empty().delay(100).take(1)); do監聽,回傳上一級Obs Obs.do(x =&gt; console.log(‘send: ‘ + x)) Error Handling Operators source.map(x =&gt; x.toUpperCase()).catch(error =&gt; Rx.Observable.empty()); //送empty導向complete.catch((error, obs) =&gt; Rx.Observable.empty() .startWith(‘連線發生錯誤： 5秒後重連’) .concat(obs.delay(5000)) );//5000ms後回送自己使其再重新subscribe source.map(x =&gt; x.toUpperCase()).retry(1);source.map(x =&gt; x.toUpperCase()).retryWhen(errorObs =&gt; errorObs.delay(1000));; Mathematical and Aggregate Operatorscount取得Obs裡含有的Obs數量 (同樣是回傳Obs，不是數字)]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2F02.DOM%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[取得 DOM 物件的常用方法：document.getElementById()document.querySelector()document.getElementsByTagName()document.getElementsByClassName() https://developer.mozilla.org/en-US/docs/Web/Events 滑鼠點擊事件 ‘mousedown’ -&gt; ‘mouseup’ -&gt; ‘click’ ‘mousemove’ //事件捕捉http://blog.techbridge.cc/2017/07/15/javascript-event-propagation/ e.preventDefault //防止執行預設行為e.stopPropagation //終止事件往下層傳播e.stopImmediatePropagation //立即終止事件往傳播(平行傳播也終止) https://developer.mozilla.org/en-US/docs/Web/API/Element]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2Freadme.html</url>
    <content type="text"><![CDATA[資料型態 stringnumberbooleannull and undefinedobjectsymbol (new to ES6) 物件建立一個物件一定會有proto,但不一定有prototype (function一定有prototype) proto:是物件實質的繼承鏈prototype:僅用來規劃繼承內容(所以function之所以稱構造函數,一定要有prototype) var Car = function(){this.speed=100}當mycar=new Car()時,mycar的proto會被指向Car.prototype,當作mycar的繼承鏈 邏輯運算子的延伸 x=A||B||C依序檢查,第一個為true的即指定給x,若全為false則指定最後一個 x=A&amp;&amp;B&amp;&amp;C依序檢查,第一個為false的即指定給x,若全為true則指定最後一個 Hoisting(提升) 指用’var’宣告的變數將被拆為declaration與assignment,declaration的部分將被提升到scope的上方,其值會先處於undefined ‘var’屬於function scope,將被’let’的block scope取代 Closure閉包. 若將function視為一個物件,若呼叫funcA又回傳funcB,此時funcA會自動產生一個物件實體,只要透過funcB就能持續存取這個實體的props.First-class function就是形容有這樣特性的程式語言,將function視為物件(頭等公民) function funcA(){ let c=0; return function() {return c++;}} let funcB = funcA();console.log(funcB(),funcB(),funcB()); //0 1 2 who is this函數中的’this’指向誰 function()宣告 : this指向呼叫該function的object()-&gt;{}宣告 : this指向建立arrow function的對象(即該函數的外層),右邊不加{}即直接返回值,列如:()=&gt;3 bind this綁定function的this對象 以function()宣告為例,this會指向呼叫該function的object例如myobj.func(),func中的this就會指向myobj但let myfunc=myobj.func後在最外層執行myfunc(),此時this會指向window(root object)造成func中的this沒有固定的對象 若要綁定this到固定的對象可以用let myfunc=x.func.bind(myobj);myfunc();或myfunc.call(myobj, arg1, arg2);myfunc.apply(myobj, [arg1, arg2]) PS: bind產生出來的func與原func都仍在同一個closure object裡,只是this指向不同 []除用在array外,還用於computed property names或key-name myobj.var1myobj[“var”+1] key-name的部分與Symbol資料型態是搭配的,用於製造唯一鍵與變數的隱蔽性let x = Symbol(‘sym’);myobj[x]=… getter/setter延伸變數存取的機能性 var myObject = { get a() {return this._a;}, set a(val) {this._a = val * 2;}};myObject.a = 2; 檢查物件是否擁有某prop (不含prototype chain)myObject.hasOwnProperty(“a”); 檢查物件是否擁有某prop (包含prototype chain)(“a” in myObject) 取得屬性描述Object.getOwnPropertyDescriptor(myobj, “myvar”); 設定屬性唯獨Object.defineProperty(myobj, “myvar”, { value: 5, writable: false, //可寫入? configurable: false, //可刪除? enumerable: true}); 禁止物件添加propObject.preventExtensions(myobj); 禁止物件添加/刪除propObject.seal(myobj); 禁止物件添加/刪除/修改propObject.freeze(myobj); 以上均為淺層(shallow)的設定 enumerable列舉,相當於一個無序屬性的集合能被列舉的對象表示能透過for-in歷遍(Traversals)object與array的元素預設都是enumerable (若透過descriptor定義則預設是false) for (key in myobj) { console.log(key + ‘ : ‘ + myobj[key]);} iterator迭代器,一個能夠產生無須索引(key)資料的function().next(),例如產生亂數…在JS裡iterator固定建立於myobj[Symbol.iterator] iterator有延遲運算(Lazy evaluation)的特性,即call-by-need,很適合做非同步運算(把大量串列運算切割分時執行)這部分其實跟generator很相似 取得:var arr = [1, 2, 3];var iterator = arrSymbol.iterator;iterator.next(); //{ value: 1, done: false } 自建:myObject[Symbol.iterator]=function(){ var idx = 0; var ks = Object.keys(myObject); return { next: function() { return { done: (idx &gt;= ks.length), value: myObject[ks[idx++]] }; } }; }或透過defineProperty建立Object.defineProperty(myObject, Symbol.iterator, {…}); Generator類iterator(也有next()函數),在某些情境上程式碼會更精簡有彈性 function* hello_g() { yield ‘hello’; // when step 0 yield ‘world’; // when step 1}var iter = hello_g();for (var v of iter) { console.log( v );} Observable可觀察物件.來自RxJS,補強很多JS相關於互動與非同步的操作.從enumerable -&gt; iterator -&gt; generator,都跟處理串列資料有關但又僅止於資料產生,RxJS的Observable的設計則更有應用情境. for (let key in myobj/obj) //與enumerableObject或Array都可以用 for (let value of arr) //object要有iterator才能用,或是object為一個generatorArray可以用,Object要自寫iterator for (let [key, value] of map) //of map回傳的是陣列[key, value],所以可以這樣寫(解構) arr.forEach(function(value, key, arr){…}); (記法 : in enumerable(有key) ; of iterator/generator/map) Set Map 數學公式上迭代：使用迴圈實作。有疊加的意思遞迴：函式推疊呼叫。 @ 開頭是實例變數(instance variable)@@ 開頭則是類別變數(class/prototype) 簡寫 let name=”jim”let myobj = { name, //等同於name:name who() //等同於who: function() { return this.name }} Destructuring解構,簡化變數宣告與指定 []:以左右邊的順序依序指派var [x, y, , z = 100] = [1, 2, 3];for (let [key, value] of map) {}:依key指派var {w, h} = {x:0, y: 0, w:100, h:100};var {w, h} = getSize(); mixin: 混和,僅一名詞. 指的是多重繼承,一般只有單一繼承,JS可透過修改Prototype達到多重繼承的效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2F00.Promise%20%26%20async%20%26%20await.html</url>
    <content type="text"><![CDATA[Promise 解決3個問題 callback hell (循序執行)通常處理非同步問題都是用callback做handle函數,有些事件可能是循序N次才處理完就變成一個很多層的callback function擠在一起 getAsyncData1(function (){ getAsyncData2(function (){ //… }}) getAsyncData().then(…).then(…) 併發執行 與 比快執行Promise.all([getUser, getArticle]).then(success);Promise.race([getUser, getArticle]).then(success); 3.一個catch能處理所有的rejectpromise1.then(data=&gt;promise2).then(data=&gt;{…}).catch(ason=&gt;{…}) Promise的組成 1.建立異步事務(executor function)var promise=new Promise((resolve, reject) =&gt;{ setTimeout(function() { resolve(‘DATA’) // for ok data //reject(‘X’) // for rejection reason }, 3000); }) 異步事務的resolve(…) 對應 接收結果的then(func1)異步事務的reject(…) 對應 接收結果的catch(func)或then(func1,func2)的func2executor function的return似乎沒有什麼意義 2.接收事務執行結果promise.then(data=&gt;{…}, reason=&gt;{…}); 狀態[[PromiseStatus]]：pending(待定) | resolved(已解決) | rejected(已拒絕) promise.then()的回傳同一個promise每次then()都匯回傳一個新的實體,但對應到同樣的結果,不能reuse也不能retry,retry機制必須寫到事務函數中 不管then()多少次,回傳的都是第一個promise,then裡面只是放異步處理的函數宣告多個promise時,所有的promise都由第一個promise替我們傳遞執行結果 promise.then()的執行promise1.then(data1=&gt;{console.log(data1)}) 返回另一個promisepromise1.then(data1=&gt;{console.log(data1);return promise2}).then(data2=&gt;console.log(data2)) //data2 = promise2’s resolve 返回資料 (當filter)promise1.then(data1=&gt;{console.log(data1);return 123}).then(data2=&gt;console.log(data2)) //data2 = 123 (then內的function基本上可以回傳三種類型,value/promise/thenable)也可以在事務函數中寫resolve(nextPromise),nextPromise會自動被循序執行,不需要寫then 靜態方法 Promise.resolve Promise.reject同樣用來傳遞value/promise/thenable Promise.resolve(‘data’)相當於new Promise((resolve, reject)=&gt;{resolve(‘data’)}); 沒看出來特別意義 async / await async:做為function宣告的前綴字,表示這個function是異步執行await:做為Promise執行的前綴字,表示等待Promise完成,並使該Promise的回傳變成傳入resolve()的值 await的使用一定要在異步函數中]]></content>
  </entry>
  <entry>
    <title><![CDATA[ObjectClone]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FObjectClone.html</url>
    <content type="text"><![CDATA[shallow copy:拷貝Object:只能拷貝Primitive Type,其他object類( array function date regx )都只能reference拷貝Array:只能拷貝一維中的Primitive Type. //slice funcvar copyarr = arr.slice(0); //spread op (拆解再置入)var copyarr = […arr]; //assign (也可做合併)var copyarr = Object.assign([], arr);var copyobj = Object.assign({}, obj); deep copy: //純資料複製,function會變成undefinedvar copyarr = JSON.parse(JSON.stringify(deepArray)) //jqueryvar copyarr = $.extend(true, [], arr); //lodashvar copyarr = _.cloneDeep(arr);]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fdecorators.html</url>
    <content type="text"><![CDATA[@inputmytype:number=1;component中變數加上@input即可對應HTML tag上的props 可以用別名對應外部的props name@input(‘propsColor’) color:string; @outputmyclick = new EventEmitter();…myclick.emit(value)component中變數加上@input即可對應HTML tag上的事件 其中$event是ng的保留字,必須這樣寫在JS框架中很中很多對應都是字串解析對應到程式碼宣告,對應關係從字面會很難理解,需要透過手動試驗才比較好搞懂 ***自訂two way binding要做兩件事 @Input() myvalue: number;@Output() myvalueChange: EventEmitter = new EventEmitter(); 1.output前綴字為input+Change2.必須要自己發emit3.如果只用[myvalue]的方式binding,必須再寫(myvalueChange)=”…”自己處理 @ContentChild與@ViewChild (@ContentChildren / @ViewChildren)兩者同為取得child component,但取得的時機與component所處的 @ContentChild(ChildComponent) child:ChildComponent;@ContentChildren(ChildComponent) childs:QueryList; 1.ContentChild取得的child是透過引入的childViewChild取得的是自己template裡加上的child 2.ContentChild是在ngAfterContentInit時取得ViewChild是在ngAfterViewInit時取得 這也是因為ContentChild的建立比ViewChild的建立早]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fcomponent%E4%BA%92%E5%8B%95.html</url>
    <content type="text"><![CDATA[data binding@input@output[(ngModule)] Template中可透過#做互動 Stop]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2F01-Architecture.html</url>
    <content type="text"><![CDATA[程式進入點通常為main.ts (這裡的module與js中import/export的module是不同的層級的觀點,一個是js檔案結構,一個是ng的應用結構) function call前有加@,表示前置函數,其後接的class宣告將一起被帶入該函數,ng用這樣的方式把custom classes與ng系統結合 1.modules @NgModule({METADATA})export class AppModule{} 基本上都會有一個root module(即AppModule),視需要在加入其他feature moduleroot module : 一定會import’BrowserModule’,因為與網頁瀏覽(view/route)相關feature module : 一定會import’CommonModule’ [METADATA]declarations: 宣告module裡需要用到的’view classes’,包含components,directives,pipeeports ? 將自己declarations中的feature module開放import : 引入feature module供component使用(自動注入?)providers : 宣告共用的DI services,供其他部件bootstrap : 指定root component,相當於指定view的初始畫面. 只有root module需要指定bootstrapdirectives : 使用將value傳給subcom的props時,需將subcomp列為direvtives 2.components @Component({METADATA})export class HeroListComponent{} 類似MVC中的control角色,負責UI流程 [METADATA]moduleId: module.id,指定後Url的部分可以設定為相對路徑selector: 連接該元件的HTML tag名稱providers: 宣告元件私有的DI servicestemplateUrl: 該元件的template位址style/styleUrls:css style,其style不會擴散到component外,也不會到sub component,完全只在自己的template中套用inputs: 用法同@input 3.templates 即HTML模板 Angular’s template syntaxhttps://angular.io/guide/template-syntax 4.data binding bind的用途1.顯示資料 2.傳遞資料(透過props)除了bind字串數字外,也可以bind物件 (-&gt;為bind to,資料流向之意) interpolation (component value -&gt; DOM) property binding (component value -&gt; DOM) event binding (DOM event -&gt; component) Two-way data binding (component value DOM) - parent.value -&gt; subcom.props &lt;subcom props=&gt; parent.value subcom.props parent.value &lt;- subcom.props??? 5.directives 諸如ngFor與ngIf甚至做two way binding的[(ngModel)]都是directive連component都是一個繼承了template導向的directive import { Directive, ElementRef, Renderer } from ‘@angular/core’;@Directive({ selector: ‘[myHidden]’ })export class HiddenDirective { constructor(el: ElementRef, renderer: Renderer) { renderer.setElementStyle(el.nativeElement, ‘display’, ‘none’); }} 一個Html tag中可能有多個directive,每個各自都會被執行若有兩個directive的selector的名字是一樣時,就看該元件declarations中加入directive的順序,依序執行 6.Services 任何物件都可以成為Service,不需要extends或implements任何類別可以當作是一個MVC中module的概念,或任何的運用主要是service加到METADATA中的provider後能提供依賴注入(DI) 7.dependency injection依賴注入,簡單說就是一個分工的概念,將模組依某特性劃分開,以利重複使用與管理.在程式碼上的實踐就是將其依賴的模組從參數列傳入. 宣告方式:METADATA…providers:[HeroService] 注入方式:constructor(private service: HeroService) { } module providers:所有component共用一個實體的servicecomponent providers:每個實體的component都有自己一個實體的service]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2FDirectives.html</url>
    <content type="text"><![CDATA[https://dotblogs.com.tw/wellwind/2017/02/14/angular2-directive-intro 分三種Components:即DOM elementStructural:改變DOM element結構,像是ngIf與ngForAttribute:改變DOM element的顯示或行為,可以當作一種擴充與重複利用的概念 ng-content將HTML_CONTENT傳送給component mytpl: HTML_CONTENT subcomp-tpl: 用select指定要插入的component(類似css的selector) &lt;my-component&gt; &lt;div mycardtype1&gt; A &lt;/div&gt; &lt;div class=&quot;mycardtype2&quot; style=&apos;color:red&apos;&gt; B &lt;/div&gt; &lt;div mycardtype3=1&gt; C &lt;/div&gt; &lt;/my-component&gt; &lt;div class=&quot;my-component&quot;&gt; &lt;div&gt; Title: &lt;ng-content select=&quot;[mycardtype1]&quot;&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;div&gt; Content: &lt;ng-content select=&quot;.mycardtype2&quot;&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;div&gt; Content: &lt;ng-content select=&quot;[mycardtype3=1]&quot;&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;/div&gt; Title:AContent:BContent:C]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2FRxJS.html</url>
    <content type="text"><![CDATA[http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/https://segmentfault.com/a/1190000005051034 Observable算是一種設計邏輯,一般函數呼叫的運作都是同步的,偶爾會希望它是異步的,所以會用setTimeout的方式進行異步,但setTimeout在情境意義上比較缺乏,Observable就像加入情境意義的setTimeout 通常的設計都有’提供服務者’與’被服務者’,就像server與client的關係,溝通上可以用push與pull來區別pull(拉取) client主動 向 server取得資料push(推送) server主動 向 client推送資料 其中pull又稱作’輪詢’,即定時詢問之意,其資料的即時性掌握在client的主動程度;push則類似youtube的頻道訂閱(subscribe),若有訂閱,在頻道更新時會由server主動推送通知 兩者各有所長,例如pull適合應用在’取樣’大量事件,或有些較低階的語言不易實行pushpush最大的優點就是即時,又有效率,但也有些情境讓push很為難,像是上述的大量事件,要每個事件都即時傳達是不可能,也可能造成server超過負荷 js最常用到的push方式就是button event,透過addListener向event emitter註冊一個event listener觀念轉到RxJS上,event emitter就是Observable,event listener就是Observer Observable基本上透過Rx.Observable.create建立,或從第三方應用中取得]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fangular2%2Fdecorators%20-%20Pipe.html</url>
    <content type="text"><![CDATA[功能形容: &lt;p&gt;&#123;&#123; birthday | mydate:fmt &#125;&#125;&lt;/p&gt; 輸出 April 15, 1988 而非 Fri Apr 15 1988 00:00:00 GMT-0700其中的mydate就是一個pipe元件 又分pure跟impure區別在pure是在birthday更動時運作,impure則在任何的component change detection cycle運作是需求選用 範例@Pipe(&#123; name: 'mydate', pure: true&#125;)export class MyDatePipe implements PipeTransform &#123; transform(value: number, fmt: string): string &#123; return ...; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.others%2Fserver%20rendering.html</url>
    <content type="text"><![CDATA[意指瀏覽器上顯示的內容是直接從伺服器產生 直接的嵌在html中 相反的則為client rendering,顯示內容為client端執行js後產生,server在只負責產生一個基本能使js運作的網頁與data api讓client js查詢]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fdatabase%2FmongoDB%2Freadme.html</url>
    <content type="text"><![CDATA[http://ithelp.ithome.com.tw/articles/10165786http://mongodbcanred.blogspot.tw/2015/01/mongodb.htmlhttp://mongodbcanred.blogspot.tw/2015/01/mongodbinsert-document-remove-document.htmlhttp://ithelp.ithome.com.tw/articles/10166066?sc=pt RDBMS到NoSQL DB-&gt;DBTABLE-&gt;COLLECTION : 可以不用事先定義欄位 (稱為Schema-Free)RECORD/ROW-&gt;DOCUMENT : COLLECTION下的每筆DOC允許有不等數量的欄位Column-&gt;FieldPK-&gt;_id DOC為JSON格式(儲存的格式為BSON,即binary) 可透過 subcollections來組織資料庫,例如IT部門下有兩個子部門ERP跟MIS,就可以分別建成三個collectionIT / IT.ERP / IT.MIS 選取或建立DBuse mydb 顯示目前操作的DB(db相當於指向目前使用的DB)db 顯示所有DB(至少含有一個collection的DB才會被顯示)show dbs 刪除DBdb.dropDatabase() 建立COLLECTIONdb.createCollection(NAME, OPTIONS) (直接用insert也可以用預設的OPTIONS建立COLLECTION) db.createCollection(“mycol”)db.mycol.drop()show collections 插入DOCdb.collection.insert(&lt;documents&gt;,&lt;option&gt;)db.mycol.insert(&#123; title: 'MongoDB Overview', description: 'MongoDB is no sql database', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;) : 資料寫入確保writeConcern:寫入確保等級設定 w:-1 (嚴謹性：非常低)；發生資料庫寫入錯誤一律不回傳 w:0 (嚴謹性：低) ；只可以偵測到網路錯誤 w:1 (嚴謹性：中 預設等級) w:1,j:1 (嚴謹性：高) ；在寫入日誌後才回傳處理過程。 w:2 (嚴謹性： 高 ) ；這個級別只在replica set的部署模式下生效 db.collection.insert({name:’jim’},{writeConcern:{w:1,j:1}}) 更新DOC (update:僅更新值) db.COLLECTION_NAME.update(WHERE, UPDATED_DATA, OPTIONS)db.mycol.update(&#123;'title':'MongoDB Overview'&#125;,&#123;$set:&#123;'title':'New MongoDB Tutorial'&#125;&#125;,&#123;multi:true&#125;) 預設僅能更新單一doc $set : 設定key的value$unset : 刪除key$inc : 累加 更新DOC (save:有_id時為’取代’doc,沒_id時相當於insert) 刪除DOCdb.COLLECTION_NAME.remove(WHERE,justOne&lt;option&gt;)db.mycol.remove() //刪除全部 查詢DOC (find/findOne)db.COLLECTION_NAME.find(WHERE).pretty() 用pretty()返回格式化內容 WHERE:where A = ‘ABC’ : {“A”:”ABC”}where A &lt; 1 : {“A”:{$lt:1}}lt ltegt gtene$in (包含)$nin (不包含)$and (和)$or (或)$not (否)$all 匹配所有指定內容才行(and) (key為陣列時)$in 匹配一筆指定內容即可(or) (key為陣列時)$size (node數量) (key為陣列時)$type 匹配資料型態$elemMatch 進入sub doc匹配$slice 取陣列的部分元素 (稍微複雜,要用例子驗證一下行為) OR: (預設為AND)A=1 and (B=2 or C=3)&#123;&#123;"A":1&#125;,&#123;$or:[&#123;"B":2&#125;,&#123;"C":3&#125;]&#125;&#125; key:value區分大小寫,可以用正規表示法(但速度比較慢)db.mycol.find({name:/Russell/i}) 投影 (Projection) : 僅查詢DOC的部分資料 (1:顯示 0:不顯示)(_id預設為顯示)db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;) 限制DOC數量db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;).limit(2) 略過N個DOCdb.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;).skip(1) 取得DOC數量db.mycol.find().count() Indexing Aggregation and Groups]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fseo%2Freadme.html</url>
    <content type="text"><![CDATA[titlemeta keyword/description h1 / h2 img-alt goggle trends robots.txt規範搜尋引擎$用來結尾,否則路徑後可能被視為*指定Sitemap路徑 sitemap.xml主動提交sitemap給各大搜尋引擎,要求搜尋引擎建立檢索內容包含各個url,及其更新頻率/日期/重要程度等 其內容可靠軟體自動產生 http://www.google.com/webmasters]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJQuery%2F05.AJAX.html</url>
    <content type="text"><![CDATA[$(‘#result’).load(‘url…’) $(‘#result’).load(‘url…’, function(respTxt, statusTxt, xhr){})$.get(‘url…’, function(respTxt, statusTxt, xhr){}) statusTxt為’success’或’error’ load基本上與get相同,但會將get回的內容置於selector中 load / get /getJSON $.ajax({ method: ‘GET’, url: ‘’, dataType: ‘json’}).done(function(data){}) $.post(url, {title:’A’, body:’B’}).done(function(data){})]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJQuery%2F03.dom%20manipulation.html</url>
    <content type="text"><![CDATA[$(‘p’).css(‘color’,’red’)$(‘p’).css({color:’red’, background:’white’}) $(‘p’).addClass(‘css1’)$(‘p’).removeClass(‘css1’)$(‘p’).toggleClass(‘css1’) $(‘p’).text(‘plain text’)$(‘p’).html(‘html text’) $(‘p’).append(‘html text’)$(‘p’).preappend(‘html text’) $(‘p’).appendTo($(‘p’))$(‘p’).preappendTo($(‘p’)) $(‘p’).before(‘html text’)$(‘p’).after(‘html text’) $(‘p’).empty()$(‘p’).detach() //get text back$(‘p’).text() $(‘p’).wrap(‘‘); //每個p外個包一個h1$(‘p’).wrapAll(‘‘); //所有的p包一個h1 (在p跟p中間但不在p裡的元素會被移出到下面,或是說只有p被搬出來) $(‘a’).attr(‘target’); //get$(‘a’).attr(‘target’, ‘_blank’); //set$(‘a’).removeAttr(‘target’); $.each([‘Brad’,’Kelley’],function(idx,val){}) var newObjArr = $(‘ul#list li’).toArray()]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJQuery%2F04.effects%20and%20animaion.html</url>
    <content type="text"><![CDATA[$(‘#box’).fadeOut()$(‘#box’).fadeIn()$(‘#box’).fadeToggle() $(‘#box’).slideDown()$(‘#box’).slideUp()$(‘#box’).slideToggle() $(‘#box’).stop() $(‘#box’).fadeOut(‘fast’) // fast slow 3000$(‘#box’).fadeOut(3000, fadeDoneFunc) $(‘#box’).animate()({ //css left:500})可以連續執行animate,內部會自動依序動作]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJQuery%2F02.event.html</url>
    <content type="text"><![CDATA[$(document).ready(function(){….}) $(‘#btn1’).click(function(e){}) $(‘#btn1’).on(‘click’, function(e){}) click / dbclick / hover / focus / blur / keyup / change / submit … for on()click / mouseenter / mouseleave / mousemove / mousedown / mouseup … show() hide() toggle()元素顯示隱藏 $(this) 便於在callback中取得發出事件的元件 $(this).css(‘background’, ‘pink’)$(this).text(‘x’+e.clientX) $(this).text(‘key’+e.which)e.preventDefault 阻止事件向上回報(冒泡)]]></content>
  </entry>
  <entry>
    <title><![CDATA[__]]></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2Fjavascript%2FJQuery%2F01.selector.html</url>
    <content type="text"><![CDATA[$ = JQuery $(‘dom_element_name’)選擇物件,回傳可能是0個到1個以上的element p.classp#id $(‘p span’)選擇p元素下的所有span元素 :first:last:even :odd :nth-child(3n) $(‘p span:first’)第一個在p元素下的span $(‘:text’).hide()選取參數type為text的元素 $(‘[type]’).hide()選取有type參數的元素 $(‘[herf=”http://www.google.com&quot;]&#39;) 選取herf參數為指定字串的元素]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2F%E6%95%B4%E7%90%86%E4%B8%AD%2F00.editor%2Fatom%2Freadme.html</url>
    <content type="text"><![CDATA[//js語法提示補全atom-ternjs //git command supportgit-plus //html標籤快打emmet file-icons atom-live-server //標籤索引todo minimap //顯示css顏色pigments //語法檢查linter //排版atom-beautify //stack overflow搜尋ask-stack //將與選取字串同樣的字串標示highlight selected //git serverC:\Users\Jim\AppData\Local\atom\app-1.18.0\resources\app\node_modules\dugite\git\git.exe //git commandC:\Users\Jim\AppData\Local\atom\app-1.18.0\resources\app\node_modules\dugite\git\cmd\git.exe set PATH=%PATH%;C:\Users\Jim\AppData\Local\atom\app-1.18.0\resources\app\node_modules\dugite\git\cmd\]]></content>
  </entry>
</search>
