<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Singleton]]></title>
    <url>%2F%2FSingle%2FSingleton.html</url>
    <content type="text"><![CDATA[video 建立的兩個需求: thread safe lazy Plainclass MySingale&#123; private MySingale()&#123;&#125; public static MySingale instance = new MySingale();&#125; //kotlinobject MySingale&#123;&#125; Lazy (not thread safe)class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; val instance by lazy(LazyThreadSafetyMode.NONE)&#123; MySingale() &#125; &#125;&#125; Lazy (thread safe)(synchronized) 加synchronized class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static synchronized MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; private var instance: MySingale? = null @Synchronized fun getInstance(): MySingale&#123; if (instance == null) instance = MySingale() return instance &#125; &#125;&#125; Lazy (thread safe) (volatile) 加volatile : 確保不同thread中能立即察覺變數的更動 class MySingale&#123; private MySingale()&#123;&#125; private static volatile MySingale instance; public static MySingale getInstance()&#123; if (instance == null)&#123; //避免持續進入synchronized synchronized (MySingale.class)&#123; if (instance == null)&#123; instance = new MySingale(); &#125; &#125; &#125; return instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; val instance by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; MySingale() &#125; &#125;&#125; 透過Holder (靜態內部類) 透過static Holder達到lazy new操作在java中原本也就是thread safe class MySingale&#123; private MySingale()&#123;&#125; private static Holder&#123; private static MySingale instance = new MySingale(); &#125; public static MySingale getInstance()&#123; return Holder.instance &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; fun getInstance() = Holder.instance &#125; companion Holder&#123; val instance = MySingale() &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2F%2FSingle%2FKotlin.html</url>
    <content type="text"><![CDATA[官方文件 簡介 介於Java與Scala之間 困擾 因為setter與getter緣故 難以區別’賦值’與’叫用’ 看不出in func的移轉 ()裡是什麼? 前綴是class : 建構成員參數宣告 前綴是fun : 函數參數宣告 {} 裡是什麼? 前綴是class : class宣告 前綴是fun : fun宣告 匿名函數 lambda 描述 不用分號結尾 一個檔案可多個類別 預設類別名稱 FilenameKt 沒有Primitive類型 全是Object (所以Java要存取都須透過getter/setter) 沒有static關鍵字 @JvmStatic @JvmField 方便對映回java對應 關鍵字 internal : 不允許外部訪問 (修飾class對java無效;但修飾fun會造成java無法access) Annotation @JvmOverloads //使fun多載(默認參數) @Synchronized @Volatile @JvmSuppressWildcards 避免Any轉成Java的? package 不宣告即為預設的package 檔案路徑不須對應package import 可以引入function 變數 前面一定要val或var val : 不可變(final) var : 可變 lateinit : 告訴編譯器稍晚會init不要報錯 但若沒有init執行時仍會丟異常 var 變數名稱: 型態 ＝ 初始值var x : Int = 1var x = 1 //自動推定var age_:Int? = nullx as String //轉型 (不需要再傳給變數)x.trim() Int String Unit : 相當於void Any : 類似Object 但不能是null IntArray / intArrayOf(1,2,3) vararg : 相當於Java接收參數String args…, 用*vararg能將其轉回陣列與java互用 Null 變數預設不能為null 型別後加?才能為null 安全調用 obj?.getNum()?:-1 空斷言!! 當null時報出exception (表示上:在變數後加!提示該變數是nullable) var x: Any //允許,但後續仍會被要求initvar x: Any? = nullfun getLength(s:String?):Int = s.length //編譯器不會過fun getLength(s:String?):Int = s?.length?:0fun getLength(s:String?):String = s!! function open : 可複寫 寫在最外層會變成 FilenameKt的靜態method open fun myfunc(x: Int, s: String) : Int&#123;&#125;//單行回傳fun getAge() = age 匿名函數 不允許冠return 最後一行的變數或結果自動當作回傳 fun myfunc(type: Int, func: () -&gt; Int)&#123; println(func())&#125;myfunc(1,&#123;7&#125;) //熟悉的寫法myfunc(1)&#123;8&#125; //較難理解的寫法myfunc(func = &#123;9&#125;, type = 1) //指定參數位置fun myfunc(func: () -&gt; Int)&#123; println(func())&#125;myfunc&#123;10&#125; //很難理解的寫法 SAM conversion//前面沒有fun關鍵字 後面接&#123;&#125;就是傳入匿名參數 懶加載 by lazy被用到時才初始化 val xy:Int by lazy &#123; val x=1 val y=5 x+y //最後一行即為匿名函數的回傳&#125; 具名函數 有回傳須指定型態 且要冠return fun func1():Int &#123;return 1&#125; //指名為func1fun func2() &#123;2&#125; //指名為func2fun func3() = &#123;3&#125; // &#123;3&#125;為匿名函數(lambda) 指定給func3作為回傳fun func5() = 5println("func1 ? " + func1()) //1println("func2 ? " + func2()) //kotlin.Unitprintln("func3 ? " + func3()) //Function0&lt;java.lang.Integer&gt;println("func3' ? " + func3()()) //3println("func4 ? " + &#123;4&#125;()) //4println("func5 ? " + func5) //5 //程式進入點func main(args:Array&lt;String&gt;)&#123;&#125; string templateval x = 1println("x = $x");println("x+1 = $&#123;x+1&#125;"); if-elseval max = if (x &gt; y) x else y when if 也可以回傳值 後面接的是lambda val x = 1var y:Intwhen (x) &#123; 1, 2 -&gt; y = 1 in 20..30 -&gt; y = 1 else -&gt; y = -1&#125;//SmartCast 可回傳var v = when (obj) &#123; is String -&gt; Integer.parseInt(obj) is Number -&gt; obj.toInt() + 5 else -&gt; -1&#125; forfor (i: Int in 1..5 step 2) &#123; print(y)&#125;//135for (i: Int in 5 downTo 1) print(i)//54321 lambda it : 預設第一個引數 val ia: IntArray = intArrayOf(120, 30, 15, 27, 66)ia.filter &#123; it &gt; 50 &#125; // 留下大於50的元素 .sortedBy &#123; it &#125; // 依照大小排序 .map &#123; it / 10 &#125; // 元素值除以10 .forEach &#123; print("$it-") &#125; // 顯示元素值 // 顯示： 6-12- class open : 可被繼承 close : inner : 預設的inner class是static的(與java相反), 要成為member class需加inner open class Person(var name: String) &#123; // 首要建構子的參數列 (有寫就一定要call)//參數列宣告有加var或val才能被外面存取//首要(primary)建構子 (有寫就一定要call) init&#123; &#125;//geter / setter var age:Int get() = age // java用.getAge() kotlin仍用.age set(value) &#123;age=value&#125; //這樣寫會recursive,要用field取代age set(value) &#123;field=value&#125;// 其它建構式，使用this(name)呼叫主要建構式 constructor(name: String, , age: Int) : this(name) &#123; this.age = age &#125; fun sayHi() &#123; println("Hi, $name!") &#125;&#125;//繼承open class NewPerson(name: String) : Person(name)&#123; override fun sayHi() &#123; println("Hey, $name!") &#125;&#125;val person = Person("Jim")println(person.age)person.sayHi() object 單例(Singleton) 立即實體化 沒有建構子 靜態實例 類似java的static 但access寫法不一樣 僅能透過ClassName存取 不能透過實例存取 中間多有一個單例的名稱 無法訪問其outter class的成員 (因為是單例/靜態/不屬於物件) 可以實作介面 但不能繼承 因為沒有建構子 可以宣告在任何地方 companion只能定義在class中 且僅能有一個 類似於static interface MyInterface &#123; fun doit() &#125;object single : MyInterface&#123; override fun doit() &#123; &#125;&#125;class MyClass&#123;//static companion object&#123; //變數預設名稱為Companion var x=1 fun myStaticFunc() &#123; &#125; //java叫用MyClass.Companion.sfunc() &#125;//單例 (class外部無法access) object mySingle&#123; var x=1 fun myFunc() &#123; &#125; &#125;&#125;//外界access方式 (不能透過類別實例存取)MyClass.myStaticFuncMyClass.mySingle.x MyClass.Companion.myStaticFuncMyClass.mySingle.x 類別擴展 用途類似包裝utils工具 MyUtils.ext(person) 但更便利 Java無法使用 有block範圍限制 不同block可有各自的擴展 (預編譯要先過) 可以靜態擴展 (可擴展第三方類別) 可以動態擴展 (但離開block後就不能用了) 可以透過import 在不同的檔案類別中共用 fun Person.ext()&#123; println("are you $name ?")&#125;import com.example.myextends.extimport com.example.myextends.*//泛型fun &lt;T&gt; T.basicToString(i: Int) &#123;&#125;basicToString&lt;String&gt;(1) infix : 語法糖 便於閱讀 infix fun String?.append(s:String?) = this+svar x = "xxx" append "dddd" 泛型video*postpost ? 相當於 * (這樣說不正確) extends 相當於 out get安全 set禁止 生產者 super 相當於 in set安全 get禁止 消費者 inline : 相當於將函數程式碼坎入到caller處 比較適用於lambda型式的函數 refied : 與重新定義泛型有關 //聲明處型變interface Source&lt;out T, in E&gt; &#123; // &lt;&lt;---在這裡 fun funOut(): T //out表示僅能定義在輸出 fun funIn(t:E) //in表示僅能定義在輸入&#125;//使用處型變interface Source&lt;T&gt; &#123; fun funIn(t: Source&lt;out T&gt;) // &lt;&lt;---在這裡&#125;//泛型約束&lt;T extends String&gt; ==&gt; &lt;T : String&gt;//kotlin允許多個約束 (用where關鍵字)open class Food&#123;&#125;open class Fruit : Food()&#123;&#125;class Apple : Fruit()&#123;&#125; 不型變 指List與List是無關聯的 協變 指List是List的子類”型” (不是子類) 逆變 指List是List的子類”型” 突破java限制: //javainterface Source&lt;T&gt; &#123; public T nextT();&#125;public void demo(Source&lt;String&gt; strs)&#123; Source&lt;Object&gt; objs = strs; // 在Java中是不允许的 // 正确方式为 // Source&lt;? extends Object&gt; objs = strs;&#125; //kotlinabstract class Source&lt;out T&gt; &#123; // 使用out的话，T只能作为返回值 abstract fun nextT(): T // 不能作为传入参数，下面会报错 // abstract fun add(value: T)&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs&#125; functioninterface Function &lt;in T, out U&gt;Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt; enum 與 sealed sealed用法類似enum 但能以class或object識別 enum class Lang(val text: String)&#123; ENGLISH("Hello"), CHINESE("你好");&#125; sealed class Cmd(val text: String)&#123; class Play(val url): Cmd object Stop: Cmd&#125; 委派 Delegate field存取委派 內部用get/set實現 Delegates實作要繼承ReadWriteProperty 像是做lazy或監聽 var state:Int by Delegates.observable(0, &#123;prop, old, new -&gt; &#123; println("$old =&gt; $new")&#125;) 尾遞歸優化 避免StackOverflowError (其實就是轉為loop處理) 遞歸函數在最後呼叫稱為尾遞歸 函數前綴 tailrec Operator overloadinga == b // a.equals(b)a..b // a.rangeTo(b)a in b // a.contains(b)a[i] // a.get(i)a[i] = 9 // a.set(i, 9) 其他class MyClass&#123;&#125;Class::class.java //取得class實例 等同於Java的MyClass.class]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth]]></title>
    <url>%2F%2FSingle%2FOAuth.html</url>
    <content type="text"><![CDATA[youtube 意義user =&gt; client app(consumer) &lt;=&gt; server(service provider) app取得provider的service user不必向app透露帳號密碼 過程 client請求request token client將主導權導向server server向用戶詢問是否授權(導向server提供的畫面) server將主導權導向client client請求access token Signature 簽名 server透過signature驗證用戶身份 Signature = Signature Base String (AES with) secret key Signature Base String大概是由url的特徵產生 secret key僅有加密者與server知曉,故透過Signature就能讓server辨試身份 Request Token 與provider對話權的令牌 初步驗證app的權限後取得 client提供app key與signature向server請求request token Access Token 存取用戶資料授權的令牌 驗證用戶身份與同意授權項目後取得]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread的各式需求]]></title>
    <url>%2F%2FSingle%2FThread%E7%9A%84%E5%90%84%E5%BC%8F%E9%9C%80%E6%B1%82.html</url>
    <content type="text"><![CDATA[相關知識 program : binary code,一段機械碼或可被執行的檔案 process : 執行一個program後形成一個process,其中包含一塊記憶體空間(code/heap)與thread. process間是不共用的,互相通信需特殊的機制 thread : 實際執行程式碼的單元 包含一stack儲存原生變數與參考及函數流程等執行位址 task : 任務,軟體概念,task是指派給thread執行的,類似Runnable corutine: 協程,軟體概念,由應用程式或編譯器實作的軟體架構,目的在於有效與便利運用thread與thread間的切換 corutine例如要完成一個取得一筆資料顯示到ui上,額外需要一個io thread避免ui thread被較慢的io thread阻塞,程式的編寫上可能需要一個func切換到io thread執行,還要一個callback func返回執行結束,以及一個組合這些流程的func,一整個流程散落各處. 協程相當於將block排程到thread中,由背景系統決定執行時機,也就是說該block成為該thread中一個異步執行的任務,我們只需透過async宣告異步任務與await等待任務,就能將前述的動作寫在一個block中. 用於單執行緒的javascript中最為顯著. async&#123; value = await getData();&#125; concurrent vs parallel concurrent : 並行 N -&gt; 1 像是排程(Javascript) parallel : 平行 N -&gt; N Thread的切換一個流程中某些動作必須跳到異步執行 待執行完再切回原本的thread 這些切換thread的動作將使一個流程無法順暢的寫完 舉例: user按下執行按鈕 (ui) 下載url的內容 (network) 存成本地檔案 (i/o) 取得執行狀況 將內容顯示於ui (ui) coroutine 協程 透過async/await讓工作不立即執行 且能夠被等待 相當於排程的概念 更有效率的使用thread 例如 : 在main thread中連續執行ABC三函數 一般情況下執行的順序是ABC 若B能進入異步 順序會變為AC…B (B不確定何時執行) 若B能進入異步 且C能等待B執行完 順序又變回ABC 假若B在異步執行時是透過其他thread 那C等待B時main thread還能繼續其他工作 Javamessage handler適合簡單的切換 多個連續流程仍難以處理 exector 預先做好各個thread,執行時丟入runnable 切換越多次巢狀越明顯 沒辦法等待(await) (等待會進入blocking) public class AppExecutors &#123; //seeu 建立Thread切換機制 private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors() &#123; diskIO = Executors.newSingleThreadExecutor(); networkIO = Executors.newFixedThreadPool(THREAD_COUNT); mainThread = new MainThreadExecutor()); &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; private static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; Kotlin (透過協程)RxJavaEventBus]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShellCmd]]></title>
    <url>%2FLinux%2FSingle%2FShellCmd.html</url>
    <content type="text"><![CDATA[refref find grep awk//資料夾中搜尋文件內容grep -r '導航' ~/GoogleDrive/grep -r --include="*.java" "service" .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo安裝紀錄]]></title>
    <url>%2F%E7%B4%80%E9%8C%84%2FSingle%2FHexo%E5%AE%89%E8%A3%9D%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[Hexo 、NexT 目標本地端透過Hexo建立網站骨架 並將markdown文章轉為html 上傳到github做為blog網站 安裝node.js node.js為一本地端的js執行平台 用途廣泛 npm (安裝node.js時會一並安裝) 一個套件管理系統 能透過命令列安裝套件 安裝git 版本控管工具 做為本地端工具與github連結 github 一個線上的版本控管工具 其附加功能使其能成為http伺服器其Repo需命名為”ACCOUNT_NAME.github.io” #安裝hexo命令列工具npm install -g hexo-cli#在該目錄建立blog目錄hexo init blog#安裝node.js環境cd blognpm install#發佈到github的工具npm install hexo-deployer-git --save#使網頁能即時自動更新的工具(會造成一些問題 1.網頁空白 2.搜尋失效)(查問題時最好移除)npm install hexo-browsersync --save#下載慣用的blog主題佈局(NexT)git clone https://github.com/iissnan/hexo-theme-next themes/next#站內搜尋工具 (:category開頭會無法連結)npm install hexo-generator-searchdb --save 常規操作#新增文章hexo new "My New Post"#啟動本地端serverhexo server#產生文件hexo g --watch#上傳到githubhexo d 站內連結若用相對連結在首頁跟文章內顯示的連結路徑不同 語法測試12345 1 2 測試 測試 測試 AB aaa bbb]]></content>
      <categories>
        <category>紀錄</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
