<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[My New Post3]]></title>
    <url>%2F2018%2F04%2F02%2FMy-New-Post3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[My New Post2]]></title>
    <url>%2F2018%2F04%2F02%2FMy-New-Post2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F04%2F02%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[1234//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); JUnit 僅於本地JVM上測試 又稱單元測試(函數功能測試) 不依靠android環境 以滑鼠右鍵選單”Go To&gt;Test”快速建立test class Annotation @Test 註解一函數為 測試使用 @Test(expected = Exception.class) 使符合預期時拋出異常 @Test(timeout=100) 指定測試需在100ms內完成 @Before 註解一函數為 每個測試函數執行要先執行的函數 @After 邏輯同上 @BeforeClass @AfterClass 邏輯同上 但僅為整個class執行一次 @Mock 宣告一個假物件 @Captor 宣告一個叫用參數捕捉器(以取得叫用參數) @Spy 監視一個真物件 @Rule 修飾TestRule Matchers 比對器 類似過濾行為 能以廣義的形容區別物件 123456eqis 是某個objectisA 是某個classnotanyInthasItem Assert 斷言結果 判斷值是否符合預期 若不符合斷言即為測試失敗 12345678//斷言結果需為trueassertTrue("test failure", mockins.func() == 1);//斷言instance.func()執行回傳為1assertThat("test failure", mockins.func(), is(1)); //用Matcher判斷assertThat(mockins.getList(), not(hasItem(not_expected));//assertEquals mockito 製作假物件ref 通過製作假物件與指定其反應回傳 來驗證該假物件是否被呼叫?以何參數呼叫? 通常被測物需為真物件(因為要測試他的邏輯) 其依賴物為假物件(不著重邏輯是否正確或回傳什麼 僅著重是否被真物件正確叫用) 1234567891011121314151617181920212223242526272829303132333435//1. 產生mock物件@Mock MyClass mockIns; //不需要newMockitoAnnotations.initMocks(this); //但之後要做init使class內的@Mock生效//1. 產生mock物件LinkedList mockList = mock(LinkedList.class);LinkedList mockList = mock(LinkedList.class, Mockito.RETURNS_SMART_NULLS); //指定預設的回傳//2. 指定mock物件的反應 (此動作稱為Stubbing)when(mockList.get(0)).thenReturn("it's a mock string");when(mockList.get(1)).thenThrow(new RuntimeException());when(mockList.get(anyInt())).thenReturn("element");when(mockList.size()).thenReturn(1, 2, 3); //每次回傳都不同//doReturn, doThrow, doAnswer, doNothing, doCallRealMethoddoThrow(new RuntimeException()).when(mockList).clear();reset(mockList); //清除所有Stubbing//3. 經過某些動作操作後...即可進入驗證mockedList.add("once");//驗證1. 驗證mock物件的方法是否被呼叫(times, atLeast, atMost, atLeastOnce, never, timeout)verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); verify(mockedList).set(anyInt(), eq("element")); //用Matchers便於廣義的驗證//驗證2. 連帶驗證呼叫順序InOrder inOrder = inOrder(mockedList);inOrder.verify(mockedList).add("first");inOrder.verify(mockedList).add("second");//驗證3. 捕捉呼叫參數ArgumentCaptor&lt;String&gt; args = ArgumentCaptor.forClass(String.class);mockedList.add("John");verify(mockedList).add(args.capture()); //驗證add的叫用 同時捕捉叫用的參數assertEquals("John", args.getValue()); spy監視真物件123List list = new LinkedList();List spy = spy(list);//之後spy即類似mockito的操作 TestRule 能在測試函數前後插入動作 例如偵測測試函數的執行時間 加入TestRule時需用@Rule註解才能與JUnit掛鉤 123456789101112131415161718public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; //base : 一個能夠驅使測試函數被執行的物件 //description : 一個相關於測試函數環境的描述 return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; //即測試前 base.evaluate(); //即測試後 &#125; &#125;; &#125;&#125;@RuleMyRule rule = new MyRule() EspressoAndroid testing samples 依賴於JUnit的一個測試框架 UI測試 依靠android環境執行 針對view元件進行驗證 基本三步驟 取得view或data的互動 onView / onData 執行動作 perform 檢查驗證 check 大致動作1234//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); onView ViewInteraction onView(Matcher viewMatcher) 透過matcher取得view的控制 1234567891011121314//Matcher&lt;View&gt;allOf 合併多個matcherwithIdwithTextisDisplayed//其父view的id為R.id.recyclerViewisDescendantOfA(withId(R.id.recyclerView))//其父view為ListView.classisDescendantOfA(isAssignableFrom(ListView.class))hasDescendanthasSibling perform ViewInteraction perform(final ViewAction… viewActions) 執行動作1234567891011//ViewActionclick()LongClick()clearText()replaceText("")typeText("")closeSoftKeyboard()//專為RecyclerView設計(actionOnItem)onView(allOf(withId(R.id.recyclerView))) .perform(actionOnItem(hasDescendant(withText("title")), click())); check ViewInteraction check(final ViewAssertion viewAssert) 斷言 1234//ViewAssertionmatches(isDisplayed()) //使用view matcher來斷言doesNotExist()isChecked() 其他123pressBack() //按下返回鍵TestUtils.rotateXXX() //控制手機旋轉TestUtils.getCurrentActivity() TestUtils 一個工具類 提供靜態方法控制手機裝置 rotate / getCurrentActivity 自訂Matcher123456789101112131415161718192021//一個回傳Matcher的functionprivate Matcher&lt;View&gt; withItemText(final String itemText) &#123; return new TypeSafeMatcher&lt;View&gt;() &#123; @Override public boolean matchesSafely(View item) &#123; return allOf( //其父view為ListView.class isDescendantOfA(isAssignableFrom(ListView.class)), //且text為itemText withText(itemText) ).matches(item); &#125; @Override public void describeTo(Description description) &#123; description.appendText("is isDescendantOfA LV with text " + itemText); &#125; &#125;; &#125; LeakCanary 檢測記憶體洩漏 (針對activity生命週期)]]></content>
      <categories>
        <category>RRR</category>
      </categories>
      <tags>
        <tag>哇哈哈</tag>
        <tag>ABC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
