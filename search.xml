<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[作品]]></title>
    <url>%2Fhome%2F%2FSingle%2FArts.html</url>
    <content type="text"><![CDATA[股票程式化分析軟體官網連結 以Java實現 能夠即時編譯腳本程式用以分析或繪圖 WOVOgithub / marketplace 一個VSCode Extension LangStargithub / google play / web版本 Ionic寫的Hybrid App 後台用firebase 包含social login 過往操作可離線使用 TSNotegithub / google play native Android app]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hybrid App Architecture]]></title>
    <url>%2Fhome%2F%2FSingle%2FHybridAppArchitecture.html</url>
    <content type="text"><![CDATA[Cordova其前身稱為PhoneGap 做為JavaScript Bridge 實現JS介接Native Libraryref WebView 使用WebView意味著看到的ui元件不是native元件構建而成 而是透過webview畫出 應該也沒有寫NativeView的必要了 WebView有分原生的或Cordova的跨平台WebView Plugin大致寫法類似用xml(metadata)分別設定android與ios 並分別實作api對應的native程式(繼承CordovaPlugin) 最後實作一個js object對應該api 當app執行時plugin會被 透過WebView叫用api (之後再自行封裝成類別形式)cordova.exec(success_callback, error_callback, feature_classname, action_str, args); React NativeReact Native 航向真全端，建構雙平台 App /Native UI Components / 菜鳥窩React Native 從零到高級 只有JS Engine 沒有WebView 意味著web的ui元件實現須對應到native的ui元件上 實作比較辛苦 但執行比較快]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2FSort.html</url>
    <content type="text"><![CDATA[ref 泡沫排序 倆倆比較 將大的往後推(交換) 每一輪結束最大的一定推到最後一個(排好一個) 所以下一輪就少推一個 優化: 若其中一輪完全沒有交換 表示已經完成排序 public static void bubbleSort(final int[] nums) &#123; for (int i = nums.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; final int next = j + 1; if (nums[j] &gt; nums[next]) &#123; final int buffer = nums[j]; nums[j] = nums[next]; nums[next] = buffer; &#125; &#125; &#125;&#125;static void test1() &#123; int[] arr = new int[]&#123;3, 17, 63, 27, 9, 15, 2, 6&#125;; System.out.println(Arrays.toString(arr)); bubbleSort(arr); System.out.println(Arrays.toString(arr));&#125; 交換排序 從第一個位置開始 與之後的每個位置比較 交換出最小的 一輪比完再進行下個位置 public static void exchangeSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; final int buffer = nums[j]; nums[j] = nums[i]; nums[i] = buffer; &#125; &#125; &#125;&#125; 選擇排序 (交換排序法的優化) 如同交換排序 只是記住最小值的索引位置 於當輪結束時交換 public static void selectionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length-1; ++i) &#123; int k = i; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[k] &gt; nums[j]) &#123; k = j; &#125; &#125; if (k != i) &#123; final int buffer = nums[k]; nums[k] = nums[i]; nums[i] = buffer; &#125; &#125;&#125; 插入排序 記住第i個位置的值(tmp) (準備把tmp往左插入到正確位置)開始往左比 一路把大於tmp的值往右推 直到找小於tmp的位置 再執行下個循環 public static void insertionSort(final int[] nums) &#123; for (int i = 0; i &lt; nums.length; ++i) &#123; final int tmp = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; tmp) &#123; nums[j + 1] = nums[j--]; &#125; nums[j + 1] = tmp; &#125;&#125; 快速排序 採分治法(Divide and Conquer) 找一個中間數(pivot)將 並使其歸於正確位置(左小又大) 左右邊再各自做一次同樣的循環 public static void quickSortRecursive(final int[] nums, final int start, final int end) &#123; final int x = nums[start]; // 將start位置的值設為pivot int l = start + 1; //所以start+1是最左的元素 int r = end - 1; //end因為是length 所以要減1 while (true) &#123; //從右邊往左 找到小於pivot的位置 while (r &gt; start &amp;&amp; nums[r] &gt;= x) &#123; --r; &#125; //從左邊往右 找到大於pivot的位置 while (l &lt;= r &amp;&amp; nums[l] &lt;= x) &#123; ++l; &#125; //若l&lt;r表示尚未巡完整個array 就已需要交換 if (l &lt; r) &#123; final int buffer = nums[l]; nums[l] = nums[r]; nums[r] = buffer; &#125; else &#123; //lr巡完表示pivot的位置就在其交會點 if (r &gt; start) &#123; final int buffer = nums[r]; nums[r] = nums[start]; nums[start] = buffer; &#125; break; &#125; &#125; final int ls = start, le = r; final int rs = r + 1, re = end; final int ll = le - ls, rl = re - rs; if (ll &gt; 1) &#123; quickSortRecursive(nums, ls, le); &#125; if (rl &gt; 1) &#123; quickSortRecursive(nums, rs, re); &#125;&#125;quickSortRecursive(array, 0, array.length); 合併排序```排序======```java 排序```排序======```java 排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2Fhome%2F%2FSingle%2FGit.html</url>
    <content type="text"><![CDATA[working space : 工作區 即源碼開發的目錄 commit history(repo) : 即提交歷史紀錄區 stage(index) : 緩存區 介於工作區與歷史區之間 add進了stage之後commit才會進repo 而不是讓工作區所有檔案都進repo patch : 即commit產生的紀錄點 master : git最初預設的分支 origin : 慣用的預設的遠端別名 用來表示某一個遠端的路徑 HEAD : 指向當下所處的base patch (可以用@符號) HEAD^ : 指HEAD的前一個patch 等同HEAD~或HEAD~1 HEAD@{2} : 歷史紀錄(reflog)的指向簡寫 detached HEAD : 脫離的HEAD(斷頭) 即HEAD未處於分支的末端(git checkout HEAD^) 之後若再建新的patch將難以合併回分支 ORIG_HEAD : 當merge或rebase時會留下的一個記錄點 用於合併出錯時的返回點 參考文章git reflog 查詢# 列出設定git config -lgit config --global -l# 查訊patchgit show HEADgit log --oneline # 當下repo版本的歷史git reflog # 所有操作歷史 (不會進遠端)# 比對git diff # 比對工作區not staged的檔案git diff --cached # 比對工作區與repogit statusgit branch 程式碼還原ref還原前須注意當下工作區與緩存區是否有工作尚未commit 可以先commit或stash做暫存patch checkout 切換patch(branch) 直接影響working space/stage/repo 在任何動前 最好都先知道自己在哪個branch下作業 或直接用checkout確保一定在某個branch下可針對個別檔案還原 resetref 重置回某patch版本可針對個別檔案還原 commit流程 : 修改檔案 -&gt; add進stage -&gt; commit進reporeset流程 : (hard)還原檔案 &lt;- (mixed)stage重置回未add &lt;- (soft)repo重置回某版本 將HEAD移到某patch(即變更repo的版本) 且之後的patch將於數十天後被GC刪除 reset的所有操作都被記錄在reflog中 最算reset沒有起任何作用 最好只在私有的本地分支進行 不要影響到遠端及其他開發者的base 模式 soft : 保留當下的stage與working space mixed(預設) : 保留當下的working space 但stage退回(如同未add) hard : 完全重置 revert 將某個patch逆向重做後當成一個新的patch 如同撤銷某個patch 雖會多一個patch但不會影響既有的history 暫存patch當工作到一半若要切換到其他patch或branch 但又不想commit當下的修改時 可以此法暫存之後再取回 stash 將工作區與緩存區暫存起來 再硬重置回HEADpop動作如同cherry-pick也會有conflict 所以要先回到正確的patch再popgit stash # 暫存git stash save "mywork" # 給定暫存訊息 git stash listgit stash pop stash@&#123;1&#125; # pop出來後就移出list了 合併ref首先要切到要進行合併的分支 cherry-pick 將其他分支中想要的patch複製成新的patch加到當下分支 rebase 將該分支的起點(交叉點)換到新的patch或branch (以cherry-pick實現)達人推薦的合併方式 merge –no-ff 將兩個分支合併產生一個merge patch被併的分支仍能保留末端節點 Fast-Forward指合併的兩個分支原本就重疊在一起 此時合併不需產生merge patch (就看不出分支的起點了) # rebase或merge出錯時 可以此返回合併前狀態git reset --hard ORIG_HEAD 解衝突ref # 完成解衝突git cherry-pick --continue# 取消pickgit cherry-pick --abort 同步遠端分支要push前或每日工作前先pull確保本地端base與遠端相同 一方面及時察覺新版本的變動 二方面確保push時順利 fetch 下載 pull 下載並merge pull –rebase 下載並以rebase合併]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2Fhome%2F%2FJava%2FLock.html</url>
    <content type="text"><![CDATA[ref 同步與異步同步二字在生活上通常都解釋成同時進行/亦步亦趨 但程式上不是這樣觀念 異步 : 各自行動 互不等待 (記住異步的定義) 同步 : 行動須受牽制 等待 使一致 比喻 異步 : 像是短跑比賽 參賽者各跑各的 同步 : 像是跑接力賽 沒拿到接力棒就只能等待 (執行上依賴共享的資源) 用途 異步 : 增進執行效率 多執行緒 : 使用共享資源時還是要進入同步 單執行緒 : 任務寫在Event Callback/Hook 由Event Loop驅動 仿效異步 (如JavaScript) 同步 : 保護共享資源的必要手段 異步執行 指耗時任務交付後就可以先去做別的事情 等任務執行完再通知此任務稱為異步任務 不會馬上被執行架構為事件處理型(onEvent)的設計異步任務(Runnable)可以用thread或handler達成 同步執行 指事情必須依序處理 未完成前不能離開例如從網路取得一張圖片 顯示在螢幕上 若下載圖片要10秒鐘 程式就必須等待完成後才能繼續執行程式的基礎都是建立在同步執行上的 而多執行緒中的同步更強調的是只有一個執行緒在執行該段程式執行緒競爭要達到同步的代價就是等 等的實踐就是鎖 鎖的用途就是保護 對於鎖或與執行緒同步相關的實踐: synchronized lock blocking queue semaphore 需要等待的情境 等待共享資源 (用同步鎖解決) 等待異步任務(一個或多個)結果 (Thread.join或更高階的手段) 鎖 臨界區(critical section) : 即被鎖住的區塊 可重入性(reentrant) : 指thread可以重入相同的鎖中 即在funcA中又進入funcB 線程飢餓與公平(Starvation and Fairness) : 指線程搶不到開鎖機會的狀況 Busy Wait : 指while loop的等待方式 造成cpu持續忙碌而無法有效利用 synchronized 以某個物件(實例或類)做為鎖 多個thread中僅能一個thread取得鎖 也就是執行權 確保僅有一個thread進入critical section 確保從main memory讀入 離開時寫回 thread間取得鎖的結果是不公平的 有優先權的 而不是先到先贏 class Test&#123; //實例鎖 public synchronized void funcA()&#123; &#125; public synchronized void funcB()&#123; &#125; //類鎖 public static synchronized void func()&#123; &#125; static obj... public void func()&#123; //實例鎖 synchronized(this)&#123; &#125; //類鎖 synchronized(obj)&#123; &#125; &#125;&#125; 線程間能被安全共用的實例public class MyData&#123; protected Object data = false; public synchronized Object get()&#123; return data; &#125; public synchronized void set(Object data)&#123; this.data = data; &#125;&#125; 信號機制 每個Object都能做為MonitorObject wait : 使當下thread進入等待 並監視MonitorObject的信號 notify : 喚醒監視MonitorObject的thread (由系統決定喚起的thread) notifyAll : 喚醒全部監視的thread 重新競爭鎖 Missed Signals : 指notify前沒有相應的wait先被執行 而可能造成之後的wait無人喚醒 算是設計錯誤 以信號機制實現鎖public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; //isLocked為false時 進入wait循環 thread被鎖住 等待另一個thread開鎖 //若同一個thread未unlock又來lock第二次 同樣會被鎖死 造成沒有thread能解鎖 while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false; notify(); //相當於觸發信號 &#125;&#125;public class Counter&#123; private Lock lock = new Lock(); private int count = 0; public int inc()&#123; lock.lock(); int newCount = ++count; lock.unlock(); //若臨界區會拋出異常 需使用catch finally return newCount; &#125;&#125; wait如同sleep 但從wait中醒來並不是一定要有notify 它僅是告知已經可以從wait中喚醒 這種不是經由notify喚醒的情形稱作虛假喚醒(spurious wakeup) 故wait與notify之外仍需要isLocked做為是否unlock的判斷 這種while建構的鎖稱為自旋鎖 實現可重入性要考慮: 記住是由哪個thread上鎖 且上鎖幾次 解鎖必須counter歸零 Slipped Conditions 即指while(isLocked)與isLocked=true非一氣呵成(原子操作) 執行的間隙造成鎖的狀態改變 FairLock 透過List將記住請求鎖的順序 Semaphore 計數信號 實作上首先要確保操作的原子性當資源量為1時 可當鎖用 SEM_VALUE_MAX 資源量 P take/wait 減1操作 取得資源 V release/signal 加1操作 歸還資源 BlockingQueue 阻塞隊列 當take時沒有元素 或put時沒有空間時阻塞線程]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMM (Java Memory Model)]]></title>
    <url>%2Fhome%2F%2FJava%2FJMM.html</url>
    <content type="text"><![CDATA[*ref ref ref JMM (Java Memory Model) JVM執行區分 主內存(共享內存) 與 本地內存 Main : 主記憶體 (heap) Local : 各個thread獨立使用 (cache/副本) thread執行時會將需要的內容從main複製到local 之後操作各自的local memory, thread彼此間是無法得知其他thread操作的結果 除非重新同步main的資料 local從main讀寫資料應該是視為synchronized或有cpu確保同步 String str = new String("hello");//str為一參考 會放在stack//new String會放到heap//hello是字面值會放到靜態儲存區(應該也是heap) 可見性(visibility) 指A修改變數x時 確保B能夠隨時得到最新的值 (即cache失效)Java透過volatile將變數宣告為易變的/易揮發的 以提示其需要可見性的維護 (但並沒有原子性保護) x = 0;AB兩thread同時執行+3與+5,預期得到8volatile x = 0;A(x=x+3) : 0+3=3 將3指定給xB(x=x+5) : 0+5=5 此時x變為3,但運算已結束 將5指定給x 最後卻得到5,這是因為x=x+5的動作並不屬於原子操作,x+5與x=?是分別執行的,中間可以穿插,所以volatile不一定能確保變數一定是thread-safe的故volatile一般都用在狀態或旗標變數上 原子操作 (atomic)原子是最小無法分割之物 用來形容操作是不能分割的 以完成i++為例 分別需要取值/運算/賦值 假若期間無法插入任何與i相關的操作 就可以確保i的正確性 範例volatile int x = 0;volatile int y = 0;AtomicInteger a = new AtomicInteger(0);for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; x = x + 1; a.addAndGet(1); synchronized (Thread.class)&#123; y = y + 1; &#125; &#125; System.out.println("ans x : " + x); //405949 &lt;- 錯的 System.out.println("ans y : " + y); //500000 System.out.println("ans a : " + a); //500000 &#125; &#125;).start();&#125; CAS compareAndSet(expected, new) atomic檢查主入內存與expected是否相同,若相同表示可以賦值為new 否則回傳false 猜測應該是用在鎖的應用上 類似CountDownLatch 但不會阻塞 atomicI = new AtomicInteger(0);private void safeCount() &#123; for (;;) &#123; runCount++; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) break; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection]]></title>
    <url>%2Fhome%2F%2FJava%2FCollection.html</url>
    <content type="text"><![CDATA[ref ref 類型 Collection 一無序物件群體的介面 Set 一無序物件群體 元素無法重複(會覆蓋) 沒有索引沒有get方法 因爲沒有key的概念 僅存放value(或稱element) 用iterator遍歷HashSet為常用的實現 或可排序的TreeSet List 一有序物件群體 元素可重複 有數字索引 能get(idx) Map 鍵值對 (Key-Value pair) (entrySet) 結論 要數字索引 : List (ArrayList) (CopyOnWriteArrayList) 有Key-Value關聯 : Map (HashMap/LinkedHashMap) (ConcurrentHashMap) 單存放置一群物件 : Set (HashSet) 要隨時排序 : TreeMap 基本上如此 但技術演變很快 類別也會出現變形 concurrent(指多thread能夠同時存取) 意味 thread-safe 遍歷HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();//keysetfor (Object k : map.keySet())&#123; System.out.print(k + " ");&#125;//entrysetfor (Map.Entry entry : map.entrySet()) &#123; System.out.print(entry.getKey() + " ");&#125;//iteratorIterator entries = map.entrySet().iterator();while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry)entries.next(); System.out.print(entry.getKey() + " ");&#125; 測試發現 : HashMap與Hashtable 遍歷時都是沒有規律的 實現類實現解說 HashMap (ConcurrentHashMap) 以hashcode為key (null也有其hashcode)速度快,遍歷時無序的(非照put時機或key值排列)非thread-safe, multi-thread資料可能異常,但有ConcurrentHashMap可以替代,或Collections.synchronizeMap(map)使其thread-safe需要預留較大的array空間(對應每個hashCode) 資料量不多時划不來以一個hash值為索引的array其每個元素對應到一個list 當list長度超過8則改為紅黑樹(自平衡二元樹) Hashtable thread-safe, 慢繼承Dictionary較早的技術 建議用HashMap取代 LinkedHashMap (小資料量的通常的選項) 繼承HashMap (應該是以雙向鏈取代固定size的array)遍歷時是依照put順序的較慢 但啟動較省空間 在資料不多時 不見得比較慢 EnumMap 以enum為鍵 意即使用時就已知最大容量 通常會較快 TreeMap 實做SortMap介面遍歷預設依照key值的升序排序 可以自訂Comparator WeakHashMap 弱參考 可做自動回收的快取 HashSet 以HashMap實現即以Object的hashCode為key 本身為值 故同樣的hashCode無法對應兩個值 即不會重複 map.put(key, new WeakReference(value)) Arraysint[] ints = new int[10];Integer[] ints2 = new Integer[10];List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); 固定長度 可放原生類型透過java.util.Arrays工具類延伸操作 ArrayList 元素為連續排列 但能動態調整大小(會預留空間) 從刪除或插入會造成比較大的開銷get/set能透過索引算出 快add/remove需要移動整個右邊元素 慢 LinkedList 以雙向鏈(node)實現Listget/set需透過node遍歷 慢add/remove直接調整左右節點即可 快 (節點不在最前最後時要先遍歷找到節點) Iterator (迭代器)用於遍歷Set與List元素 類似一個for loop (Map的遍歷透過其EntrySet) ListIterator : 可雙向 fail-fast : 操作集合會累加modCount以示集合出現更動 若迭代時出現更動會拋出異常java.util.ConcurrentModificationException 算是一種偵錯機制 fail-safe : 迭代時複製一分參考清單 該清單無人能更動 自然就能確保迭代期間是完整的 但期間若真有異動也無法即時反應 Stream (流)類似以loop方式每次推送一個元素到function中操作 透過各式操作符一層一層完成以往for loop的工作 parallelStream : 以並行(切割任務)方式處理流 同步Map map = Collections.synchronizedMap(new HashMap()); JDK集合實現List//Single-threadedArrayList – 基於數組的泛型LinkedList – 請勿使用Vector – 已棄用//ConcurrentCopyOnWriteArrayList – 極少更新，常用於遍歷 Maps//Single-threadedHashMap – 泛型映射EnumMap – 枚舉鍵Hashtable – 已棄用IdentityHashMap – 用== 對比的鍵LinkedHashMap – 保持插入次序TreeMap – 有序鍵WeakHashMap – 有益於緩存//ConcurrentConcurrentHashMap – 泛型並發映射ConcurrentSkipListMap – 有序並發映射 Sets//Single-threadedHashSet – 泛型集合EnumSet – 枚舉集合BitSet – bits/dense 整型集合LinkedHashSet – 保持插入次序TreeSet – 有序集合//ConcurrentConcurrentSkipListSet – 有序並發集合CopyOnWriteArraySet – 極少更新，常用於遍歷 Queues / deques (隊列/雙隊列)//Single-threadedArrayDeque – 基於數組的泛型Stack – 已棄用PriorityQueue – 有序檢索操作//ConcurrentArrayBlockingQueue – 有界阻塞隊列ConcurrentLinkedDeque / ConcurrentLinkedQueue – 無界鍊式隊列(CAS)DelayQueue – 由延遲元素構成的隊列LinkedBlockingDeque / LinkedBlockingQueue – 可選有界鍊式隊列(locks)LinkedTransferQueue – 可傳輸元素且不進行存儲PriorityBlockingQueue – 並發PriorityQueueSynchronousQueue – Queue 接口的交換器]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 增訂]]></title>
    <url>%2Fhome%2F%2FJava%2FJava8Explained.html</url>
    <content type="text"><![CDATA[Lambda 箭頭函數lambda是一個java8開始的新語法 類似於javascript的箭頭函數 因應functional programming而生 可以將箭頭函數想像成一個”只有一個method的object” 就會比較容易理解 看/用起來像function但其實是一個object 因為只有一個method所以method的name就不重要了 object即等同method 為什麼要這樣?因為java的method不能像變數一樣當作參數 要傳函數勢必只能整個object傳入 而箭頭函數就是為了解決這樣的困擾 Runnable runnbale = new Runnable() &#123; public void run() &#123; System.out.println("run me!"); &#125; public Runnable get()&#123; //將現有的method當作箭頭函數般回傳 return this::run; &#125;&#125;;//箭頭函數的形式Runnable runnbale = () -&gt; System.out.println("run me!"); Collection走訪functional programming的另一個重點就是function chain與Collection(list/map/array)的走訪. 搭配Collection的stream() //透過stream()衍生function chainlist.stream().filter(s -&gt; Integer.valueOf(s) &lt; 3).forEach(s -&gt; System.out.print(s));//parallelStream() : 平行處理的stream Lambda 以函數為參數//格式Function&lt;input, output&gt;Consumer&lt;input, void&gt;Predication&lt;input, boolean&gt;Supplier&lt;output&gt; static test(int x, Function&lt;int, string&gt; fun)&#123; f.apply(x);&#125;test(99, (int x) -&gt; &#123;return "99"&#125;); Interface擴展interface的method可前綴default與static的關鍵字 用以擴展interface的method Optionallink Optional是一個新的類別 用於封裝一個傳入或回傳值 並提供一些良好的方法 讓programer養成良好的習慣 Data/Time方面的新類別]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhome%2F%2FJava%2F%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[*post 定義//Lev 1class Food&#123;&#125;//Lev 2class Fruit extends Food&#123; int weight;&#125;//Lev 3class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125; T //(或其他字母)T為一泛型可用以表示某一特定類別class List&lt;T&gt;&#123; T e&#125;List類別中有一特定類別為E區間:子類 &lt;- extends T super -&gt; 父類 -&gt; Object 泛型Class設計- T指是某一確切的類別 例如T為Fruit 並且可以多型轉換接受Apple或Banana- List&lt;T&gt;同上 但無法多型轉換 因為List&lt;Fruit&gt;並不能轉為List&lt;Apple&gt;- List&lt;? extends T&gt;是一個不確切的型別 兼容其子類 List&lt;Fruit&gt;與List&lt;Apple&gt;- super與extends雷同 兼容其父類 只是需求比較少見 - 例如要傳入一個比較器 希望設計這個比較器時能被通用 - 會寫成class Comparator&lt;Furit&gt;&#123;&#125;而不是替每種fruit分開寫 - 接收比較器的介面就需讓父類能傳入 如不管T是Fruit或Apple或Banana都能用 class MyList&lt;T&gt;&#123; //在MyList中根本不會知道E將會是什麼 ArrayList&lt;T&gt; list = new ArrayList(); //Fruit的子類都能傳入 void add(E e)&#123; &#125; //只能傳入ArrayList&lt;Fruit&gt; void addFromList1(ArrayList&lt;T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之子類 void addFromList2(ArrayList&lt;? extends T&gt; list_)&#123; list.addAll(list_); &#125; //能傳入Comparator&lt;T&gt;與E之父類 void sort(Comparator&lt;? super T&gt; c) &#123; &#125;&#125; E被指定為?的副作用因為編譯時還不知道E是什麼,所以不能確定其子類或父類 Food food = null;Fruit fruit = null;Apple apple = null;Object obj = null; //? extendsArrayList&lt;? extends Fruit&gt; fruitlist_ex = null;fruitlist_ex.add(food); // X : 任何型別都不能傳入fruitlist_ex.add(fruit); // Xfruitlist_ex.add(apple); // X/*原因 :假若fruitlist_ex = new ArrayList&lt;Apple&gt;();此時fruitlist_ex.add(new Banana())若被允許表示T同時代表了具體的Apple(建構時)與Banana(函數呼叫時),這將使後續的操作難以預料故無論輸入什麼類都一律拒絕,以保封裝後的安全*/food = fruitlist_ex.get(0); // 回傳上限型別(Fruit),很合理,後續自己轉成子類 //? superArrayList&lt;? super Fruit&gt; fruitlist_su = null;fruitlist_su.add(fruit); // 可以傳入合理型別fruitlist_su.add(apple);/*原因 : 因為下限就是Fruit,不能fruitlist_su = new ArrayList&lt;Apple&gt;();所以T無論如何至少都是Fruit容器,放fruit/apple/banana都能符合T*/food = fruitlist_su.get(0); // X : 無法傳出合理型別obj = fruitlist_su.get(0); // 只能回傳Object型別/*原因 : 上線型別是Object故唯有傳Object能涵蓋所有可能型別*/ 即使你很確定轉型不會造成操作失敗,但編譯器仍會阻止你,因為至少在編譯器這一關需確保泛型所有可能性的安全,以提供語法上邏輯的正確. 簡記 extends 與其子類 僅能用於 輸出參數 out getter super 與其父類 僅能用於 輸入參數 in setter]]></content>
  </entry>
  <entry>
    <title><![CDATA[Singleton]]></title>
    <url>%2Fhome%2F%2FJava%2FSingleton.html</url>
    <content type="text"><![CDATA[video 建立的兩個需求: thread safe lazy Plainclass MySingale&#123; private MySingale()&#123;&#125; public static MySingale instance = new MySingale();&#125; //kotlinobject MySingale&#123;&#125; Lazy (not thread safe)class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; val instance by lazy(LazyThreadSafetyMode.NONE)&#123; MySingale() &#125; &#125;&#125; Lazy (thread safe)(synchronized) 加synchronized class MySingale&#123; private MySingale()&#123;&#125; private static MySingale instance; public static synchronized MySingale getInstance()&#123; if (instance == null) instance = new MySingale(); return instance; &#125;&#125; //kotlinclass MySingale&#123; companion object&#123; private var instance: MySingale? = null @Synchronized fun getInstance(): MySingale&#123; if (instance == null) instance = MySingale() return instance &#125; &#125;&#125; Lazy (thread safe) (volatile) 加volatile : 確保不同thread中能立即察覺變數的更動 class MySingale&#123; private MySingale()&#123;&#125; private static volatile MySingale instance; public static MySingale getInstance()&#123; if (instance == null)&#123; //避免持續進入synchronized synchronized (MySingale.class)&#123; if (instance == null)&#123; instance = new MySingale(); &#125; &#125; &#125; return instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; val instance by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; MySingale() &#125; &#125;&#125; 透過Holder (靜態內部類) 透過static Holder達到lazy new操作在java中原本也就是thread safe class MySingale&#123; private MySingale()&#123;&#125; private static class Holder&#123; static MySingale instance = new MySingale(); &#125; public static MySingale getInstance()&#123; return Holder.instance; &#125;&#125; //kotlinobject MySingale&#123; companion object&#123; fun getInstance() = Holder.instance &#125; companion Holder&#123; val instance = MySingale() &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2Fhome%2F%2FJava%2FJava.html</url>
    <content type="text"><![CDATA[面試題 field修飾字 同package 子類 其他package public ✅ ✅ ✅ protected ✅ ✅ × default ✅ × × private × × × 引用 強引用(Strong) 強行使物件無法被回收 軟引用(Soft) 不置於立即回收 做cache時很適合 弱應用(Weak) 同軟引用 但更容易會被回收 虛引用(Phantom) 該回收就回收 可用於檢查物件的回收與否 person = new Person("john", 10);ref = new SoftReference&lt;Person&gt;(person);Person p = ref.get(); String透過純字面建立的string會在靜態緩衝裡建立快取 所以同樣的字串會對應到同樣的位置 但透過new String則一定是一個全新的指向s1 = "123";s2 = "12" + "3";s3 = "12" + new String("3");s4 = new String("123");// 其中只有s1==s2 StringBuffer / StringBuilder StringBuffer : thread-safe 較慢 StringBuilder : not thread-safe 較快 builder類通常宣告於method內做local變數 沒有共用的問題 也就不需要thread-safe interface / abstract interface 一個interface可繼承(extends)另一個interface 一個class可實作(implements)多個interface 可有member field 但強制成為static final method上加註default或static建立具體method (java8開始) abstract 無異於一個具體類(concrete class) 但無法實例化 且有抽象方法 一個class僅能繼承一個abstract class IOC / DI 控制反轉(Inversion of Control) 等同依賴注入(Dependency Injection)即指建立一物件時 其依賴並非由建立者或建立物來建立提供 而由一專屬框架負責 InputStream / OutputStream 流操作分兩類 byte/character byte : 以InputStream / OutputStream結尾 character : 以Reader / Writter結尾 以InputStreamReader為例 前綴InputStream表示輸入為byte 後綴Reader表示輸出character Proxy 代理 即中間人 透過中間人與物件互動 中間人即可提供一些額外的功能 RealSubject 被代理的物件(委託對象) ProxySubject 代理對象 Subject RealSubject與ProxySubject共同的介面 假設有一個request方法 靜態代理 : 就僅是將RealSubject包到ProxySubject裡new ProxySubject(real); 動態代理 : 透過反射 class ProxyHandler implements InvocationHandler&#123; private Subject subject; public ProxyHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = method.invoke(subject, args); return result; &#125;&#125;//建立一個該subject的handler 處理對應的invokehandler = new ProxyHandler(real);//建立ProxySubject 給予其該有的介面與handler 會動態產生一個classproxy = (Subject)Proxy.newProxyInstance( RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler);proxy.request(); Annotationref類似metadata 提供訊息用以描述內容 例如某個method是override的 用途 編譯檢查 如 @Override,@SuppressWarnings,@Deprecated 執行期間以反射取得某物件的Annotation 以提供相應的處理 編譯時搭配額外編譯工具提供自動產生代碼 如Dagger/JavaDoc @Retention(RetentionPolicy.RUNTIME) //使其能在runtime時保留 供反射使用@Target(METHOD.TYPE) //能被用在method上public @interface MyAnnotation &#123; String value() default "test"; //宣告需要一個字串變數&#125;public class TheClass &#123; @MyAnnotation("unit test") public void doSomething() &#123; &#125;&#125;//透過反射取得其AnnotationMethod method = TheClass.class.getMethod("doSomething"); Annotation[] annotations = method.getDeclaredAnnotations();Annotation annotation = method.getAnnotation(MyAnnotation.class); 捕捉 UncaughtException從Thread捕捉所有未能從try catch中捕捉的意外 替即將掛掉的程式安插一些處理方式 class ExceptionHandler implements Thread.UncaughtExceptionHandler&#123; @Override public void uncaughtException(Thread t, Throwable e) &#123;...&#125;&#125;Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler()); 內部類class AllInnerClass&#123; //內部類 (嵌套類) class InnerClass&#123; &#125; //靜態內部類 static class StaticInnerClass&#123; static Object obj = new Object(); //靜態成員的初始化 1.懶初始化 2.保證thread-safe &#125; public Object getTaske()&#123; //局部類 class LocalClass extends Object&#123; &#125; return new LocalClass(); &#125; //匿名內部類 Runnable anonymousInnerClassObject = new Runnable()&#123; @Override public void run() &#123;&#125; &#125;; //Lambda Runnable runnbale = () -&gt; System.out.println("running~");&#125; HTTPHttpURLConnection 較低階 HttpClient 較高階 以HttpGet或HttpPost做為請求對像 HttpClient client = new DefaultHttpClient(); HttpGet request = new HttpGet("http://tw.yahoo.com"); HttpResponse response = client.execute(request); HttpEntity entity = response.getEntity(); InputStream input = entity.getContent();]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2Fhome%2F%2FSingle%2FKotlin.html</url>
    <content type="text"><![CDATA[官方文件 簡介 介於Java與Scala之間 困擾 因為setter與getter緣故 難以區別’賦值’與’叫用’ 看不出in func的移轉 ()裡是什麼? 前綴是class : 建構成員參數宣告 前綴是fun : 函數參數宣告 {} 裡是什麼? 前綴是class : class宣告 前綴是fun : fun宣告 匿名函數 lambda 描述 不用分號結尾 一個檔案可多個類別 預設類別名稱 FilenameKt 沒有Primitive類型 全是Object (所以Java要存取都須透過getter/setter) 沒有static關鍵字 @JvmStatic @JvmField 方便對映回java對應 關鍵字 internal : 不允許外部訪問 (修飾class對java無效;但修飾fun會造成java無法access) Annotation @JvmOverloads //使fun多載(默認參數) @Synchronized @Volatile @JvmSuppressWildcards 避免Any轉成Java的? package 不宣告即為預設的package 檔案路徑不須對應package import 可以引入function 變數 前面一定要val或var val : 不可變(final) var : 可變 lateinit : 告訴編譯器稍晚會init不要報錯 但若沒有init執行時仍會丟異常 var 變數名稱: 型態 ＝ 初始值var x : Int = 1var x = 1 //自動推定var age_:Int? = nullx as String //轉型 (不需要再傳給變數)x.trim() Int String Unit : 相當於void Any : 類似Object 但不能是null IntArray / intArrayOf(1,2,3) vararg : 相當於Java接收參數String args…, 用*vararg能將其轉回陣列與java互用 Null 變數預設不能為null 型別後加?才能為null 安全調用 obj?.getNum()?:-1 空斷言!! 當null時報出exception (表示上:在變數後加!提示該變數是nullable) var x: Any //允許,但後續仍會被要求initvar x: Any? = nullfun getLength(s:String?):Int = s.length //編譯器不會過fun getLength(s:String?):Int = s?.length?:0fun getLength(s:String?):String = s!! function open : 可複寫 寫在最外層會變成 FilenameKt的靜態method open fun myfunc(x: Int, s: String) : Int&#123;&#125;//單行回傳fun getAge() = age 匿名函數 不允許冠return 最後一行的變數或結果自動當作回傳 fun myfunc(type: Int, func: () -&gt; Int)&#123; println(func())&#125;myfunc(1,&#123;7&#125;) //熟悉的寫法myfunc(1)&#123;8&#125; //較難理解的寫法myfunc(func = &#123;9&#125;, type = 1) //指定參數位置fun myfunc(func: () -&gt; Int)&#123; println(func())&#125;myfunc&#123;10&#125; //很難理解的寫法 SAM conversion//前面沒有fun關鍵字 後面接&#123;&#125;就是傳入匿名參數 懶加載 by lazy被用到時才初始化 val xy:Int by lazy &#123; val x=1 val y=5 x+y //最後一行即為匿名函數的回傳&#125; 具名函數 有回傳須指定型態 且要冠return fun func1():Int &#123;return 1&#125; //指名為func1fun func2() &#123;2&#125; //指名為func2fun func3() = &#123;3&#125; // &#123;3&#125;為匿名函數(lambda) 指定給func3作為回傳fun func5() = 5println("func1 ? " + func1()) //1println("func2 ? " + func2()) //kotlin.Unitprintln("func3 ? " + func3()) //Function0&lt;java.lang.Integer&gt;println("func3' ? " + func3()()) //3println("func4 ? " + &#123;4&#125;()) //4println("func5 ? " + func5) //5 //程式進入點func main(args:Array&lt;String&gt;)&#123;&#125; string templateval x = 1println("x = $x");println("x+1 = $&#123;x+1&#125;"); if-elseval max = if (x &gt; y) x else y when if 也可以回傳值 後面接的是lambda val x = 1var y:Intwhen (x) &#123; 1, 2 -&gt; y = 1 in 20..30 -&gt; y = 1 else -&gt; y = -1&#125;//SmartCast 可回傳var v = when (obj) &#123; is String -&gt; Integer.parseInt(obj) is Number -&gt; obj.toInt() + 5 else -&gt; -1&#125; forfor (i: Int in 1..5 step 2) &#123; print(y)&#125;//135for (i: Int in 5 downTo 1) print(i)//54321 lambda it : 預設第一個引數 val ia: IntArray = intArrayOf(120, 30, 15, 27, 66)ia.filter &#123; it &gt; 50 &#125; // 留下大於50的元素 .sortedBy &#123; it &#125; // 依照大小排序 .map &#123; it / 10 &#125; // 元素值除以10 .forEach &#123; print("$it-") &#125; // 顯示元素值 // 顯示： 6-12- class open : 可被繼承 close : inner : 預設的inner class是static的(與java相反), 要成為member class需加inner open class Person(var name: String) &#123; // 首要建構子的參數列 (有寫就一定要call)//參數列宣告有加var或val才能被外面存取//首要(primary)建構子 (有寫就一定要call) init&#123; &#125;//geter / setter var age:Int get() = age // java用.getAge() kotlin仍用.age set(value) &#123;age=value&#125; //這樣寫會recursive,要用field取代age set(value) &#123;field=value&#125;// 其它建構式，使用this(name)呼叫主要建構式 constructor(name: String, , age: Int) : this(name) &#123; this.age = age &#125; fun sayHi() &#123; println("Hi, $name!") &#125;&#125;//繼承open class NewPerson(name: String) : Person(name)&#123; override fun sayHi() &#123; println("Hey, $name!") &#125;&#125;val person = Person("Jim")println(person.age)person.sayHi() object 單例(Singleton) 立即實體化 沒有建構子 靜態實例 類似java的static 但access寫法不一樣 僅能透過ClassName存取 不能透過實例存取 中間多有一個單例的名稱 無法訪問其outter class的成員 (因為是單例/靜態/不屬於物件) 可以實作介面 但不能繼承 因為沒有建構子 可以宣告在任何地方 companion只能定義在class中 且僅能有一個 類似於static interface MyInterface &#123; fun doit() &#125;object single : MyInterface&#123; override fun doit() &#123; &#125;&#125;class MyClass&#123;//static companion object&#123; //變數預設名稱為Companion var x=1 fun myStaticFunc() &#123; &#125; //java叫用MyClass.Companion.sfunc() &#125;//單例 (class外部無法access) object mySingle&#123; var x=1 fun myFunc() &#123; &#125; &#125;&#125;//外界access方式 (不能透過類別實例存取)MyClass.myStaticFuncMyClass.mySingle.x MyClass.Companion.myStaticFuncMyClass.mySingle.x 類別擴展 用途類似包裝utils工具 MyUtils.ext(person) 但更便利 Java無法使用 有block範圍限制 不同block可有各自的擴展 (預編譯要先過) 可以靜態擴展 (可擴展第三方類別) 可以動態擴展 (但離開block後就不能用了) 可以透過import 在不同的檔案類別中共用 fun Person.ext()&#123; println("are you $name ?")&#125;import com.example.myextends.extimport com.example.myextends.*//泛型fun &lt;T&gt; T.basicToString(i: Int) &#123;&#125;basicToString&lt;String&gt;(1) infix : 語法糖 便於閱讀 infix fun String?.append(s:String?) = this+svar x = "xxx" append "dddd" 泛型video*postpost ? 相當於 * (這樣說不正確) extends 相當於 out get安全 set禁止 生產者 super 相當於 in set安全 get禁止 消費者 inline : 相當於將函數程式碼坎入到caller處 比較適用於lambda型式的函數 refied : 與重新定義泛型有關 //聲明處型變interface Source&lt;out T, in E&gt; &#123; // &lt;&lt;---在這裡 fun funOut(): T //out表示僅能定義在輸出 fun funIn(t:E) //in表示僅能定義在輸入&#125;//使用處型變interface Source&lt;T&gt; &#123; fun funIn(t: Source&lt;out T&gt;) // &lt;&lt;---在這裡&#125;//泛型約束&lt;T extends String&gt; ==&gt; &lt;T : String&gt;//kotlin允許多個約束 (用where關鍵字)open class Food&#123;&#125;open class Fruit : Food()&#123;&#125;class Apple : Fruit()&#123;&#125; 不型變 指List與List是無關聯的 協變 指List是List的子類”型” (不是子類) 逆變 指List是List的子類”型” 突破java限制: //javainterface Source&lt;T&gt; &#123; public T nextT();&#125;public void demo(Source&lt;String&gt; strs)&#123; Source&lt;Object&gt; objs = strs; // 在Java中是不允许的 // 正确方式为 // Source&lt;? extends Object&gt; objs = strs;&#125; //kotlinabstract class Source&lt;out T&gt; &#123; // 使用out的话，T只能作为返回值 abstract fun nextT(): T // 不能作为传入参数，下面会报错 // abstract fun add(value: T)&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs&#125; functioninterface Function &lt;in T, out U&gt;Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt; enum 與 sealed sealed用法類似enum 但能以class或object識別 enum class Lang(val text: String)&#123; ENGLISH("Hello"), CHINESE("你好");&#125; sealed class Cmd(val text: String)&#123; class Play(val url): Cmd object Stop: Cmd&#125; 委派 Delegate field存取委派 內部用get/set實現 Delegates實作要繼承ReadWriteProperty 像是做lazy或監聽 var state:Int by Delegates.observable(0, &#123;prop, old, new -&gt; &#123; println("$old =&gt; $new")&#125;) 尾遞歸優化 避免StackOverflowError (其實就是轉為loop處理) 遞歸函數在最後呼叫稱為尾遞歸 函數前綴 tailrec Operator overloadinga == b // a.equals(b)a..b // a.rangeTo(b)a in b // a.contains(b)a[i] // a.get(i)a[i] = 9 // a.set(i, 9) 其他class MyClass&#123;&#125;Class::class.java //取得class實例 等同於Java的MyClass.class]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth]]></title>
    <url>%2Fhome%2F%2FSingle%2FOAuth.html</url>
    <content type="text"><![CDATA[youtube 意義user =&gt; client app(consumer) &lt;=&gt; server(service provider) app取得provider的service user不必向app透露帳號密碼 過程 client請求request token client將主導權導向server server向用戶詢問是否授權(導向server提供的畫面) server將主導權導向client client請求access token Signature 簽名 server透過signature驗證用戶身份 Signature = Signature Base String (AES with) secret key Signature Base String大概是由url的特徵產生 secret key僅有加密者與server知曉,故透過Signature就能讓server辨試身份 Request Token 與provider對話權的令牌 初步驗證app的權限後取得 client提供app key與signature向server請求request token Access Token 存取用戶資料授權的令牌 驗證用戶身份與同意授權項目後取得]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDagger.html</url>
    <content type="text"><![CDATA[gradle設定dependencies &#123; kapt &apos;com.google.dagger:dagger-compiler:2.5&apos; compile &apos;com.google.dagger:dagger:2.5&apos;&#125; android/kotlin注意事項@Inject/@Named 註解欄位時要加field:fragment要繼承DaggerFragment (否則從FragmemtManger取回時不會注入)activity要繼承DaggerAppCompatActivity 示例欲在MainActivity中自動注入Car實例 class Car&#123;&#125;class MainActivity()&#123; lateinit var car: Car init&#123; car = Car() //希望透過別的方式將Car注入到MainActivity的car &#125;&#125; 對象名詞定義 dependency : 依賴物 如Car client : 接收依賴者 如MainActivity 先設想一個注入器要有哪些提示才能完善 依據什麼對應D和C? 用類型,但要切確,例如不能把Object注入到String field 怎麼知道哪個field需要被注入? 用@Inject標記field 哪些類是可以拿來注入的? 用@Inject標記constructor 建構依賴時可能需要建構參數或靈活性? 用@Provides做method回傳建構好的實體 所以依賴可用@Inject標記constructor”或”直接做@Provides method回傳依賴物 同一個類但對應多個不同的子類或不同建構參數? 用@Qualifier給各自一個別名 field想宣告成界面類型要怎麼做? 用@Binds做綁定該類與其介面 注入的東西生命週期為何? 用@Scope定義 可以需要一個或多個生產依賴的工廠 稱作Module 至少要有個注射器建構這些工程吧 Component就是注射器 而Module依附在注射器裡 注射器下還有子注射器區別不同的環境 叫做SubComponent 那不就要寫很多code? 幾乎只要用interface或abstract進行描述 dagger會自動產生實做好的類別(Component/Module) 尚未驗證 依賴的可視性應該取決於注射器與子注射器的繼承關係 子能見父 但子與子間互不可見 “父可能也不能見子” (父子指的是注射器產生出的實體) 子的注射物無法override父的注射物 仍要用key 是否單例取決於scope 同名scope在不同注射器上應如同不scope 同注射器同scope間僅能有一個實體 沒指名scope表示沒此注射都用不同實體 一個依賴只能有一個scope @Singleton是一個Application層的scope 相當於global/root/最頂層 開始於一個該scope的頂層物件 該物件在產生其他依賴 這一群的依賴中 同一個Lazy只會回傳一個實體 與singleton無關 只是快取 step1 @Inject 宣告注入物 : 在注入物的Constructor標註@Inject (一種可以不在Module中宣告的方式) 使用注入物 : 在其使用處(注入處)標註@Inject (可用Lazy取得緩衝物件) @Singletonclass Car @Inject constructor() &#123;&#125;class MainActivity()&#123; lateinit var car: Car @Inject set&#125; 發現在android的dagger2, Constructor不一定需要@Inject step2 @Module Module如同依賴物的生產工廠 當有需要依賴時dagger會自己叫用這裡的fun Module可為’class一般類’或’abstract class抽象類’或’object實例’ 其中只有抽象類能用@Binds(因為code是自動產生的,僅需提供介面) 用抽象函數提供依賴 其輸入參數最終要能得到實例 (靠@Inject或@Provides) @Binds 用抽象函數提供轉型 @Binds abstract OutCls trans(InCls obj) @Provides 直接提供注入函數 回傳實例 @Moduleclass CarModule&#123; @Singleton //標示provide一個singleton實例 @Provides //標示該fun為一provide函數 fun provideCar() = Car()&#125; 一個物件要被提供給注射器 @I : 直接在該物件的constructor宣告@Inject (會自動產生依賴函數於注射器) @P : 用@Provides寫函數回傳提供 (寫在Module裡,就可以省略1) @B : 轉型需求 僅是一個輔助 1或2再加上@Binds abstract fun… step3 @Component Component稱為注入器更貼切 只需定義其介面 dagger2的builder會實作該介面 並建出前綴為Dagger的class 並用該class建立注射器實體 @Singleton //如果Module中有Singleton這裡也要有(原因可能跟@Scope綁定作用域相似)@Component(modules = arrayOf(CarModule::class)) //定義注入器能注入的Moduleinterface MainActivityComponent &#123; fun injectCar(main: MainActivity)&#125;//dagger2會自動建出DaggerMainActivityComponent並且實作injectCar() step4 實際注入 dagger2負責建立依賴 但依賴注入的時間點仍須自己處理 //方式1 自有注射器 (或繼承DaggerAppCompatActivity 他能替我們注入activity的依賴)class MainActivity&#123; lateinit var car: Car @Inject set init&#123; DaggerMainActivityComponent //dagger自己產生的class .builder() .carModule(CarModule()) //將Module提供給注入器 .build() //建立注入器實體 .injectCar(this) //替this注入依賴 (沒有lazy) &#125;&#125; //方式2 建立Android Framwork App共用的注射器 App要註冊到manifestclass App : Application() &#123; //android.app.Application val injector: AppComponent by lazy &#123; DaggerMainActivityComponent .builder() .carModule(CarModule()) .build() &#125;&#125; more1 @Qualifier 或@Named(“type”) 用來替@Inject注入處綁定@Provide fun, 解決Car能由多個provide fun產出的情形 首先要自訂Annotation @Qualifier@Documented@Retention(RUNTIME)public @interface ProvideID &#123; String value() default "";&#125;@QualifierA@Provides fun provideCarA():Car&#123;...&#125;@QualifierB@Provides fun provideCarB():Car&#123;...&#125; //kotlin中明確指出annotation作用的位置為field:@Inject@field:Named("local")lateinit var ....或@field:[Inject Named("local")]lateinit var .... 將該Annotation註釋到@Provide與@Inject的注入處即可 more2 @Scoperef 用來綁定@Provide與@Component注入器間的生命週期 讓provide產生的實例沿用直至注入器結束 一個component中僅能有一個scope 同一個component中不允許兩個同類型的’注射物類型’ (以類型的字面定義區分 無論繼承關係) 同一個scope中不會建立兩個同類型的’注射物實體’ (即局部單例) 用@I或@P方式建立依賴物(當兩個都有建立時,依賴是優先從@P方式取得) 若是依賴在注射器中是從@P方式取得 則@I的scope宣告會被忽略 故scope應該建立於provider函數上 (很容易理解 因為provider函數的回傳是我們自己實例化的 scope限制的是該函數 而不是函數的回傳) @B因為是自動產生provider函數 所以會參考@I的scope宣告 more2 @Singelton 即@Scope做出來的一個Annotaion 字面上的意思是Singelton 實際上每個scope中的每個類型都僅能有一個實體對映 若要對映多個 1.用@Qualifier區分 2.用@Binds轉成不同型別(非@Binds真正的目的) more3 @Reusable 類似@Singelton但不再需要與注入器綁定 multi-thread時可能會出現多個實例 more4 @BindsInstance 與@Component注射器的builder相關 貌似能從builder()後接上需要提供的依賴物 more5 注射器間的依賴 一個注射器的依賴來源可以是Module 也可以是另一個注射器 @Component(dependencies = MainActivityComponent.class) //依賴另一個注射器interface Activity2Component &#123; fun injectCar(aty: Activity2)&#125;Activity2Component aty2Component = Dagger Activity2Component.builder() .mainActivityComponent(mainAtyComponent) //build時需提供注射器的依賴 .build(); more6 注入器間的繼承 @SubComponent Annotation使用上如同@Component 同一個Component下的SubComponent可以有各自的scope 概念就跟類別繼承一樣]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRxJava.html</url>
    <content type="text"><![CDATA[stream的類型 cold : 如同隨選視訊 流是固定的 訂閱才送 每次送都是完整的 不論是否送過給別人 hot : 如同直播 流是不斷送出的 無法減速的 每次訂閱都只能從當下開始 沒有終點的 物件解釋//基於Obserable建立一個可訂閱對象Obserable.create( new OnSubscribe&lt;String&gt;()&#123; @Override public void subscribe(Emitter&lt;String&gt; e)&#123; //發送事件 e.onNext("new event!"); e.onComplete(); &#125; &#125;) .subscribe( //訂閱並設定接收的對象 參數列:onNext, onComplete, onError new Consumer&lt;String&gt;() &#123; @Override public void accept( String s) &#123; System.out.println(s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;); ref Obserable : 可觀察對象 除此還有多種不同類型的可觀察對象可以create OnSubscribe : 可訂閱對象 負責發送產生事件 Emitter : 相當程度代表一個訂戶(多少有連結關係) Observer : 觀察者 即訂戶 接收事件 Consumer : 一個通用的介面 帶有一個accept方法 該方法被叫用的意義與時機由外界定義 BiConsumer : 同Consumer 但accept能傳如兩個參數 upstream / downstream : 即兩個observable的相對應關係 donw=up.map(…) 大致流程(一種意象上的形容 幫助記憶) 最末端的observer開始o.subscribe(observer) 一路向上訂閱 操作符也如同一個observer+observable (向上進行訂閱 向下提供可觀察對象) 一直訂閱到最頂端的observable (到頂端前,中間的操作符也可能發射值) observer相當於會被丟到OnSubscribe.subscribe()直接被呼叫onNext/onError/onCompleted 一個observable被重複訂閱也是相同的流程 但不見得會發射一樣的值 要視observable設計與規劃而定 例如cold與hot的差別 ObservablesRxJava搭配Room observable flowable : 有backpresure策略 可控制流速 single : 只發1次(onSuccess)或0次(onError)事件 沒有其他選項 completable : 沒有事件 只有成功與否 只有onComplete與onError 常用.andThen(…)操作符再轉出其他obserable maybe : single+completable 一次性使用 : single / maybe 僅關注成敗 : completaion emmiter interface onNext(T t) 多事件型會用這個關鍵字 onSuccess(T t) 單事件型 相對應的是onError(Throwable t) observer interfaceobserver與emmiter的介面有點像是mapping 呼叫emmiter的onNext近似於observer的onNext被呼叫 onError後 onComplete應該就不會被呼叫了 Subjectref subject同時擁有observable與observer的能力. 做為observer可以直接透過subject實體餵入事件onNext(“event”) 做為observable能讓外部訂閱 算是一種整合應用 做為observer很單純 但做為observable則有很多變化 PublishSubject 沒有任何特殊機制 BehaviorSubject 訂閱時會發射預設值或最後一值 像是一個狀態變數一樣 任何時候都有值 AsyncSubject 只在onCompleted才發射值(最後一個) ReplaySubject 任何時間訂閱都從頭再發射一次 操作符 操作符回傳的都是Observable 但向操作符提供的function僅是完善操作符的一小部分 func的in/out與操作符的out是不相干的 操作符的應用 應考慮流的屬性(hot/cold) 操作符 - 結合concat一個流結束 才切到下一個流 marge多個流同時穿插 當一個流onError就全部結束 操作符 - 建立create 自訂OnSubscribe 自己提供值來發射 from 用Iterable的內容值發射 just 從參數列給值來發射 defer 產生新的observable (每次訂閱就會重新產生) Interval 值從0開始 每固定時間發射一次 timer 在一段時間之後發射0 之後就completed range 分別發射一個區間的值 repeat 將收到的值重複發射N次 操作符 - Transforming 將值變形buffer(count) 累積count個值 轉成array發射 buffer(count, skip) 累積skip個值 只取count個 轉成array發射 window(count/time) 同buffer 但包裝成Observable 可用時間做buffer map 將值個別map成新的值 ex:1 =&gt; “1” flatMap 將值個別map成以Observable產生的值 ex:1 =&gt; Observable.just(“1”) flatMapIterable 將值個別map成以Iterable產生的值 ex:1 =&gt; listOf(“1”) map說明 以上三個map操作符輸出的都是Observable\ 僅只是用不同的方式建立內容 scan 類似map的用法 但多一個acc的累加參數 (如若有設初始值,在subscribe時會先送初始值,無論上游是否有值) groupBy 依值建立GroupedObservable 返回Observable\&lt;GroupedObservable\&lt;K,T&gt;&gt; cast 轉型 操作符 - Filteringdebounce 抗反彈 收到值後需N時間後無新值才會發射 否則用新值且N重算 throttleWithTimeout (同throttleLast?) 同debounce 但N不會重算 throttleFirst 同debounce 但N不會重算 且取的是最先發生的值 sample 固定時間內取最新的一筆 時間的起點與訂閱時間有關 與資料發生時間無關 distinct 僅發射不同的 從未出現過的值 distinctUntilChanged 僅發射與前一個值不同的值 elementAt 僅發射第N個值(接收到的第N個) filter 僅發射函數返回為true的值 last / first 僅發射函數返回為true的第一或最後一個值 發射完即completed take 僅發射固定筆數 發射完即completed skip 忽略前面N筆 blocking… 將上游阻塞 待下游… 用途尚未確認 操作符 - CombiningObservable.combineLatest(O1,O2,combiner) 當O1或O2有值時透過combiner函數決定發射的值 (傳入O1,O2的最新值) (多形用法還多) join(O2,T1,T2,combiner) 將現有Observable(O1)與O2結合 T1/T2分別表示O1/O2有效的時間 兩者都在有效時間內時會呼叫combiner進行發射 joinGroup … Observable.merge 混合兩個Observable mergeWith 同merge 但沒試出結果 startWith 開頭時插入值 switch 當一個O發射多個O時 切換到最新發射的O Observable.zip(O1,O2,O3,zipper) … 將O1,O2,O3的值依序合併成新值 操作符 - 異常處理onErrorReturn 捕捉onError異常 並補一個值 之後onCompleted onErrorResume 同onErrorReturn 並補一個Observable繼續運作 OnExceptionResumeNext 針對Exception處理 retry / retryWhen onError時重試 retryWhen要注意forever loop問題 操作符 - Utilitydelay 延遲值的發射 delaySubscription 延遲訂閱的時間 doOnEach/doOnNext/doOnSubscribe/doOnUnsubscribe/doOnError/doOnCompleted/doOnTerminate/finallyDo 監聽事件 直接回傳上游Observable materialize 將事件與值封裝為Notification類型 dematerialize 將Notification解回事件與值 [ subscribeOn / observeOn ] 將個訂閱過程拆分”訂閱時期”與”觀察(遞值)時期” 訂閱時是由下往上(code的順序) 觀察時期是由上往下 subscribeOn 在訂閱時期指定thread (訂閱時期比較短 相應的函數通常只執行一次) observeOn 在觀察(遞值)時期指定thread (觀察(遞值)時期比較長 相應的函數通常反覆執行) timeInterval 發射值與前一個值之間的時間差 timeStamp 發射值發生時的時間戳 timeout 逾時未出現值則發出onError 或發出endWith+onCompleted using 有點像是建立一個與該Observable伴隨生命的物件 操作符 - Conditional and Booleanall(func) 根據func的回傳 如果至onCompleted都沒有false 就發射一個true 然後onCompleted amb(O1,O2…) 讓O1,O2…競賽 以最先有值或事件的O做為發射的來源 contains(func) onCompleted前func回true則發射true 否則發射false 然後onCompleted isEmpty (true or flase) + onCompleted defaultIfEmpty empty時發射default+onCompleted sequenceEqual(O1,O2) 用來判斷O1,O2的發射值與順序是否一模一樣 skipUntil(O2) 直到O1出現O2的pattern前都skip skipWhile(func) 直到func回傳false前的值都skip takeUntil / takeWhile … 如上類似 操作符 - 合計Aggregatecontact 合併兩個O 但第一個onCompleted才能切第二個 count 在O結束時 發射值的數量然後onCompleted reduce 壘算 直到O結束才發射 然後onCompleted (類似scan 只是scan是每次壘算都發射) collect(init,collector) 將值收集到ArrayList之類的物件 在O結束時才發射 然後onCompleted 操作符 - Connectablepublish 將O轉成需要connect才發射的型態(Connectable) 主要用意在控制多個observer時的發射時機 connect 當connect時該Connectable即已經開始訂閱上游 refCount 將Connectable轉回普通的O replay 轉為一個Connectable 並保留數個值或一段時間的值做新訂閱者的startWith (字面很像重播 但實際比較像buffer的效果) 操作符 - 自訂操作符ref compose (自定義/加工observable) Transformer 加工上游observable 再返回另一個observable 可以當成一個聚合的操作符 執行一個compose裡面藏了很多操作符 lift (自定義observer) 能插入一個Operator/Subscriber]]></content>
      <tags>
        <tag>Android</tag>
        <tag>ReactiveX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast]]></title>
    <url>%2Fhome%2F%2FAndroid%2FBroadcast.html</url>
    <content type="text"><![CDATA[Broadcast 發送或接收系統事件廣播 如低電量/簡訊生命週期在onReceive()結束後終止以靜態方式(manifest)註冊接收器 可以不用開app 也能接收事件 registerReceiver(new BroadcastReceiver()&#123;&#125;, new IntentFilter("action..."));unregisterReceiver(mybc);Intent intent = new Intent(this, MyBC.class)Intent intent = new Intent("action...")intent.putExtra("data", "mydata");sendBroiadcast(intent);class MyReceiver extends BroadcastReceiver&#123; onReceive(content, intent);&#125; 或以常駐的方式(不論app是否啟動或kill都能被執行) &lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.EDIT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Dev Log]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDevLog.html</url>
    <content type="text"><![CDATA[TextView行高在編輯文字時會改變addTextChangedListener(object:TextWatcher&#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; //每次文字更動時都在設定一次行高 setLineSpacing(0f, 1f) setLineSpacing(20f, 1f) &#125;&#125;)]]></content>
      <tags>
        <tag>Android</tag>
        <tag>開發紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRecyclerView.html</url>
    <content type="text"><![CDATA[加入RecyclerView//0. 取得viewvar view = findViewById&lt;RecyclerView&gt;(R.id.recyclerView)//1. 設定layoutval layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)view.layoutManager = layoutManager//2. 設定adapterview.adapter = MyAdapter(data)//3. 設定分隔線view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); class MyAdapter : RecyclerView.Adapter() &#123; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; //建立ItemView並存於ViewHolder回傳 &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; //將欲顯示的內容抽換到holder中的view &#125; override fun getItemCount(): Int &#123; &#125; //自訂ItemView的Holder class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2Fhome%2F%2FAndroid%2FFragment.html</url>
    <content type="text"><![CDATA[加入Fragment fragment要被砍入的位置 R.id.contentFrame fragment自身的佈局 R.layout.main_frag var fragment = supportFragmentManager.findFragmentById(R.id.contentFrame)?:MainFragment().also &#123; supportFragmentManager.beginTransaction().apply &#123; add(R.id.contentFrame, it) commit() &#125;&#125; class MainFragment : Fragment()&#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; var view = inflater?.inflate(R.layout.main_frag, container, false) return view &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2Fhome%2F%2FAndroid%2FGradle.html</url>
    <content type="text"><![CDATA[Groovy 語言特性介紹 加快編譯//gradle.propertiesorg.gradle.jvmargs=-Xmx512morg.gradle.daemon=trueorg.gradle.parallel=trueorg.gradle.configureondemand=true 異常”Gradle project sync failed”在android sample中加入kotlin一直不成功 但new project中卻沒問題 把code移入new project中確認也沒問題 可見是環境造成 rm -rf .gradle/ .idea/ build gradle 最後是把src root folder從Application改名(Refacotr)為app才正常 buildTypes 控制編譯流程 debug / release productFlavors 分歧編譯目錄 mock / prod 不同選擇即用不同目錄下的檔案編譯 flavorDimensions : 對flavor再進行一次分類 例如platform,vertype 組合出多個目錄 BuildConfig設定會透過BuildConfig類帶入java中 applicationId作用在google play store上 用以辨識app, 不同的release要有不同的applicationId, 否則會被視為同一個app 可寫在defaultConfig或個別的buildType/productFlavors中 也可用applicationIdSuffix]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE_ENV]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIDE-ENV.html</url>
    <content type="text"><![CDATA[API版本 SDK TOOL路徑cd ~/Library/Android/sdk/tools/bin/ export JAVA_HOME=`/usr/libexec/java_home -v 1.8`export SDK_HOME=/Users/jimliu/Library/Android/sdkexport ANDROID_HOME=/Users/jimliu/Library/Android/sdkexport GRADLE_HOME=/Applications/Android\ Studio.app/Contents/gradle/gradle-3.2/export PATH=$JAVA_HOME/bin:$&#123;SDK_HOME&#125;/tools/bin:$&#123;SDK_HOME&#125;/platform-tools:$GRADLE_HOME/bin:$PATH cat &gt; ~/.bash_profile貼上之後ctrl+c 添加Library Adding a Library Project Adding a Jar library 快速鍵//自動完成不分大小寫editor&gt;general&gt;code completion的case sensitive completion要調為none//自加cmd IKJL : 上下左右cmd+sft J/L : to line start/endcmd+sft I/K : extend/shrink selectioncmd p : parameter infocmd ;或z : Basic/ in Code Completion 函數自動完成 (api doc)cmd , : insert live template 插入樣板//mousecmd click : Declaration/ in Main menu Naviagte 查原始碼 (或xml)//視窗檔案切換ctrl tab//游標opt 左右 : 左右移 擴大/縮小選取sft opt : 上/下移動行sft enter : end + entercmd enter : enter + 上 (游標位置不動產生一空行)//快速產生程式碼 souf fori logi cmd j : 插入樣板cmd opt t : if / try / while//開啟燈泡內的選項opt enter//查詢物件的method/field 或任何可能的字串ctrl space : 查詢method/field (選定後按tab!!!!) 或 提示字串自動完成//建立methodcmd n : 各式選單ctrl o : select override/implement//單純查詢ctrl j : 查詢文件定義cmd p : 顯示參數定義 ****cmd b : 查原始碼 (或xml)cmd u : 跳到父類cmd opt L : 自動格式化cmd F9 : 編譯執行//搜尋內容或檔案sft sftsft F6 : 變數改名cmd + d : 複製貼上一整行 或貼上已選取的內容cmd sft a : 開啟系統功能搜索]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resource]]></title>
    <url>%2Fhome%2F%2FAndroid%2FResource.html</url>
    <content type="text"><![CDATA[資源引用出現的樣式[@|?][namespace:]type/name//type : string，dimen，drawable，layout，color，anim，animator，mipmap，raw，id，style，attr，array//@ : 引用切確資源@android:string/title //Android本身的資源@string/title //省略namespace即引用自建資源//? : 引用自主題屬性 (如果主題沒定義該屬性會報InflateException)android:background="?attr/colorPrimary"//+ : 通常是替自己建立資源設定ID時使用android:id="@+id/myViewId"//@null : 應該是一個特別的id 讓某些屬性能夠不執行android:button="@null"android:background="@null" assets與raw assets不會產生id於R資源 可有目錄結構 透過AssetManager讀取 raw屬於R資源 透過R.id讀取 AssetManager am = getAssets(); InputStream is = am.open("filename"); InputStream is = getResources().openRawResource(R.id.fileNameID);VideoView.setVideoUri(Uri.parse("android.resource://" + getpackageName() + "/" + R.raw.movie)); 多國語言只需透過IDE編輯即可 (勾選不需要翻譯的字串) Drawable 可被畫出在View上的 例如圖檔來源 from BitmapDrawable 也可從xml定義 color shape : 形狀 方圓線等 stroke 描邊 solid 填充 corners 邊角 padding selector : 狀態 每個item搭配一個狀態對應一個drawable state_pressed / state_focused / state_selected / state_checkable state_checked/ state_enabled / state_activated / state_hovered state_window_focused layer-list : 圖層 越先執行的在越底層 用很多層疊出一個drawable]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storage]]></title>
    <url>%2Fhome%2F%2FAndroid%2FStorage.html</url>
    <content type="text"><![CDATA[Storage internal與external是以app間分享的角度,external表示可被分享 無論internal或external 在app移除都會跟著移除 除非用是PublicDirectory internal /data/data/ 被連結到(/data/user/...) 一定存在 別的app不能訪問 用Context.filesDir取得 primary external /Android/data/PACKAGE_NAME 被連結到(/storage/emulated/...) 可能是內部記憶體卡的分割或外部記憶裝置(Adoptable Storage) 用Context.getExternalFilesDir取得 secondary external 外部記憶裝置 不一定存在 //Context.filesDir (/data/data的連結) /data/user/0/PACKAGENAME/files//Context.getExternalFilesDir /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures//Context.getExternalFilesDirs (Primary/Secondary) /storage/emulated/0/Android/data/PACKAGENAME/files/Pictures /storage/12E9-1105/Android/data/PACKAGENAME/files/Pictures //Environment.getExternalStorageDirectory /storage/emulated/0 //Environment.getExternalStoragePublicDirectory /storage/emulated/0/Pictures //Environment.getDataDirectory /data//Environment.getDownloadCacheDirectory /cache//Environment.getRootDirectory /system//Environment.getExternalStorageState mounted]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layout]]></title>
    <url>%2Fhome%2F%2FAndroid%2FLayout.html</url>
    <content type="text"><![CDATA[Layout view跟layout定義上的差別: view是通常形容元件 layout則是容器(容器內的排版)layout是view的子類 RelativeLayout定位於 某元件 或 所處容器 的相對位置 FrameLayout定位於左上角 (view會重疊) LinearLayout水平或垂直 接續排列 權重分佈 TableLayout格狀排列 ConstraintLayout約束排列 約束元間之間的相對關係 (取代RelativeLayout) LayoutParams.FILL_PARENT //依父容器大小 填滿父容器LayoutParams.WRAP_CONTENT //依內容大小 適當顯示 SwipeRefreshLayout有下拉Refresh功能 findViewById&lt;SwipeRefreshLayout&gt;(R.id.refresh_layout)?.apply &#123; isRefreshing = true //設定為正在refresh setColorSchemeColors( ContextCompat.getColor(activity, R.color.colorPrimary), ContextCompat.getColor(activity, R.color.colorAccent), ContextCompat.getColor(activity, R.color.colorPrimaryDark) ) setOnRefreshListener&#123; println("do refresh...") postDelayed(&#123; println("done refresh...") isRefreshing = false //設定為沒在refresh &#125;, 3000) &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArchitectureComponent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FArchitectureComponent.html</url>
    <content type="text"><![CDATA[video video LifecycleOwner : lifecycle的擁有者 像activity或fragment都是LifecycleOwner 可透過getLifecycle()取得Life LifecycleObserver : 一個介面 實作這個介面 就能透過Life.addObserver加入監聽lifecycle事件的行列 ViewModel :]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMisc.html</url>
    <content type="text"><![CDATA[Launcher 即手機home鍵看到的畫面 以及其延伸的機制 本身同樣為activity HomeScreen WorkSpace 上半部的大範圍 HotSeat 底下的熱連結 AppList (GridView) 應用 Shortcut 將app中某些功能結合user需求產生快捷 LiveFolder 類似將一個content provider封裝 AppWidget WallPaper]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Widget]]></title>
    <url>%2Fhome%2F%2FAndroid%2FWidget.html</url>
    <content type="text"><![CDATA[Widget 一個自訂的service(app)顯示且整合於WorkSpace中 整合困難的部分在於launcher與widget執行於兩個不同的process中 AppWidget 即自訂的app AppWidgetHost 一個AppWidget的宿主 負責與AppWidget交互 AppWidgetHostView AppWidgetManager AppWidgetProvider 提供view的更新 是一個BroadReceiver (即使是空的也無所謂) AppWidgetProviderInfo 提供資料的更新(mata-data) 寫code只需要AppWidgetProvider與Manifest+provider_info+layout的設定即可 RemoteViews 一個能夠對映view的投射物件(兩者都從相同的layout建立) 透過RomoteViews操作view 再將此RomoteViews丟到遠端 遠端即可知道如何更新實際的view 達到跨process的view操作]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAnimation.html</url>
    <content type="text"><![CDATA[*post animation property (透過修改view實例自動產生動畫) view animation (tween) (Alpha Rotate Scale Translate Set) drawable animation (frame by frame) 單位: 數字 : px 50% : 自己寬度的50% 50p : 容器寬度的50% //Tweenanim.setDurationanim.repeatMode // 重頭再開始 / 倒退再開始anim.fillAfter // 停在結束anim_set.add(anim)view.startAnimation(...)anim = animationUtils.loadAnimation(R.id....) // from xmlaty.overridePendingTransition() //過場動畫 //viewFlipperfilper.setInAnimation(...)filper.setOutAnimation(...) android:activityOpenEnterAnimation&lt;ViewAnimator android:inAnimation="@android:anim/slide_in_left"&gt; &lt;TextView/&gt; &lt;TextView/&gt;&lt;/ViewAnimator&gt; youtube Animation Tweened (補間動畫) alpha 淡入淡出 rotate scale translate 移動 Frame-by-Frame Property Animation (屬性動畫) Tweened與ValueAnimator的差別 Tweened僅是繪製上的調整 也就是說移動一個button 事實上只是畫到別的地方而其屬性仍保留在原處 而ValueAnimator則不斷的調整view的屬性 TweenedAlphaAnimation animate = new AlphaAnimation(1, 0);animate.setStartOffset(1000);animate.setDuration(1000);animate.setFillAfter(true); //動畫後停留在最後animate.setFillBefore(false); //動畫後回到起點animate.setRepeatCount(1);AnimationSet aset = new AnimationSet(true); //共用interpolatoraset.addAnimation(animate);imageview.startAnimation(aset); //rotate需定義旋轉的中心點,中心點可相對於自己或containarRotateAnimation animate = new RotateAnimation(0, 360 Animation.RELATIVE_TO_PARENT, 1f, Animation.RELATIVE_TO_PARENT, 0f); //scale需定義縮放的軸心,軸心可相對於自己或containarScaleAnimation animate = new ScaleAnimation(1, 0.1f, 1, 0.1f Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); //向中心點縮小 ####用xml建動畫流程建res/anim目錄,寫alpha.xml,android studio會自動產生對應的code在gen/R.java &lt;set ...&gt; &lt;alpha ... /&gt;&lt;/set&gt; Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha); Interpolator用途示範插值器 補插動畫效果 Frame-by-Frame&lt;animation-list ...&gt; &lt;item android:drawable="..." android:duration="500" /&gt;&lt;/animation-list&gt; imageview.setBackgroundResource(R.drawable.animff);AnimationDrawable ad = (AnimationDrawable)imageview.getBackground();ad = AnimationUtils.loadAnimation(this, R.anim.alpha); LayoutAnimationController控制layout group中動畫的順序 ####從java建立Animation animate = AnimationUtils.loadAnimation(this, R.anim.alpha);LayoutAnimationController lac = new LayoutAnimationController(animate);lac.setDelay(0.5f);lac.setOrder(LayoutAnimationController.ORDER_NORMAL);listview.setLayoutAnimation(lac); ####從xml導入&lt;LayoutAnimation delay="0.5" animationOrder="normal" animation="@anim/alpha"/&gt; &lt;ListView layoutAnimation ="@..."/&gt; AnimationListeneranimation.setAnimationListener(new AnimationListener()&#123; onAnimationStart() onAnimationEnd() onAnimationRepeat()&#125; ValueAnimator ValueAnimator : 類似以值的變化形容動畫 類似補差值 ObjectAnimator : 將ValueAnimator套用到Object上 ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); animator.setDuration(5000); animator.start(); //組合多個動畫ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); //在xml定義anim_file.xmlAnimator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file); animator.setTarget(view); animator.start(); Activity overridePendingTransition方法需要在startAtivity方法或者是finish方法調用之後立即執行 overridePendingTransition(R.anim.zoomin, R.anim.zoomout)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2Fhome%2F%2FJava%2FThread.html</url>
    <content type="text"><![CDATA[相關知識 program : binary code,一段機械碼或可被執行的檔案 process : 執行一個program後形成一個process,其中包含一塊記憶體空間(code/heap). process間是不共用的,互相通信需特殊的機制 thread : 實際執行程式碼的單元 包含stack與cache儲存變數與參考 task : 任務,軟體概念,如同Runnable介面 yield : 類似sleep 但不能指定時間 目的在於讓出cpu時間給同優先級的執行緒 (針對非timeslicing作業系統) Concurrency(並發) vs Parallelism(並行) 與thread數量無絕對關連 與資源共用有關資源可以指時間或執行緒或資料物件例如javascript中共享執行緒的異步執行(協程)(Promise)就屬於併發的應用 並發 : 一個資源 輪流供應多個人使用 (共用需要使用鎖)(有能力處理一起發生的事件,但未必一起執行) 並行 : 每個人有各自的資源 雖同時進行 但互不相干 Thread 其應用通常與Lock息息相關 Daemon Thread 守護線程 又稱background thread 其生命週期中斷於程式的其他thread全部結束 例如GC線程setDaemon(true) corutine 協程 由編譯技術實現 被視為輕量級thread 應該是依附在thread 用於異步執行 透過async/await讓工作不立即執行 且能夠被等待 相當於排程的概念 更有效率的使用thread 例如 : 在main thread中連續執行ABC三函數 一般情況下執行的順序是ABC 若B能進入異步 順序會變為AC…B (B不確定何時執行) 若B能進入異步 且C能等待B執行完 順序又變回ABC 假若B在異步執行時是透過其他thread 那C等待B時main thread還能繼續其他工作 async&#123; value = await getData();&#125; Thread Poolref ExecutorService 即thread pool的實現 Executor介面類 即execute() 供ExecutorService實現 Executors工具類 便於產生ExecutorService 內部有一個BlockingQueue存放任務 每個thread如同一個looper等待取得task Thread的切換一個流程中某些動作必須跳到異步執行 待執行完再切回原本的thread 這些切換thread的動作將使一個流程無法順暢的寫完 舉例: user按下執行按鈕 (ui) 下載url的內容 (network) 存成本地檔案 (i/o) 取得執行狀況 將內容顯示於ui (ui) message handler 適合簡單的切換 多個連續流程仍難以處理 範例 切換越多次巢狀越明顯 public class AppExecutors &#123; //seeu 建立Thread切換機制 private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors() &#123; diskIO = Executors.newSingleThreadExecutor(); networkIO = Executors.newFixedThreadPool(THREAD_COUNT); mainThread = new MainThreadExecutor()); &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; private static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; ForkJoinPool專處理可併行的任務 將任務(ForkJoinTask)切割執行於pool中 運用於Collection.ParallelStreams中 //ForkJoinTask大致寫法@Overrideprotected Integer compute() &#123; if(needSplit)&#123; return sum(); &#125;else&#123; int middle = (start + end) / 2; CountTask task1 = new SumTask(start, middle); CountTask task2 = new SumTask(middle+1, end); //執行分割任務 task1.fork(); task2.fork(); return task1.join() + task2.join(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Room]]></title>
    <url>%2Fhome%2F%2FAndroid%2FRoom.html</url>
    <content type="text"><![CDATA[TypeConverter 建立物件與database primitive type的轉換 data class Word( @SerializedName("naText") var naText: String, @SerializedName("taText") var taText: String)//透過TypeConverter建立object與json字串的轉換class WordConverter &#123; @TypeConverter fun word2Json(words: ArrayList&lt;Word&gt;): String &#123; val json = Gson().toJson(words) return json &#125; @TypeConverter fun json2Word(json: String): ArrayList&lt;Word&gt; &#123; val turnsType = object : TypeToken&lt;ArrayList&lt;Word&gt;&gt;() &#123;&#125;.type val list = Gson().fromJson&lt;ArrayList&lt;Word&gt;&gt;(json, turnsType) return list &#125;&#125;@Entity(foreignKeys = [ForeignKey(entity = BookInfo::class, parentColumns = ["id"], childColumns = ["bookId"], onDelete = CASCADE)])@TypeConverters(WordConverter::class) //加入需要的TypeConverterdata class BookContent(@PrimaryKey(autoGenerate = true) var id: Long, var bookId: Long, var words: ArrayList&lt;Word&gt; = ArrayList&lt;Word&gt;()) ForeignKey (外鍵) 使該table(child)與外界的table(parent)連動 例如一起被刪除 Embedded 在table中坎入其他table或pojo class 避免宣告裡必須攤平所有欄位失去結構 可作為查詢時暫用的表 實際的解析上有點像是將Embedded表的欄位名(變數名)平面化 所以各個表中的欄位名還不能重複 若重複還要加prefix將整個表的欄位名加前綴 select語句針對prefix的部分必須一一列出(太麻煩了) SELECT *, tbl_b.id as prefix_id FROM tbl_a INNER JOIN tbl_b ON tbl_a.id=tbl_b.id WHERE ... Relation 可以建立一個連動的查詢 整合到一個table中 (用起來方便但要多建一個class) @Entitydata class BookSet( @Embedded var info: BookInfo?=null,//BookContent.bookId對映BookInfo.id//查詢的結果必須是List或Set @Relation(parentColumn = "id", entityColumn = "bookId") var content: List&lt;BookContent&gt;?=null) Migration 升級]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB-MySQL]]></title>
    <url>%2Fhome%2F%2FAndroid%2FDB-MySQL.html</url>
    <content type="text"><![CDATA[SQLiteOpenHelperref public class DBHelper extends SQLiteOpenHelper &#123; public DBHelper(Context context) &#123; super(context, "mydb.db", null, 0); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("CREATE TABLE IF NOT EXISTS user(\ _id INTEGER PRIMARY KEY AUTOINCREMENT, \ name TEXT)" ); &#125;&#125;dbHelper = new DatabaseHelper(context);SQLiteDatabase db = dbHelper.getWritableDatabase();SQLiteDatabase db = dbHelper.getReadableDatabase();db.close();//insertContentValues values = new ContentValues();values.put("id", 1);values.put("name", "jim");db.insert("user", null, values);db.execSQL("insert into user (id,name) values (1,'carson')") //updatevalues.put("name", "jim2");db.update("user", values, "_id=?", new String[] &#123; "1" &#125;);db.execSQL("update [user] set name = 'jim2' where _id=1");//deletedb.delete("user", "_id=?", new String[]&#123;"1"&#125;);db.execSQL("delete from user where _id=1");//seleteCursor c = db.rawQuery("select * from user where id=?",new Stirng[]&#123;"1"&#125;);c = db.rawQuery("SELECT _id, name FROM user");c = db.query("user", new String[] &#123; "_id", "name" &#125;, "_id=?", new String[] &#123; "1" &#125;, null, null, null); Cursor//遍歷1while (c.moveToNext()) &#123; int idx = c.getColumnIndex("_id"); //取得欄位idx int id = c.getInt(idx); //取得資料&#125; //遍歷2c.moveToFirst(); while(!c.isAfterLast())&#123; //dosomething c.moveToNext(); &#125;//記得關閉c.close(); 將db檔預先置入apk 將寫好的db放到res/raw下 在開啟db前將資源寫入android檔案系統 InputStream myInput = context.getResources().openRawResource(R.raw.database);File file = context.getDatabasePath("mydb.db");if (!file.exists()) &#123; try &#123; OutputStream myOutput = new FileOutputStream(file); byte[] buffer = new byte[1024]; int length; while ((length = myInput.read(buffer))&gt;0)&#123; myOutput.write(buffer, 0, length); &#125; myOutput.close(); myInput.close(); mIsDBOK = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Task]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTask.html</url>
    <content type="text"><![CDATA[Activity.runOnUiThread activity內建的一方法 便於異步切回main thread AsyncTaskref aad : Execute a background task inside of a Service thread pool+handler應用的再封裝 易於與main(UI) thread切換 需在main thread建立與執行 (最終記得cancel) 如同Thread一次性使用 結束後無法重新啟動 class MyTask extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123;//&lt;傳入型態, 進度值型態, 結果型態&gt; @Override public Bitmap doInBackground(String ...args)&#123; //進入異步 不要做view操作 publishProgress(...); activity.runOnUiThread &#125; onPreExecute() //回main thread onProgressUpdate(Integer... values) //回main thread onPostExecute(Bitmap bitmap) //回main thread&#125;new MyTask().execute("str"); CountDownLatch// 1.設定好要count down的數量final CountDownLatch countDownLatch = new CountDownLatch(1);// 2.在異步thread結束後countDown使其歸零countDownLatch.countDown();// 3.一直等到countDownLatch為0才返回countDownLatch.await(); Timer &amp; TimerTaskTimer timer = new Timer()timer.schedule(new TimerTask() &#123; @Override public void run() &#123; //... &#125;&#125;, 1000, 1000);timer.cancel() Looper + Handler Looper消息接收器 建立時連帶建立一個MessageQueue Handler消息處理/發送器 用途在於將msg或task隊列執行 Looper與Handler內部都是利用current thread做為key 所以建立與呼叫時所處的thread很重要 //自訂的class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; //以當下thread建立looper (內部會存於map中) Looper.prepare(); //以當下thread建立Handler 並取得當下thread的looper中的MessageQueue //於是looper與handler都有共通的msgQueue //之後外部可用handler建立傳遞msg進入msgQueue //loop即能收到msg並透過msg的callback回叫handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; &#125; &#125;; //以當下thread執行loop (當下thread會進入等待msg的loop而block住) Looper.loop(); &#125;&#125; MessageQueue 內部是透過native code實現主要機制 HandlerThread 同上方範例 但沒有handler public void download2(String url) &#123; HandlerThread ht = new HandlerThread("MyHandlerThread"); ht.start();//必須先啟動thread (執行prepare後looper才會建立) //直接指定Handler的looper Handler handler = new Handler(ht.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //H:MyHandlerThread System.out.println("H:"+Thread.currentThread().getName()); if (msg.obj=="quit") getLooper().quit(); &#125; &#125;; handler.post(new Runnable()&#123; public void run()&#123; //R:MyHandlerThread System.out.println("R:"+Thread.currentThread().getName()); &#125; &#125;); handler.obtainMessage(0, "url").sendToTarget(); handler.obtainMessage(0, "quit").sendToTarget();&#125; main thread預設已執行prepare 所以在main thread下Handler能直接使用]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[壓力循環測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FMonkeyTest.html</url>
    <content type="text"><![CDATA[Android測試 adb (android debug bridge)Android SDK本地端執行程式 crash / anr(activity not responding) //列出deviceadb devices//進入手機shell (如果Permission denied可執行su)adb shell//到安裝路徑cd /data/data/com.jimliuxyz.vocabook.mock///安裝apkadb install package.apk//取得 device logadb logcat monkeyAndroid OS上的測試程式 monkey 自動壓力測試(隨機操作)//執行測試 (隨機點擊操作)adb shell monkey 100//執行100個操作 每1000ms執行一次 以50為操作seedadb shell monkey -p tw.com.langstar.t1 -v -s 50 --throttle 1000 100-v : detial info-s : seed操作種子 固定的種子能複製出同樣的操作行為--pct-touch : touch操作的百分比--ignore-crashes : crash後自動重啟再測試---//手機內存放anr的log目錄data/anr monkey 自訂測試腳本//Android SDK內建的UI元件檢視器 能查詢執行中的app/Users/jimliu/Library/Android/sdk/tools/bin/uiautomatorviewer//上傳檔案adb push myscript /data/local/tmp//執行測試 (隨機點擊操作)adb shell monkey -f /data/local/tmp/myscript 100 // 點擊DispatchPointer(downtime,eventide,press:0/release:1,x,y,pressure,size,metastate,xpresision,ypresision,device,edgeflags)DispatchPointer(10,10,0,100,100,1,1,-1,1,1,0,0)DispatchString(mystr)//manifest的activity須加exported="true"屬性LaunchActivity(package, package + ActivityName)UserWait(1000) //msDispatchPress(66) //keycode monkeyrunnerAndroid SDK本地端程式/Users/jimliu/Library/Android/sdk/tools/bin/monkeyrunner從本地端執行python控制測試流程 可抓圖 from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#MonkeyRunner.alert("msg", "title", "okText")device = MonkeyRunner.waitForConnection(3, "emulator-5554")device.startActivity("package/package.activityname")MonkeyRunner.sleep(2)device.touch(100, 100, "DOWN_AND_UP")device.type("string")device.press("KEYCODE_ENTER", "DOWN_AND_UP")image = device.takeSnapshot()image.writeToFile("./test.png", "png") monkeyrunner demo.py]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShellCmd]]></title>
    <url>%2Fhome%2FLinux%2FSingle%2FShellCmd.html</url>
    <content type="text"><![CDATA[refref # 搜尋執行檔路徑 (依環境path)which gitwhereis git# 依檔名尋找檔案find / -name gitfind grep awk# 資料夾中搜尋文件內容grep -r '導航' ~/GoogleDrive/grep -r --include="*.java" "service" .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[頁面導航]]></title>
    <url>%2Fhome%2F%2FAndroid%2FNav.html</url>
    <content type="text"><![CDATA[task back stack行為設定參考官方中文說明Android 深入ActivityAndroid基礎知識 launchMode intent flag minifest activity Deep Link(App Links) 超連結啟動apprefref aad:Implement non-standard task stack navigation (deep links) &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;!--從adb啟動--&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!--從browser啟動--&gt; &lt;data android:scheme="app" android:host="jimliuxyz.com"&gt;&lt;/data&gt;&lt;/intent-filter&gt; adb shell am start -W -a android.intent.action.VIEW -d "app://jimliuxyz.com" com.jimliuxyz.tsnoteam : activity maneger-W : wait for launch to complete[-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;]package不一定要 如果要用override fun onNewIntent()處理 activity要為singleTop之類 TaskStackBuilderrefref 用於憑空建立parent activity於TaskStack中當MsgActivity是從其他app(intent或deep link)啟動時 並沒有自己的back stack 所以按下back按鈕時 無法回到MainActivity 此時就需要NavUtils工具 Minifest 指定android:parentActivityName為欲返回的MainActivity &lt;activity android:name="com.example.myfirstapp.MsgActivity" android:label="display_message" android:parentActivityName="com.example.myfirstapp.MainActivity" &gt; &lt;!-- Parent activity meta-data to support 4.0 and lower --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.myfirstapp.MainActivity" /&gt;&lt;/activity&gt; //通常都經由ActionBar左上角的箭頭驅動返回事件(android.R.id.home)getActionBar().setDisplayHomeAsUpEnabled(true); //測試不okIntent upIntent = NavUtils.getParentActivityIntent(this);if (NavUtils.shouldUpRecreateTask(this, upIntent)) &#123; //非處於自己app的back stack中時 TaskStackBuilder.create(this) .addNextIntentWithParentStack(upIntent) .startActivities();&#125; else NavUtils.navigateUpTo(this, upIntent); 透過PendingIntent預先設定好(測試ok)notify-user Intent intent = new Intent(this, MsgActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addNextIntentWithParentStack(intent); //依manifest設定的android:parentActivityNamepi = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); launchMode manifest可設定activity的android:launchMode standard : 不斷新建堆疊a - a&apos; - a&apos;&apos; singleTop : 同standard,但當該activity已處於stack top時不會再新建a - a - a - b - a&apos; - a&apos; singleTask : 不會重開,該activity出現時勢必將task中其他task全部拋掉a - a - b - c - d - a [back]離開app singleInstance : 不會新建,該activity的task僅允許自己使用a - a - a [back]離開a回到b b - [back]離開b回到home 簡述 standard - 不斷重開堆疊 : 預設 (可能有多個aty重複) singleTop - 頂端不新建 : 合理避免重複 (可能有多個aty重複) singleTask - 頂端排他 task pop all : Home singleInstance - 獨佔 : 供別的app使用 single指的是activity不新建 但會執行onNewIntent() taskAffinity allowTaskReparentingaffinity類似一個groupId的概念 activity預設的affinity為package name當一個activity以FLAG_ACTIVITY_NEW_TASK啟動時會以affinity去找該被加到哪個task中 FLAG_ACTIVITY透過intent開啟的activity該依循何策略進入task或操作stack FLAG_ACTIVITY_NEW_TASK(同singleTask) : aty會在自己的task中 new aty : 為aty新增tasknew aty : push進aty原屬的taskold aty : 顯示task但aty不會到top (怪怪的) FLAG_ACTIVITY_CLEAR_TOP : pop出原本在其上者 b是FLAG_ACTIVITY_CLEAR_TOPa - b - c - d - b (此時cd會被pop出,剩下ab) FLAG_ACTIVITY_BROUGHT_TO_FRONT : activity會to front FLAG_ACTIVITY_MULTIPLE_TASK : 能以另一個task啟動(act實體個別存在不同的task) FLAG_ACTIVITY_SINGLE_TOP(同singleTop) FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET與FLAG_ACTIVITY_RESET_TASK_IF_NEEDED : 1.設定清除點 2.pop掉清除點與之後的 還有很多…]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent]]></title>
    <url>%2Fhome%2F%2FAndroid%2FIntent.html</url>
    <content type="text"><![CDATA[概述 一個意圖/命令的容器putExtra僅能傳遞native type,或序列化物件(Serializable或Parcelable) 顯示 : 指定元件的類別 隱式 : 僅提供ACTION/CATEGORY/URI 不指定元件的類別 intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(file), "image/*");startActivity(intent);intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://..."));startActivity(intent); Intent導航與返航####導航 //啟動startActivity(intent)startActivityForResult(intent, req_id) //透過activity或fragment呼叫//被啟動override fun onCreate(savedInstanceState: Bundle?) //首次啟動override fun onNewIntent(intent: Intent?) //已啟動 但有新intent ####返航 setResult() //均透過activityoverride fun onActivityResult(int requestCode, int resultCode, Intent data) fragment有startActivityForResult與onActivityResult,但沒有setResult PendingIntent 封裝執行intent的機制 類似於將startActive/startService與intent封裝起來 丟給系統 透過系統機制讓user觸發intent此外尚有些flag策略 通常就是和Notification合用 Notification 位於手機上方的通知欄 可作為service的ui使其能顯示狀態與被使用者操作 //NotificationManagernm = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);//Intentintent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);//PendingIntentpi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);//NotificationCompat.Builderbuilder = new NotificationCompat.Builder(this, "practice_channel") .setSmallIcon(android.R.drawable.ic_dialog_info) .setContentTitle(getString(R.string.time_to_practice)) .setContentText(getString(R.string.it_is_time_to_practice)) .setAutoCancel(true) .setContentIntent(pi);//產生與取消nm.notify(NOTIFICATION_ID, builder.build());nm.cancel(NOTIFICATION_ID);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android CheatSheet]]></title>
    <url>%2Fhome%2F%2FAndroid%2FCheatSheet.html</url>
    <content type="text"><![CDATA[//下載圖片img = Drawable.createFromStream(new URL(url).openStream(), "");//顯示短暫訊息Toast.makeText(this, "...", Toast.LENGTH_SHORT).show();getResources().getStringArray(R....);getResources().getXml(R....); //XmlResourcesParsergetAssets().open("...")getSystemService(Service...)//URIMediaStore.Images.Media.INTERNAL_CONTENT_URI 查看activity back stackadb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' | sed -En -e '/com.jimliuxyz/p']]></content>
      <tags>
        <tag>Android</tag>
        <tag>Cheat Sheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[協助工具]]></title>
    <url>%2Fhome%2F%2FAndroid%2FHelpingTools.html</url>
    <content type="text"><![CDATA[uiautomatorviewer 檢視View階層 (方面找ID) cd ~/Library/Android/sdk/tools/bin/ uiautomatorviewer draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStackadb shell dumpsysadb shell dumpsys Android-Debug-Databaseref, 本地端連結 dependencies &#123; debugImplementation 'com.amitshekhar.android:debug-db:1.0.0'&#125; # Working with emulatorcd /Users/jimliu/Library/Android/sdk/platform-tools./adb forward tcp:8080 tcp:8080 LeakCanaryLeakCanary 檢測記憶體洩漏 (針對activity生命週期) dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'&#125; public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) return; LeakCanary.install(this); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功能測試]]></title>
    <url>%2Fhome%2F%2FAndroid%2FTesting.html</url>
    <content type="text"><![CDATA[JUnit 僅於本地JVM上測試 又稱單元測試(函數功能測試) 不依靠android環境 以滑鼠右鍵選單”Go To&gt;Test”快速建立test class Annotation @Test 註解一函數為 測試使用 @Test(expected = Exception.class) 使符合預期時拋出異常 @Test(timeout=100) 指定測試需在100ms內完成 @Before 註解一函數為 每個測試函數執行要先執行的函數 @After 邏輯同上 @BeforeClass @AfterClass 邏輯同上 但僅為整個class執行一次 @Mock 宣告一個假物件 @Captor 宣告一個叫用參數捕捉器(以取得叫用參數) @Spy 監視一個真物件 @Rule 修飾TestRule Matchers 比對器 類似過濾行為 能以廣義的形容區別物件 eqis 是某個objectisA 是某個classnotanyInthasItem Assert 斷言結果 判斷值是否符合預期 若不符合斷言即為測試失敗 //斷言結果需為trueassertTrue("test failure", mockins.func() == 1);//斷言instance.func()執行回傳為1assertThat("test failure", mockins.func(), is(1)); //用Matcher判斷assertThat(mockins.getList(), not(hasItem(not_expected));//assertEquals mockito 製作假物件ref 通過製作假物件與指定其反應回傳 來驗證該假物件是否被呼叫?以何參數呼叫? 通常被測物需為真物件(因為要測試他的邏輯) 其依賴物為假物件(不著重邏輯是否正確或回傳什麼 僅著重是否被真物件正確叫用) //1. 產生mock物件@Mock MyClass mockIns; //不需要newMockitoAnnotations.initMocks(this); //但之後要做init使class內的@Mock生效//1. 產生mock物件LinkedList mockList = mock(LinkedList.class);LinkedList mockList = mock(LinkedList.class, Mockito.RETURNS_SMART_NULLS); //指定預設的回傳//2. 指定mock物件的反應 (此動作稱為Stubbing)when(mockList.get(0)).thenReturn("it's a mock string");when(mockList.get(1)).thenThrow(new RuntimeException());when(mockList.get(anyInt())).thenReturn("element");when(mockList.size()).thenReturn(1, 2, 3); //每次回傳都不同//doReturn, doThrow, doAnswer, doNothing, doCallRealMethoddoThrow(new RuntimeException()).when(mockList).clear();reset(mockList); //清除所有Stubbing//3. 經過某些動作操作後...即可進入驗證mockedList.add("once");//驗證1. 驗證mock物件的方法是否被呼叫(times, atLeast, atMost, atLeastOnce, never, timeout)verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); verify(mockedList).set(anyInt(), eq("element")); //用Matchers便於廣義的驗證//驗證2. 連帶驗證呼叫順序InOrder inOrder = inOrder(mockedList);inOrder.verify(mockedList).add("first");inOrder.verify(mockedList).add("second");//驗證3. 捕捉呼叫參數ArgumentCaptor&lt;String&gt; args = ArgumentCaptor.forClass(String.class);mockedList.add("John");verify(mockedList).add(args.capture()); //驗證add的叫用 同時捕捉叫用的參數assertEquals("John", args.getValue()); spy監視真物件List list = new LinkedList();List spy = spy(list);//之後spy即類似mockito的操作 TestRule 能在測試函數前後插入動作 例如偵測測試函數的執行時間 加入TestRule時需用@Rule註解才能與JUnit掛鉤 public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; //base : 一個能夠驅使測試函數被執行的物件 //description : 一個相關於測試函數環境的描述 return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; //即測試前 base.evaluate(); //即測試後 &#125; &#125;; &#125;&#125;@RuleMyRule rule = new MyRule() EspressoAndroid testing samples 依賴於JUnit的一個測試框架 UI測試 依靠android環境執行 針對view元件進行驗證 基本三步驟 取得view或data的互動 onView / onData 執行動作 perform 檢查驗證 check 大致動作//操作viewonView(withId(R.id.fab_add_task)).perform(click());//檢查viewonView(withId(R.id.add_task_title)).check(matches(isDisplayed())); onView ViewInteraction onView(Matcher viewMatcher) 透過matcher取得view的控制 //Matcher&lt;View&gt;allOf 合併多個matcherwithIdwithTextisDisplayed//其父view的id為R.id.recyclerViewisDescendantOfA(withId(R.id.recyclerView))//其父view為ListView.classisDescendantOfA(isAssignableFrom(ListView.class))hasDescendanthasSibling perform ViewInteraction perform(final ViewAction… viewActions) 執行動作 //ViewActionclick()LongClick()clearText()replaceText("")typeText("")closeSoftKeyboard()//專為RecyclerView設計(actionOnItem)onView(allOf(withId(R.id.recyclerView))) .perform(actionOnItem(hasDescendant(withText("title")), click())); check ViewInteraction check(final ViewAssertion viewAssert) 斷言 //ViewAssertionmatches(isDisplayed()) //使用view matcher來斷言doesNotExist()isChecked() 其他pressBack() //按下返回鍵TestUtils.rotateXXX() //控制手機旋轉TestUtils.getCurrentActivity() TestUtils 一個工具類 提供靜態方法控制手機裝置 rotate / getCurrentActivity 自訂Matcher//一個回傳Matcher的functionprivate Matcher&lt;View&gt; withItemText(final String itemText) &#123; return new TypeSafeMatcher&lt;View&gt;() &#123; @Override public boolean matchesSafely(View item) &#123; return allOf( //其父view為ListView.class isDescendantOfA(isAssignableFrom(ListView.class)), //且text為itemText withText(itemText) ).matches(item); &#125; @Override public void describeTo(Description description) &#123; description.appendText("is isDescendantOfA LV with text " + itemText); &#125; &#125;; &#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2Fhome%2F%2FAndroid%2FContentProvider.html</url>
    <content type="text"><![CDATA[Loader Fetch local data from disk using a Loader on a background thread Propagate data changes through a Loader to the UI refvideo 簡單理解為一個監聽器介面機制 很主要目的在實現LiveData(即時資料顯現)(ContentObserver) Activity重建時LoaderManager中已建立的Loader不需重建 能透過id續用 AsyncTaskLoader (abstract extends Loader) 分離IO與UI使用的執行緒 因為ContentProvider執行的thread是caller提供的 透過AsyncTaskLoader能讓caller處於非main thread 避免影響ui CursorLoader (extends AsyncTaskLoader) 建立cursor並透過cursor監聽uri是否被通知為變更 若是則Loader會叫用callback 使用loader//實作介面this implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;override fun onCreateLoader(id: Int, args: Bundle?): Loader&lt;Cursor&gt; &#123; //要求建立cursor (語句與用contentResolver.query建立時相同) return CursorLoader(this, URIContract.MyEntry.URI, arrayOf("_id", "value", "time"), null, null, null)&#125;override fun onLoadFinished(loader: Loader&lt;Cursor&gt;?, data: Cursor?) &#123; //loader建立完成 (cursor設定監聽的uri) data?.setNotificationUri(contentResolver, URIContract.MyEntry.URI) adapter!!.swapCursor(data)&#125;override fun onLoaderReset(loader: Loader&lt;Cursor&gt;?) &#123; //loader需被結束(釋放資源) adapter!!.swapCursor(null)&#125;//建立CursorAdapteradapter = SimpleCursorAdapter(this, android.R.layout.simple_list_item_1, null, arrayOf("value"), intArrayOf(android.R.id.text1), 0)var lv = findViewById&lt;ListView&gt;(R.id.lv)lv.adapter = adapter//啟動loader (啟動後的實體manager自己會管理)loaderManager.initLoader(0, null, this) 自訂Loaderpublic class StringLoader extends AsyncTaskLoader&lt;String&gt; &#123; private String mCache; public StringLoader(Context context) &#123; super(context); &#125; @Override protected void onStartLoading() &#123; if (mCache != null) &#123; //跳過loadInBackground super.deliverResult(mCache); &#125; else &#123; //驅動loadInBackground與deliverResult達到資料更新 forceLoad(); &#125; &#125; @Override public void deliverResult(String data)&#123; mCache = data super.deliverResult() &#125; @Override public String loadInBackground() &#123; return "data"; &#125; @Override public void onReset()&#123; //結束該loader 釋放資源 super.onReset() &#125;&#125; ContentProviderrefref 行為 提供資料存取的獨立個體 應該是被動的存在 有權限的約束 Activity靠ContentResovler與ContentProvider聯繫 以uri指定資源的路徑 回傳Cursor給外部使用 MINE type 即 類型/子類型 (應用類型/文件類型) 例如 text/html ContentProvider的應用類型固定為cursor 文件類型可以自訂 "vnd.android.cursor.dir/multi" //multiple record"vnd.android.cursor.item/single" //single record uri ContentUris URI解析工具 //建立uriUri uri = Uri.parse("content://com.jxyz.provider/user") //添加iduri = ContentUris.withAppendedId(uri, 5); //取出idlong personid = ContentUris.parseId(uri); UriMatcher URI比對工具 matcher = new UriMatcher(NO_MATCH); //不匹配時回傳NO_MATCHmatcher.addURI("com.jxyz.provider", "user", USER); //匹配回傳URI_USERmatcher.addURI("...", "user/#", USER_ID); //# : intmatcher.addURI("...", "user/info/*", USER_NAME); //* : stringswitch(matcher.match(uri))&#123; case URI_USER: ...&#125; ContentObserver 監視uri對應內容的變化 //監聽uri變動contentResolver.registerContentObserver(uri, true, mContentObserver)//通知uri變動contentResolver.notifyChange(uri, null);//要求cursor監聽uri (使CursorLoader能自動更新)cursor.setNotificationUri(context.contentResolver, uri) 權限//宣告本app自訂的權限&lt;permission android:name="com.jxyz.provider.READ" android:protectionLevel="normal"/&gt;//provider就可用該權限指定需要受約束的元件&lt;providerandroid:name=".MyProvider"android:authorities="com.jxyz.provider"android:readPermission="com.jxyz.provider.READ"android:exported="true"&gt;&lt;/provider&gt;//其他app若要有該權限 則需如下宣告讓user同意該使用權限&lt;uses-permission android:name="com.jxyz.provider.READ"/&gt; public class MyProvider extends ContentProvider &#123; private Context mContext; DBHelper mDbHelper = null; SQLiteDatabase db = null; //Application.instance.packageName() + ".provider" public static final String AUTOHORITY = "com.jxyz.provider"; public static final int USER_CODE = 1; public static final int USERID_CODE = 1; private static final UriMatcher mMatcher; static&#123; mMatcher = new UriMatcher(UriMatcher.NO_MATCH); mMatcher.addURI(AUTOHORITY,"user", USER_CODE); mMatcher.addURI(AUTOHORITY,"user/#", USERID_CODE); &#125; @Override public boolean onCreate() &#123; mContext = getContext(); mDbHelper = new DBHelper(mContext); db = mDbHelper.getWritableDatabase(); //init mock db.execSQL("delete from user"); db.execSQL("insert into user values(1,'Carson');"); db.execSQL("insert into user values(2,'Kobe');"); return true; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; db.insert("user", null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; int code = mMatcher.match(uri); if (code == USERID_CODE)&#123; long userid = ContentUris.parseId(uri); &#125; //後續資料如需傳遞到ListView中 需有_id欄位 return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null); &#125; @Override public String getType(Uri uri) &#123; switch(mMatcher.match(uri))&#123; case USER_CODE: return "vnd.android.cursor.dir/multi"; case USERID_CODE: return "vnd.android.cursor.item/single"; &#125; return null; //封閉的app也可以直接回null &#125;&#125; 訪問ContentProviderContentResolver resolver = getContentResolver();//insertContentValues values = new ContentValues(); values.put("_id", 5); values.put("name", "allen");resolver.insert(uri, values);//queryCursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null);//updaterui = Uri.parse(uri + "/" + "7");int result = resolver.update(uri, values, null, null);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2Fhome%2F%2FAndroid%2FActivity.html</url>
    <content type="text"><![CDATA[Activity重建與復用ref 畫面旋轉 或 變更語系 造成Activity重建 連帶影響狀態或物件需要重建 Bundle與Map類似 但key必須是string 用來存放資料 1. Minifest.xml中抑制重建 在minifest加入android:configChanges提示為自行處理 使Activity不進行重建 //android:configChanges="locale|layoutDirection"@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig);&#125; 2. onRetainCustomNonConfigurationInstance 與 getLastCustomNonConfigurationInstance 複寫onRetain將稍後要還原內容交給系統 被重建後再取回 @Overridepublic Object onRetainCustomNonConfigurationInstance() &#123; return netWorkTask;&#125; 3. Retain Fragment (官方建議使用) 設定setRetainInstance(true)即可讓Fragment復用不重建(app狀態須寫在Fragment中) (之後需注意activity/context的更動) //以下code看似在復用MyFragment,但事實上MyFragment仍會在背景被建立//除非fragment設定setRetainInstance(true)if(getSupportFragmentManager().findFragmentByTag(ID) == null) &#123; getSupportFragmentManager().beginTransaction().add(new MyFragment(), ID).commit();&#125; View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view 與 Style]]></title>
    <url>%2Fhome%2F%2FAndroid%2FViewNStyle.html</url>
    <content type="text"><![CDATA[/Users/jimliu/Library/Android/sdk/platforms/android-26/data/res/values/styles.xml 容器類型的view ListView : 列表顯示 RecyclerView : 列表顯示 更為靈活 取代ListView ScrollView : 可滑動的顯示 gridview / gallery / cardview LayoutInflater layout的實體化工具 將layout resource轉成view的實例 Adapter 設計模式中稱作”適配器” 簡單的說就是轉換器 以view容器的應用來說 就是將’資料數據’轉換填充到’ListView裡的各個item view’上 //以simple_list_item_1做為item viewadp = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1);//替adp添加兩筆資料adp.add("first");adp.add("second");//將adp指定給listview使用lv = findViewById(R.id.listView);lv.setAdapter(adp); BaseAdapter@Overridepublic View getView(int pos, View convertView, ViewGroup parent)&#123; //getView用於取得item view //convertView : 先前已建立的view,用於優化效能&#125;notifyDataSetChanged(); //向view通知data有變動 view才會refresh ViewHolder 主要用意在復用item view時避免重複findViewByIdv.setTag(holder);holder = (Holder) v.getTag();//RecyclerView.Adapter不用這樣寫 SurfaceView 有自己的ui thread 用於較佔時間繪圖應用 (VideoView/ImageView) View狀態的save與restore view需要設定id才能被儲存 android:saveEnabled 預設已為true 自定義View / ViewGroup 先分清元件與佈局的角色 大致 需要複寫onMeasure (父要求子做元件尺寸測量measureChildren) (子則量測自己) 量測完執行setMeasuredDimension ViewGroup需複寫 onLayout (排定子的繪出位置) 逐個叫用child.layout View需複寫 onDraw (繪製本身) MeasureSpec定義 為一整數 前3bit做為mode 之後作為size(寬或高) 做為父要求子做尺寸量測時的參考 (由父提供spec 子做量測) UNSPECIFIED : 沒有任何約束 EXACTLY : 約束明確的size AT_MOST : 約束上限的size LayoutParams 一個ViewGroup要遍歷所有子View的LayoutParams才知道每個子View要求被如何佈局 (所以是ViewGroup定義的 但由子View描述給其ViewGroup參照的) child.getLayoutParams Theme與Style aad:Construct a layout using XML or Java code aad:Create a custom view class and add it to a layout aad:Implement a custom application theme aad:Apply a custom style to a group of common widgets 兩者僅有使用廣度上的差別 theme針對app或activity, style針對元件, 基本上都是style 單位 dp : 1dp=160ppi的px長度 (像素隨密度改變)sp : 類似dp 用於文字pt : 點 用於文字px : 像素ppi, dpi : 像素密度 pixel per inch 每英寸像素數mm : 毫米in : 英吋 attr宣告 寫在values/attrs.xml 作為元件的屬性 (元件屬性是從xml建立的 java code僅是依資源ID取值賦予元件) attr及所有資源都會自動產生於R類中的id &lt;attr name ="mycolor" format= "color" /&gt; 屬性名稱一多容易重複混淆 用declare-styleable可將其分類 java code也會比較好讀取 //將多個attr並於declare-styleable有利組織化與讀取 在R類中會是一個resId的陣列&lt;declare-styleable name="MyStyle"&gt; &lt;attr name ="mycolor" format= "color" /&gt;&lt;declare-styleable&gt; attr的賦值//在元件標籤中賦值 (前半部需指定命名空間)&lt;TextView app: mycolor="#00ff00" android:style="@style/MyStyle"&gt;&lt;/TextView&gt; //在style/theme中賦值&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="mycolor"&gt;#0037ff&lt;/item&gt; &lt;item name="android:textViewStyle"&gt;@style/textviewstyle&lt;/item&gt;&lt;/style&gt; 元件取得attr的來源 一個元件的一個attr可能有多個來源 (大致的優先順序) 於元件標籤中或標籤中指定的style有描述 從application或activity指定的theme中有描述 theme中指定的style有描述 (即指android:textViewStyle)(format=”reference”) 元件hardcode裡有預設的style 元件取得attr obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) AttributeSet 即元件標籤中的描述 attrs 欲取得的attr defStyleAttr 預設的style的attr (在theme中經由該attr參考到確切的style)(即指android:textViewStyle) 透過這樣的機制就可在theme中複寫掉元件的整個style defStyleRes 預設的style 若沒有可丟0 public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0); TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.MyStyle, defStyleAttr, defStyleRes); int color = a.getColor(R.styleable.MyStyle_mycolor, Color.BLACK); a. recycle();&#125; 可見性的設定View.visableView.invisable : 看不見 但仍佔位置View.gone : 消失 不佔位置 模糊視窗(blur)getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND); ViewStub一個空的view 用來延遲載入另一個view時當作佔位用 SpannableString v.setText()通常傳入字串 更複雜可以傳入(html, img_getter, tag_handler) 另一種是傳入SpannableString 用途都是達到圖文混排 其他onTouch 和 onTouchEvent onTouch優先於onTouchEvent 若onTouch回傳true則事件就不會再往下傳播onTouch是作用於view處於enable狀態下]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Accessibility]]></title>
    <url>%2Fhome%2F%2FAndroid%2FAccessibility.html</url>
    <content type="text"><![CDATA[Accessibility 無障礙能力官方EventAccessibilityServiceAccessibilityEventAccessibilityService aad:Apply content descriptions to views for accessibility aad:Add accessibility hooks to a custom view 自訂View時需要sendAccessibilityEvent 否則只要注意contentDescription focusable nextFocus]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android環境概念]]></title>
    <url>%2Fhome%2F%2FAndroid%2Fbasic.html</url>
    <content type="text"><![CDATA[編譯流程 Dalvik : Android的JVM dex : 類似jar appt：Android Asset Packaging Tool MinifestMinifest-activity參數 Contextref context可理解為app的執行環境 (包含狀態與工具) ContextWrapper會包含一個Context實例(mBase)達到複製Context Application與Activity與Service雖都能當context用(但非對應同一個mBase) 要注意Activity與Service是有被回收的可能 避免將其當context傳遞 但某些關聯性的動作只能使用activity(像是show dialog) //若context的傳遞會被對方持有時 盡可能使用Application的contextcontext.getApplicationContext() Application 繼承Context 可以理解為另外一個層級的執行環境透過Manifest指定自訂的Application類 &lt;!--Manifest--&gt;&lt;application android:name=".CustomApplication"&gt; SharedPreferencekey/value pair的儲存器 用於儲存app的設定值 MODE_MULTI_PROCESSMODE_PRIVATEsp = PreferenceManager.getDefaultSharedPreferences(context);sp = getSharedPreferences("mysp", Context. MODE_PRIVATE);sp.getBoolean("key", false);sp.edit().putBoolean("key", false);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2Fhome%2F%2FAndroid%2FService.html</url>
    <content type="text"><![CDATA[Service app透過startService啟動service 執行於UI Thread 不會自動被系統結束 只能自己透過stopSelf結束 onStartCommand的回傳決定Service被系統殺掉後的行為 START_STICKY : Service被殺掉, 系統會重啟, 但是Intent會是null。 START_NOT_STICKY : Service被系統殺掉, 不會重啟。 START_REDELIVER_INTENT : Service被系統殺掉, 重啟且Intent會重傳。 Remote Service 同為Service僅是啟動/取得方式不同 主要用於跨process的應用 即透過bindService(intent, conn, BIND_AUTO_CREATE)取得binder實例操控service 以bindService啟動service會造成Service綁定於App的生命週期 用AIDL建立共通介面 內建已經做好了一個共通的binder 可以透過(Message(msg)).getBinder()建立 基本上是用handler處理message的方式傳遞訊息 (就不用建AIDL了) android:process屬性 : 可讓Service執行於自有的process上(remote service) 通常會設為:remote(這似乎屬於一個自訂的命名) Binder 在android中做process間通訊用 (底層機制應該是linux的share memory) AIDLref Android Interface Definition Language一種程式語言 用於定義介面 用於IPC(Process間通信) 與java的interface寫法類似 //IRemoteService.aidlpackage com.example.service;interface IRemoteService&#123; int getData(String key)&#125; 存成MyDataBinder.aidl,會被自動轉譯產生一個java檔,產生IRemoteService.Stub類別,作為server與client間共通的介面 server端實做IRemoteService.Stub的method即IBinder 並在onBind時回傳 client端也必須有該.aidl檔才能編譯 並透過IRemoteService.Stub.asInterface將IBinder轉為代理物件供使用 Remote Service範例實做介面//RemoteService.javapublic class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getData()&#123; return "hello"; &#125; &#125;;&#125; start service &amp; bind//Activity.java&#123; Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125;IRemoteService mIRemoteService;ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; public void onServiceDisconnected(ComponentName className) &#123; mIRemoteService = null; &#125;&#125;; IntentService Service的子類 需在manifest中宣告 Service+Handler+Looper的封裝 即類似一個task queue 當所有任務執行完時銷毀 有任務再重新建立 public class IntentServiceDemo extends IntentService&#123; public IntentServiceDemo(String name)&#123; //name for HandlerThread super(name); &#125; @Override protected void onHandleIntent(Intent intent)&#123; //進入異步 &#125;&#125;Intent intent = new Intent(this, IntentServiceDemo.class);startService(intent); JobService / JobSchedulerrefandroid-JobScheduler aad:Schedule a background task using JobScheduler Service的子類 排程不緊急或與設備狀態有關的任務(受系統牽制) 以優化系統電力消耗 在(&gt;=Build.VERSION_CODES.N)中限制了interval最小為15m flex最小為5m 比較適合惰性的任務 (時間不會準確) JobScheduler : 整個app僅有一個JobScheduler實體用來排程任務(丟入JobInfo) ComponentName : 一個pkg+cls用以描述元件 Component泛指四大組件 常用於Intent JobInfo : 指定任務執行模式 依時間/網路/Idel/充電 (透過Builder模式構建) 儲存extras當param給JobService執行 JobService : 當onStartJob時得到任務 回傳false表示任務已執行結束 回傳true表示任務進入異步執行 完成後須自行呼叫jobFinished 意象: JobService如同Service般執行 經由JobInfo建立不同任務的參數 由JobScheduler指派執行時機 呼叫JobService.onStartJob執行 執行於ui thread,耗時任務仍需另使用AsyncTask &lt;service android:name=".service.MyJobService" android:permission="android.permission.BIND_JOB_SERVICE" android:exported="true"/&gt; JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); onStopJob僅在系統強制要停止任務時呼叫 AlarmManagerref aad:Schedule a time-sensitive task using alarms 安排定時任務(time-sensitive task) 時間到用PendingIntent開啟服務或Activity 比起Java SE的Timer, AlarmManager能夠喚醒休眠的Android系統(透過PendingIntent) 被限制了interval最小為60s (時間不會準確) val intent = Intent(this, AlarmReceiver::class.java)val pi = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);val am = getSystemService(Context.ALARM_SERVICE) as AlarmManageram.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi)am.setRepeating(RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, pi);am.setRepeating(ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 1000 , 5 * 1000 , pi);class AlarmReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; &#125;&#125; &lt;receiver android:name=".AlarmReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; type(組合) RTC : 以系統時間判斷 (也就是說系統時間更改將立即反應到鬧鐘上) ELAPSED_REALTIME : 以系統流逝的時間差判斷 WAKEUP : 能於睡眠中喚醒 POWER_OFF_WAKEUP : 能於關機中喚醒]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知識樹]]></title>
    <url>%2Fhome%2F%2FAndroid%2F00.index.html</url>
    <content type="text"><![CDATA[開發紀錄 Cheat Sheet 入門知識IDE編譯流程GradleAndroidManifest.xml 供Android系統得知此app包含的組件內容與設定 class Context 可視為app執行環境(上下文) 許多操作都是需要有執行環境才能完成Application/Activity/Service都有各自的Context 但生命週期不同 class Application 做為app的single instance 相當於app的母生命週期 SharedPreferenceProcess 一段已載入記憶體執行的程式碼 例如一個執行中的app就是一個process Thread 實質執行程式碼的單元app中起始的thread稱為main thread又稱為ui thread 其最主要的工作為在每個16ms繪製一次畫面 若沒辦法如期執行就會造成畫面lag ResourceIntent每個app都是獨立的process 無法直接互動 Intent則做為之間互動的意圖/訊息內容. 透過intent描述欲執行的動作 交由android系統執行. 通常執行動作都是啟動某個app或service. PendingIntent PendingIntent會持有一個intent 交給android系統保留 如同委託系統代為於特定時機執行 (此時intent的執行與否已與建立該intent的app無關了) IntentFilter 對於能被intent啟動的對象來說(例如Service) 需要過濾不相干的意圖 (即需預先描述相關的意圖於Filter中) Notification 位於手機上方的通知欄 四大組件即Activity/Service/ContentProvider/Broadcast 這些組件的共通點就是能被別的app透過intent啟動或間接存取 四大組件生命週期互不相同 但都是經由系統實例化誕生 或依系統機制結束 我們僅能發送intent告知意圖 Activity可視為一個頁面的持有者 Activity重建與復用 Activity常有機會被系統重建 例如螢幕翻轉或語系更動 重建後可能造成狀態的喪失 Activity導航Deep Link 使app能透過超連結方式被開啟 TaskStack 相關於頁面的堆疊 即上一頁的功能 launchMode 指定TaskStack堆疊的策略 FLAG_ACTIVITY 用Intent開啟Activity的堆疊策略 Service可視為一個服務 服務能提供給自己或別的app 或常態的在背景默默執行Service衍生出了許多不同的類別 用以達到特定的需求 IntentService Service執行於main thread 但IntentService會切到worker thread佇列執行 JobService 與 JobScheduler 能依系統狀態約定任務的執行 例如有網路時才執行 使更有效率的驅動任務 節約電力 ContentProvider可視為一個資料提供者 提供資料給自己或別的app 透過特定的uri即可存取特定的ContentProvider 例如’電話簿聯絡人’等資訊就是透過ContentProvider運作 Cursor 可以理解為資料指針 其持有一群資料 透過指定cursor的位置即可取得某一筆資料 CursorLoaderBroadcast發送或接收廣播 例如系統電力不足時會發送廣播給有註冊的接收器 Fragment可視為一個頁面中的一小部分的持有者 用意在將整個頁面拆散 其生命週期基本上是依附Activity上 或由FragmentManager管理 Database MySQLAndroid內建的Database Thread / Task為了順利與容易的協調各式工作 各種衍生的類別孕育而生 Handler 一個透過當下執行緒建立的message handler 其目的在使工作能透過該執行緒佇列的被執行 可以作為執行時切換執行緒的手段 或當佇列安插異步工作於執行緒 Looper 一個透過當下執行緒建立的訊息接收器 其內部包含一個message queue 是促成Handler運作的背後推手 AsyncTask 建立一個異步工作 執行於worker thread 且提供機制與main thread互動 AlarmManager 安排定時任務(如鬧鐘般) 用PendingIntent設定 時間到開啟Activity或Service能夠喚醒Android系統 RecyclerViewView &amp; StyleLayoutWidget app widget 手機HomeScreen上的小工具 TestingJUnit Espresso Monkey 壓力循環測試 3rd Party LibraryDagger 依賴注入工具 何謂依賴? A物件需要B物件才能運作 B即為A的依賴物 將依賴物帶進A的實現方式即稱為依賴注入將各個物件實體的建立或獲取寫成函數方法 Dagger會建立其之間的依賴關係 並將依賴注入到物件中 RxJava ReactiveX 響應式編程 將數據流轉化為事件觸發 例如[1,2,3]會分別產生3個事件流之間可經由運算符號(即鏈式函數)加工產生新的流 Gson Json文件的解析 工具uiautomatorviewer 檢視View階層 (方面找ID) draw9patch 製作不受縮放影響畫質的按鈕外框圖樣 (避免四角被伸縮) 查詢TaskStack adb shell dumpsys Android-Debug-Database mysql網頁伺服器介面 LeakCanary 記憶體洩漏偵測 其他LruCache 快取 當空間吃緊時能首先移除掉近期最少使用的(Least recent used)三級快取(緩存)策略 即 記憶體中快取-&gt;本地端資料-&gt;網路資料 依其優先順序取得資料 以得到最快速度 Accessibility 輔助殘疾人士 使其便於操作app Animation 動畫 序列化Serializable / ParcelableSerializable 對於javaBean類只要implements Serializable 不用額外實現方法即可對primitive type序列化 特殊物件則須額外實現用反射實現 所以速度慢 Parcelable 要有一個名為CREATOR的靜態變數實現Creator 用以從序列還原物件要實現writeToParcel與createFromParcel (寫讀順序要對應)因為hard coding所以速度快 StorageRoom MySql的另一種操作方式 ArchitectureComponent LifeCycle與Observable的整合 使其產生LiveData 套用MVVM架構 debug過程 操作內建的debug工具 懸浮視窗ref 即將view依LayoutParams加到WindowManager做為remote view處理 inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);removeView = (RelativeLayout)inflater.inflate(R.layout.remove, null);windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);windowManager.addView(removeView, layoutParam); 雜項]]></content>
      <tags>
        <tag>Android</tag>
        <tag>知識樹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安裝紀錄]]></title>
    <url>%2Fhome%2F%E7%B4%80%E9%8C%84%2FSingle%2FHexo%E5%AE%89%E8%A3%9D%E7%B4%80%E9%8C%84.html</url>
    <content type="text"><![CDATA[Hexo 、NexT 站內連結若用相對連結在首頁跟文章內顯示的連結路徑不同 UTF-8編碼中若參雜其他編碼會讓search.xml錯誤而無法搜索 目標本地端透過Hexo建立網站骨架 並將markdown文章轉為html 上傳到github做為blog網站 安裝node.js node.js為一本地端的js執行平台 用途廣泛 npm (安裝node.js時會一並安裝) 一個套件管理系統 能透過命令列安裝套件 安裝git 版本控管工具 做為本地端工具與github連結 github 一個線上的版本控管工具 其附加功能使其能成為http伺服器其Repo需命名為”ACCOUNT_NAME.github.io” #安裝hexo命令列工具npm install -g hexo-cli#在該目錄建立blog目錄hexo init blog#安裝node.js環境cd blognpm install#發佈到github的工具npm install hexo-deployer-git --save#使網頁能即時自動更新的工具(會造成一些問題 1.網頁空白 2.搜尋失效)(查問題時最好移除)npm install hexo-browsersync --save#下載慣用的blog主題佈局(NexT)git clone https://github.com/iissnan/hexo-theme-next themes/next#站內搜尋工具 (:category開頭會無法連結)npm install hexo-generator-searchdb --save 常規操作#新增文章hexo new "My New Post"#啟動本地端serverhexo server#產生文件hexo g --watch#上傳到githubhexo d 語法測試12345 1 2 測試 測試 測試 AB aaa bbb]]></content>
      <categories>
        <category>紀錄</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
